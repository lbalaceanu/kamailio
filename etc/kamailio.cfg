#
# $Id$
#
# This a very basic config file w aliases and anamed route but
# w/o authentication, accounting, database, multi-domain support etc.
# Please refer to sip-router.cfg for a more complete example
#

# ----------- global configuration parameters ------------------------

# *** To enable mysql: 
#!define WITH_MYSQL

# *** To enable authentication execute:
#     - enable mysql
# define WITH_AUTH
#     - add users using 'kamctl'

# *** To enable persistent user location execute:
#     - enable mysql

#!define WITH_USRLOCDB

debug=1         # debug level (cmd line: -dddddddddd)
#memdbg=10 # memory debug message level
#memlog=10 # memory statistics log level
#log_facility=LOG_LOCAL0 # sets the facility used for logging (see syslog(3))

#fork=no
log_stderror=yes


check_via=no    # (cmd. line: -v)
dns=no          # (cmd. line: -r)
rev_dns=no      # (cmd. line: -R)
#port=5060
children=1
#user=sip-router
#group=sip-router
#disable_core=yes #disables core dumping
#open_fd_limit=1024 # sets the open file descriptors limit
#mhomed=yes  # usefull for multihomed hosts, small performance penalty
#disable_tcp=yes 
#tcp_accept_aliases=yes # accepts the tcp alias via option (see NEWS)

#

####### Defined Values #########

# *** Value defines - IDs used later in config
#!ifdef WITH_MYSQL
# - database URL - used to connect to database server by modules such
#       as: auth_db, acc, usrloc, a.s.o.

#!define DBURL "mysql://root:root@localhost/reg"

#!endif
#!ifdef WITH_MULTIDOMAIN
# - the value for 'use_domain' parameters
#!define MULTIDOMAIN 1
#!else
#!define MULTIDOMAIN 0
#!endif

## flags
flags
  FLAG_DLG          : 1;


# ------------------ module loading ----------------------------------

#loadpath "modules"
## Uncomment the next line if you have kamailio installed
#loadpath "/home/lbalaceanu/repos/kamailio_prod/modules/"
loadpath "/home/lbalaceanu/repos/kamailio_redis_saved/modules/"
## Comment the next line if you have kamailio installed
##loadpath "[PATH_TO_KAMAILIO_SOURCES]/modules"

#!ifdef WITH_MYSQL
loadmodule "db_mysql.so"
#!endif
loadmodule "pv"
loadmodule "tm"
loadmodule "sl"
loadmodule "rr"
loadmodule "textops"
loadmodule "maxfwd"

loadmodule "ndb_redis.so"
loadmodule "usrloc.so"
loadmodule "registrar"

loadmodule "xlog"
# loadmodule "ui-test"
# loadmodule "ctl"
# loadmodule "cfg_rpc"

loadmodule "dialog"
loadmodule "sst"
loadmodule "mi_fifo"

# ----------------- setting module-specific parameters ---------------

# pv
modparam("pv", "avp_aliases", "dlg_var=i:42")

modparam("mi_fifo", "fifo_name", "/tmp/kamailio_fifo")
# -- usrloc params --
modparam("usrloc", "db_mode", 0)

# -- rr params --
# add value to ;lr param to make some broken UAs happy
modparam("rr", "enable_full_lr", 1)

# ctl params
# by default ctl listens on unixs:/tmp/sip-router_ctl if no other address is
# specified in modparams; this is also the default for sercmd
# modparam("ctl", "binrpc", "unixs:/tmp/sip-router_ctl")
# listen on the "standard" fifo for backward compatibility
# modparam("ctl", "fifo", "fifo:/tmp/sip-router_fifo")
# listen on tcp, localhost
#modparam("ctl", "binrpc", "tcp:localhost:2046")

modparam("dialog", "dlg_flag", 1)
modparam("sst", "timeout_avp", "$avp(dlg_var)")
modparam("dialog", "default_timeout", 500)

modparam("sst", "sst_flag", 1)
modparam("sst", "timeout_avp", "$avp(dlg_var)")
modparam("sst", "min_se", 200)

# ----- usrloc params -----
/* enable DB persistency for location entries */
#!ifdef WITH_USRLOCDB
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "db_mode", 3)
modparam("usrloc", "use_domain", MULTIDOMAIN)
#!endif


# ----- auth_db params -----
#!ifdef WITH_AUTH
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "")
modparam("auth_db", "use_domain", MULTIDOMAIN)
#!endif

modparam("ndb_redis", "server", "name=srvN;addr=127.0.0.1;port=6379;db=1")
# -------------------------  request routing logic -------------------

# main routing logic

route{
    # enable dialog tracking
    setflag(FLAG_DLG);

	# initial sanity checks -- messages with
	# max_forwards==0, or excessively long requests
	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483","Too Many Hops");
		break;
	}
	if (msg:len >=  4096 ) {
		sl_send_reply("513", "Message too big");
		break;
	}

#        redis_cmd("srvN", "SET foo blabla", "r");

	if(!save("location")){
	    	xlog("L_ERR", "!!!!!! Failed to update location");
	    }
	else{
	    xlog("L_ERR", "----> Managed to update location");
	}
	xlog("L_ERR", "lala2");

	# we record-route all messages -- to make sure that
	# subsequent messages will go through our proxy; that's
	# particularly good if upstream and downstream entities
	# use different transport protocol
	if (!method=="REGISTER") record_route();
	xlog("L_ERR", "lala2");
	
	# subsequent messages withing a dialog should take the
	# path determined by record-routing
	if (loose_route()) {
		# mark routing logic in request
		append_hf("P-hint: rr-enforced\r\n");
		route(FORWARD);
		break;
	}

	xlog("L_ERR", "lala3");
	if (!uri==myself) {
		# mark routing logic in request
		append_hf("P-hint: outbound\r\n");
		route(FORWARD);
		break;
	}
	xlog("L_ERR", "lala4");

	# if the request is for other domain use UsrLoc
	# (in case, it does not work, use the following command
	# with proper names and addresses in it)
	if (uri==myself) {
		if (method=="REGISTER") {
			save("location");
			xlog("L_ERR", "lala5");
			break;
		}

		# native SIP destinations are handled using our USRLOC DB
		if (!lookup("location")) {
			sl_send_reply("404", "Not Found");
			break;
		}
		append_hf("P-hint: usrloc applied\r\n");
	}
	route(FORWARD);
}

route[FORWARD]
{
	# send it out now; use stateful forwarding as it works reliably
	# even for UDP2TCP
    t_on_reply("RESPONSE");
    xlog("L_ERR", "received request of type $rm\n");

	if (!t_relay()) {
		sl_reply_error();
	}
}


onreply_route[RESPONSE]
{
   xlog("L_NOTICE", "received reply with status code $rs\n"); 
}

