#! /bin/sh /usr/share/dpatch/dpatch-run
## rtpengine_db_table_nodes.dpatch by  <miti@dell>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/rtpengine.c ui-siprouter/modules/rtpengine/rtpengine.c
--- ui-siprouter~/modules/rtpengine/rtpengine.c	2016-01-27 12:57:19.000000000 +0200
+++ ui-siprouter/modules/rtpengine/rtpengine.c	2016-01-27 12:58:44.152207860 +0200
@@ -1,6 +1,6 @@
-/* $Id$
- *
+/*
  * Copyright (C) 2003-2008 Sippy Software, Inc., http://www.sippysoft.com
+ * Copyright (C) 2014-2015 Sipwise GmbH, http://www.sipwise.com
  *
  * This file is part of Kamailio, a free SIP server.
  *
@@ -246,18 +246,21 @@
 
 #define DEFAULT_RTPP_SET_ID		0
 #define MAX_RTPP_TRIED_NODES    50
-
 #define MI_SET_NATPING_STATE		"nh_enable_ping"
 #define MI_DEFAULT_NATPING_STATE	1
 
-#define MI_MIN_RECHECK_TICKS		0
-#define MI_MAX_RECHECK_TICKS		(unsigned int)-1
-
 #define MI_ENABLE_RTP_PROXY			"nh_enable_rtpp"
 #define MI_SHOW_RTP_PROXIES			"nh_show_rtpp"
 #define MI_PING_RTP_PROXY           "nh_ping_rtpp"
 #define MI_SHOW_HASH_TOTAL          "nh_show_hash_total"
+#define MI_RELOAD_RTP_PROXY           "nh_reload_rtpp"
 
+#define MI_DB_NOT_FOUND		"RTP database not found"
+#define MI_DB_NOT_FOUND_LEN	(sizeof(MI_DB_NOT_FOUND)-1)
+#define MI_DB_ERR		"Error reloading from RTP database"
+#define MI_DB_ERR_LEN	(sizeof(MI_DB_ERR)-1)
+#define MI_DB_OK		"Success reloading from RTP database"
+#define MI_DB_OK_LEN	(sizeof(MI_DB_OK)-1)
 #define MI_RTP_PROXY_NOT_FOUND		"RTP proxy not found"
 #define MI_RTP_PROXY_NOT_FOUND_LEN	(sizeof(MI_RTP_PROXY_NOT_FOUND)-1)
 #define MI_PING_DISABLED			"NATping disabled from script"
@@ -346,11 +349,12 @@
 static struct rtpp_node *select_rtpp_node_new(str, str, int);
 static struct rtpp_node *select_rtpp_node_old(str, str, int);
 static struct rtpp_node *select_rtpp_node(str, str, int);
+static int build_rtpp_socks(unsigned int current_rtpp_no);
 static char *send_rtpp_command(struct rtpp_node *, bencode_item_t *, int *);
 static int get_extra_id(struct sip_msg* msg, str *id_str);
 
 static int rtpengine_set_store(modparam_t type, void * val);
-static int rtpengine_add_rtpengine_set( char * rtp_proxies);
+static int rtpengine_add_rtpengine_set(char * rtp_proxies, unsigned int weight, int disabled, unsigned int ticks);
 
 static int mod_init(void);
 static int child_init(int);
@@ -375,6 +379,7 @@
 static struct mi_root* mi_show_rtp_proxy(struct mi_root* cmd_tree, void* param);
 static struct mi_root* mi_ping_rtp_proxy(struct mi_root* cmd_tree, void* param);
 static struct mi_root* mi_show_hash_total(struct mi_root* cmd_tree, void* param);
+static struct mi_root* mi_reload_rtp_proxy(struct mi_root* cmd_tree, void* param);
 
 
 static int rtpengine_disable_tout = 60;
@@ -388,6 +393,7 @@
 static char *setid_avp_param = NULL;
 static int hash_table_tout = 3600;
 static int hash_table_size = 256;
+static int setid_default = DEFAULT_RTPP_SET_ID;
 
 static char ** rtpp_strings=0;
 static int rtpp_sets=0; /*used in rtpengine_set_store()*/
@@ -406,8 +412,10 @@
 static pv_spec_t *rtp_inst_pvar = NULL;
 
 /* array with the sockets used by rtpporxy (per process)*/
-static unsigned int rtpp_no = 0;
+static unsigned int *rtpp_no = 0;
+static gen_lock_t *rtpp_no_lock = 0;
 static int *rtpp_socks = 0;
+static unsigned int rtpp_socks_size = 0;
 
 static int     setid_avp_type;
 static int_str setid_avp;
@@ -479,15 +487,19 @@
 	{"rtpengine_tout",        INT_PARAM, &rtpengine_tout         },
 	{"rtpengine_allow_op",    INT_PARAM, &rtpengine_allow_op     },
 	{"queried_nodes_limit",   INT_PARAM, &queried_nodes_limit    },
-	{"db_url",                PARAM_STR, &rtpp_db_url },
-	{"table_name",            PARAM_STR, &rtpp_table_name },
-	{"url_col",               PARAM_STR, &rtpp_url_col },
+	{"db_url",                PARAM_STR, &rtpp_db_url            },
+	{"table_name",            PARAM_STR, &rtpp_table_name        },
+	{"setid_col",             PARAM_STR, &rtpp_setid_col         },
+	{"url_col",               PARAM_STR, &rtpp_url_col           },
+	{"weight_col",            PARAM_STR, &rtpp_weight_col        },
+	{"disabled_col",          PARAM_STR, &rtpp_disabled_col      },
 	{"extra_id_pv",           PARAM_STR, &extra_id_pv_param },
 	{"setid_avp",             PARAM_STRING, &setid_avp_param },
 	{"force_send_interface",  PARAM_STRING, &force_send_ip_str	},
 	{"rtp_inst_pvar",         STR_PARAM, &rtp_inst_pv_param.s },
 	{"hash_table_tout",       INT_PARAM, &hash_table_tout        },
 	{"hash_table_size",       INT_PARAM, &hash_table_size        },
+	{"setid_default",         INT_PARAM, &setid_default          },
 	{0, 0, 0}
 };
 
@@ -496,6 +508,7 @@
 	{MI_SHOW_RTP_PROXIES,     mi_show_rtp_proxy,    0,  0,  0},
 	{MI_PING_RTP_PROXY,       mi_ping_rtp_proxy,    0,  0,  0},
 	{MI_SHOW_HASH_TOTAL,      mi_show_hash_total,    0,  0,  0},
+	{MI_RELOAD_RTP_PROXY,     mi_reload_rtp_proxy,  0,  0,  0},
 	{ 0, 0, 0, 0, 0}
 };
 
@@ -515,6 +528,49 @@
 	child_init
 };
 
+/* hide the node from display and disable it permanent */
+int rtpengine_delete_node(struct rtpp_node *rtpp_node)
+{
+	rtpp_node->rn_displayed = 0;
+	rtpp_node->rn_disabled = MI_MAX_RECHECK_TICKS;
+
+	return 1;
+}
+
+
+int rtpengine_delete_node_set(struct rtpp_set *rtpp_list)
+{
+	struct rtpp_node *rtpp_node;
+
+	lock_get(rtpp_list->rset_lock);
+	for(rtpp_node = rtpp_list->rn_first; rtpp_node != NULL;
+			rtpp_node = rtpp_node->rn_next) {
+		rtpengine_delete_node(rtpp_node);
+	}
+	lock_release(rtpp_list->rset_lock);
+
+	return 1;
+}
+
+
+int rtpengine_delete_node_all()
+{
+	struct rtpp_set *rtpp_list;
+
+	if (!rtpp_set_list) {
+		return 1;
+	}
+
+	lock_get(rtpp_set_list->rset_head_lock);
+	for(rtpp_list = rtpp_set_list->rset_first; rtpp_list != NULL;
+			rtpp_list = rtpp_list->rset_next) {
+		rtpengine_delete_node_set(rtpp_list);
+	}
+	lock_release(rtpp_set_list->rset_head_lock);
+
+	return 1;
+}
+
 
 static int get_ip_type(char *str_addr)
 {
@@ -650,6 +706,9 @@
 	return 0;
 }
 
+static inline int str_cmp(const str *a , const str *b) {
+	return ! (a->len == b->len && ! strncmp(a->s, b->s, a->len));
+}
 
 static inline int str_eq(const str *p, const char *q) {
 	int l = strlen(q);
@@ -659,6 +718,7 @@
 		return 0;
 	return 1;
 }
+
 static inline str str_prefix(const str *p, const char *q) {
 	str ret;
 	ret.s = NULL;
@@ -716,6 +776,28 @@
 	return 0;
 }
 
+struct rtpp_node *get_rtpp_node(struct rtpp_set *rtpp_list, str *url)
+{
+	struct rtpp_node *rtpp_node;
+
+	if (rtpp_list == NULL) {
+		return NULL;
+	}
+
+	lock_get(rtpp_list->rset_lock);
+	rtpp_node = rtpp_list->rn_first;
+	while (rtpp_node) {
+		if (str_cmp(&rtpp_node->rn_url, url) == 0) {
+			lock_release(rtpp_list->rset_lock);
+			return rtpp_node;
+		}
+		rtpp_node = rtpp_node->rn_next;
+	}
+	lock_release(rtpp_list->rset_lock);
+
+	return NULL;
+}
+
 struct rtpp_set *get_rtpp_set(int set_id)
 {
 	struct rtpp_set * rtpp_list;
@@ -731,6 +813,7 @@
 
 	my_current_id = set_id;
 	/*search for the current_id*/
+	lock_get(rtpp_set_list->rset_head_lock);
 	rtpp_list = rtpp_set_list ? rtpp_set_list->rset_first : 0;
 	while( rtpp_list != 0 && rtpp_list->id_set!=my_current_id)
 		rtpp_list = rtpp_list->rset_next;
@@ -740,11 +823,29 @@
 		rtpp_list = shm_malloc(sizeof(struct rtpp_set));
 		if(!rtpp_list)
 		{
+			lock_release(rtpp_set_list->rset_head_lock);
 			LM_ERR("no shm memory left to create new rtpproxy set %d\n", my_current_id);
 			return NULL;
 		}
 		memset(rtpp_list, 0, sizeof(struct rtpp_set));
 		rtpp_list->id_set = my_current_id;
+		rtpp_list->rset_lock = lock_alloc();
+		if (!rtpp_list->rset_lock) {
+			lock_release(rtpp_set_list->rset_head_lock);
+			LM_ERR("no shm memory left to create rtpproxy set lock\n");
+			shm_free(rtpp_list);
+			rtpp_list = NULL;
+			return NULL;
+		}
+		if (lock_init(rtpp_list->rset_lock) == 0) {
+			lock_release(rtpp_set_list->rset_head_lock);
+			LM_ERR("could not init rtpproxy set lock\n");
+			lock_dealloc((void*)rtpp_list->rset_lock);
+			rtpp_list->rset_lock = NULL;
+			shm_free(rtpp_list);
+			rtpp_list = NULL;
+			return NULL;
+		}
 		new_list = 1;
 	}
 	else {
@@ -753,15 +854,6 @@
 
 	if (new_list)
 	{
-		if(!rtpp_set_list){/*initialize the list of set*/
-			rtpp_set_list = shm_malloc(sizeof(struct rtpp_set_head));
-			if(!rtpp_set_list){
-				LM_ERR("no shm memory left to create list of proxysets\n");
-				return NULL;
-			}
-			memset(rtpp_set_list, 0, sizeof(struct rtpp_set_head));
-		}
-
 		/*update the list of set info*/
 		if (!rtpp_set_list->rset_first)
 		{
@@ -779,22 +871,27 @@
 			default_rtpp_set = rtpp_list;
 		}
 	}
+	lock_release(rtpp_set_list->rset_head_lock);
+
 	return rtpp_list;
 }
 
 
-int add_rtpengine_socks(struct rtpp_set * rtpp_list, char * rtpproxy)
+int add_rtpengine_socks(struct rtpp_set * rtpp_list, char * rtpproxy,
+			unsigned int weight, int disabled, unsigned int ticks, int isDB)
 {
 	/* Make rtp proxies list. */
 	char *p, *p1, *p2, *plim;
 	struct rtpp_node *pnode;
-	int weight;
+	struct rtpp_node *rtpp_node;
+	unsigned int local_weight, port;
+	str s1;
 
 	p = rtpproxy;
 	plim = p + strlen(p);
 
 	for(;;) {
-			weight = 1;
+		local_weight = weight;
 		while (*p && isspace((int)*p))
 			++p;
 		if (p >= plim)
@@ -804,33 +901,49 @@
 			++p;
 		if (p <= p1)
 			break; /* may happen??? */
-		/* Have weight specified? If yes, scan it */
-		p2 = memchr(p1, '=', p - p1);
-		if (p2 != NULL) {
-			weight = strtoul(p2 + 1, NULL, 10);
-		} else {
-			p2 = p;
+		p2 = p;
+
+		/* if called for database, consider simple, single char *URL */
+		/* if called for config, consider weight URL */
+		if (!isDB) {
+			/* Have weight specified? If yes, scan it */
+			p2 = memchr(p1, '=', p - p1);
+			if (p2 != NULL) {
+				local_weight = strtoul(p2 + 1, NULL, 10);
+			} else {
+				p2 = p;
+			}
 		}
+
 		pnode = shm_malloc(sizeof(struct rtpp_node));
 		if (pnode == NULL) {
 			LM_ERR("no shm memory left\n");
 			return -1;
 		}
 		memset(pnode, 0, sizeof(*pnode));
-		pnode->idx = rtpp_no++;
-		pnode->rn_recheck_ticks = 0;
-		pnode->rn_weight = weight;
+
+		lock_get(rtpp_no_lock);
+		pnode->idx = *rtpp_no;
+
+		if (ticks == MI_MAX_RECHECK_TICKS) {
+			pnode->rn_recheck_ticks = ticks;
+		} else {
+			pnode->rn_recheck_ticks = ticks + get_ticks();
+		}
+		pnode->rn_weight = local_weight;
 		pnode->rn_umode = 0;
-		pnode->rn_disabled = 0;
+		pnode->rn_disabled = disabled;
+		pnode->rn_displayed = 1;
 		pnode->rn_url.s = shm_malloc(p2 - p1 + 1);
 		if (pnode->rn_url.s == NULL) {
+			lock_release(rtpp_no_lock);
 			shm_free(pnode);
 			LM_ERR("no shm memory left\n");
 			return -1;
 		}
 		memmove(pnode->rn_url.s, p1, p2 - p1);
-		pnode->rn_url.s[p2 - p1] 	= 0;
-		pnode->rn_url.len 			= p2-p1;
+		pnode->rn_url.s[p2 - p1] = 0;
+		pnode->rn_url.len = p2-p1;
 
 		LM_DBG("url is %s, len is %i\n", pnode->rn_url.s, pnode->rn_url.len);
 		/* Leave only address in rn_address */
@@ -844,6 +957,63 @@
 		} else if (strncasecmp(pnode->rn_address, "unix:", 5) == 0) {
 			pnode->rn_umode = 0;
 			pnode->rn_address += 5;
+		} else {
+			lock_release(rtpp_no_lock);
+			LM_WARN("Node address must start with 'udp:' or 'udp6:' or 'unix:'. Ignore '%s'.\n", pnode->rn_address);
+			shm_free(pnode->rn_url.s);
+			shm_free(pnode);
+
+			if (!isDB) {
+				continue;
+			} else {
+				return 0;
+			}
+		}
+
+		/* Check the rn_address is 'hostname:port' */
+		/* Check the rn_address port is valid */
+		p1 = strchr(pnode->rn_address, ':');
+		if (p1 != NULL) {
+			p1++;
+		}
+
+		if (p1 != NULL && p1 != '\0') {
+			s1.s = p1;
+			s1.len = strlen(p1);
+			if (str2int(&s1, &port) < 0 || port > 0xFFFF) {
+				lock_release(rtpp_no_lock);
+				LM_WARN("Node address must end with a valid port number. Ignore '%s'.\n", pnode->rn_address);
+				shm_free(pnode->rn_url.s);
+				shm_free(pnode);
+
+				if (!isDB) {
+					continue;
+				} else {
+					return 0;
+				}
+			}
+		}
+
+		/* If node found in set, update it */
+		rtpp_node = get_rtpp_node(rtpp_list, &pnode->rn_url);
+
+		lock_get(rtpp_list->rset_lock);
+		if (rtpp_node) {
+			rtpp_node->rn_disabled = pnode->rn_disabled;
+			rtpp_node->rn_displayed = pnode->rn_displayed;
+			rtpp_node->rn_recheck_ticks = pnode->rn_recheck_ticks;
+			rtpp_node->rn_weight = pnode->rn_weight;
+			lock_release(rtpp_list->rset_lock);
+			lock_release(rtpp_no_lock);
+
+			shm_free(pnode->rn_url.s);
+			shm_free(pnode);
+
+			if (!isDB) {
+				continue;
+			} else {
+				return 0;
+			}
 		}
 
 		if (rtpp_list->rn_first == NULL) {
@@ -854,6 +1024,16 @@
 
 		rtpp_list->rn_last = pnode;
 		rtpp_list->rtpp_node_count++;
+		lock_release(rtpp_list->rset_lock);
+
+		*rtpp_no = *rtpp_no + 1;
+		lock_release(rtpp_no_lock);
+
+		if (!isDB) {
+			continue;
+		} else {
+			return 0;
+		}
 	}
 	return 0;
 }
@@ -862,7 +1042,7 @@
 /*	0-succes
  *  -1 - erorr
  * */
-static int rtpengine_add_rtpengine_set( char * rtp_proxies)
+static int rtpengine_add_rtpengine_set(char * rtp_proxies, unsigned int weight, int disabled, unsigned int ticks)
 {
 	char *p,*p2;
 	struct rtpp_set * rtpp_list;
@@ -915,7 +1095,8 @@
 
 	if (rtpp_list != NULL)
 	{
-		if (add_rtpengine_socks(rtpp_list, rtp_proxies) != 0)
+
+		if (add_rtpengine_socks(rtpp_list, rtp_proxies, weight, disabled, ticks, 0) != 0)
 			goto error;
 		else
 			return 0;
@@ -1064,12 +1245,18 @@
         found = MI_FOUND_ALL;
     }
 
+	lock_get(rtpp_set_list->rset_head_lock);
 	for(rtpp_list = rtpp_set_list->rset_first; rtpp_list != NULL;
 					rtpp_list = rtpp_list->rset_next) {
 
+		lock_get(rtpp_list->rset_lock);
 		for(crt_rtpp = rtpp_list->rn_first; crt_rtpp != NULL;
 						crt_rtpp = crt_rtpp->rn_next) {
 
+			if (!crt_rtpp->rn_displayed) {
+				continue;
+			}
+
 	        /* found a matching rtpp - show it */
 	        if (found == MI_FOUND_ALL ||
                     (crt_rtpp->rn_url.len == rtpp_url.len &&
@@ -1101,7 +1288,9 @@
                 }
 	        }
 		}
+		lock_release(rtpp_list->rset_lock);
 	}
+	lock_release(rtpp_set_list->rset_head_lock);
 
 	root = init_mi_tree(200, MI_OK_S, MI_OK_LEN);
 	if (!root) {
@@ -1300,18 +1489,26 @@
         found = MI_FOUND_ALL;
     }
 
+	lock_get(rtpp_set_list->rset_head_lock);
 	for(rtpp_list = rtpp_set_list->rset_first; rtpp_list != NULL;
 					rtpp_list = rtpp_list->rset_next) {
 
+		lock_get(rtpp_list->rset_lock);
 		for(crt_rtpp = rtpp_list->rn_first; crt_rtpp != NULL;
 						crt_rtpp = crt_rtpp->rn_next) {
 
+			if (!crt_rtpp->rn_displayed) {
+				continue;
+			}
+
 	        /* found a matching rtpp - show it */
 	        if (found == MI_FOUND_ALL ||
                     (crt_rtpp->rn_url.len == rtpp_url.len &&
 	                strncmp(crt_rtpp->rn_url.s, rtpp_url.s, rtpp_url.len) == 0)) {
 
 	            if (add_rtpp_node_info(node, crt_rtpp, rtpp_list) < 0) {
+					lock_release(rtpp_list->rset_lock);
+					lock_release(rtpp_set_list->rset_head_lock);
 	                goto error;
 	            }
 
@@ -1320,7 +1517,9 @@
                 }
 	        }
 		}
+		lock_release(rtpp_list->rset_lock);
 	}
+	lock_release(rtpp_set_list->rset_head_lock);
 
 	switch (found) {
 	    case MI_FOUND_ALL:
@@ -1382,12 +1581,18 @@
         found = MI_FOUND_ALL;
     }
 
+	lock_get(rtpp_set_list->rset_head_lock);
 	for (rtpp_list = rtpp_set_list->rset_first; rtpp_list != NULL;
 					rtpp_list = rtpp_list->rset_next) {
 
+		lock_get(rtpp_list->rset_lock);
 		for (crt_rtpp = rtpp_list->rn_first; crt_rtpp != NULL;
 						crt_rtpp = crt_rtpp->rn_next) {
 
+			if (!crt_rtpp->rn_displayed) {
+				continue;
+			}
+
 	        /* found a matching rtpp - ping it */
 	        if (found == MI_FOUND_ALL ||
                     (crt_rtpp->rn_url.len == rtpp_url.len &&
@@ -1406,7 +1611,9 @@
                 }
 		    }
 	    }
+		lock_release(rtpp_list->rset_lock);
 	}
+	lock_release(rtpp_set_list->rset_head_lock);
 
 	root = init_mi_tree(200, MI_OK_S, MI_OK_LEN);
 	if (!root) {
@@ -1509,6 +1716,48 @@
 	return init_mi_tree(404, MI_HASH_ENTRIES_FAIL, MI_HASH_ENTRIES_FAIL_LEN);
 }
 
+static struct mi_root*
+mi_reload_rtp_proxy(struct mi_root* cmd_tree, void* param)
+{
+	struct mi_root *root = NULL;
+	unsigned int current_rtpp_no;
+
+	if (rtpp_db_url.s == NULL) {
+		// no database
+		root = init_mi_tree(404, MI_DB_NOT_FOUND, MI_DB_NOT_FOUND_LEN);
+		if (!root) {
+			LM_ERR("the MI tree cannot be initialized!\n");
+			return 0;
+		}
+	} else {
+		if (init_rtpproxy_db() < 0) {
+			// fail reloading from database
+			root = init_mi_tree(404, MI_DB_ERR, MI_DB_ERR_LEN);
+			if (!root) {
+				LM_ERR("the MI tree cannot be initialized!\n");
+				return 0;
+			}
+		} else {
+			lock_get(rtpp_no_lock);
+			current_rtpp_no = *rtpp_no;
+			lock_release(rtpp_no_lock);
+
+			if (rtpp_socks_size != current_rtpp_no) {
+				build_rtpp_socks(current_rtpp_no);
+			}
+
+			// success reloading from database
+			root = init_mi_tree(200, MI_DB_OK, MI_DB_OK_LEN);
+			if (!root) {
+				LM_ERR("the MI tree cannot be initialized!\n");
+				return 0;
+			}
+		}
+	}
+
+	return root;
+}
+
 
 static int
 mod_init(void)
@@ -1524,15 +1773,50 @@
 		return -1;
 	}
 
-	/* any rtpproxy configured? */
-	if(rtpp_set_list)
-		default_rtpp_set = select_rtpp_set(DEFAULT_RTPP_SET_ID);
+	rtpp_no = (unsigned int*)shm_malloc(sizeof(unsigned int));
+	if (!rtpp_no) {
+		LM_ERR("no more shm memory for rtpp_no\n");
+		return -1;
+	}
+	*rtpp_no = 0;
+
+	rtpp_no_lock = lock_alloc();
+	if (!rtpp_no_lock) {
+		LM_ERR("no more shm memory for rtpp_no_lock\n");
+		return -1;
+	}
+
+	if (lock_init(rtpp_no_lock) == 0) {
+		LM_ERR("could not init rtpp_no_lock\n");
+		return -1;
+	}
+
+	/* initialize the list of set; mod_destroy does shm_free() if fail */
+	if (!rtpp_set_list) {
+		rtpp_set_list = shm_malloc(sizeof(struct rtpp_set_head));
+		if(!rtpp_set_list){
+			LM_ERR("no shm memory left to create list of proxysets\n");
+			return -1;
+		}
+		memset(rtpp_set_list, 0, sizeof(struct rtpp_set_head));
+
+		rtpp_set_list->rset_head_lock = lock_alloc();
+		if (!rtpp_set_list->rset_head_lock) {
+			LM_ERR("no shm memory left to create list of proxysets lock\n");
+			return -1;
+		}
+
+		if (lock_init(rtpp_set_list->rset_head_lock) == 0) {
+			LM_ERR("could not init rtpproxy list of proxysets lock\n");
+			return -1;
+		}
+	}
 
 	if (rtpp_db_url.s == NULL)
 	{
 		/* storing the list of rtp proxy sets in shared memory*/
 		for(i=0;i<rtpp_sets;i++){
-			if(rtpengine_add_rtpengine_set(rtpp_strings[i]) !=0){
+			if(rtpengine_add_rtpengine_set(rtpp_strings[i], 1, 0, 0) !=0){
 				for(;i<rtpp_sets;i++)
 					if(rtpp_strings[i])
 						pkg_free(rtpp_strings[i]);
@@ -1553,6 +1837,10 @@
 		}
 	}
 
+	/* any rtpproxy configured? */
+	if (rtpp_set_list)
+		default_rtpp_set = select_rtpp_set(DEFAULT_RTPP_SET_ID);
+
 	if (rtp_inst_pv_param.s) {
 		rtp_inst_pv_param.len = strlen(rtp_inst_pv_param.s);
 		rtp_inst_pvar = pv_cache_get(&rtp_inst_pv_param);
@@ -1621,35 +1909,47 @@
 		LM_DBG("rtpengine_hash_table_init(%d) success!\n", hash_table_size);
 	}
 
+	/* select the default set */
+	default_rtpp_set = select_rtpp_set(setid_default);
+	if (!default_rtpp_set) {
+		LM_NOTICE("Default rtpp set %d NOT found\n", setid_default);
+	} else {
+		LM_DBG("Default rtpp set %d found\n", setid_default);
+	}
+
 	return 0;
 }
 
-
-static int
-child_init(int rank)
-{
-	int n;
+static int build_rtpp_socks(unsigned int current_rtpp_no) {
+	int n, i;
 	char *cp;
 	struct addrinfo hints, *res;
 	struct rtpp_set  *rtpp_list;
 	struct rtpp_node *pnode;
+#ifdef IP_MTU_DISCOVER
+	int ip_mtu_discover = IP_PMTUDISC_DONT;
+#endif
 
-	if(rtpp_set_list==NULL )
-		return 0;
-
-	/* Iterate known RTP proxies - create sockets */
-	mypid = getpid();
+	// close current sockets
+	for (i = 0; i < rtpp_socks_size; i++) {
+		if (rtpp_socks[i] >= 0) {
+			close(rtpp_socks[i]);
+		}
+	}
 
-	rtpp_socks = (int*)pkg_malloc( sizeof(int)*rtpp_no );
-	if (rtpp_socks==NULL) {
-		LM_ERR("no more pkg memory\n");
+	rtpp_socks_size = current_rtpp_no;
+	rtpp_socks = (int*)pkg_realloc(rtpp_socks, sizeof(int)*(rtpp_socks_size));
+	if (!rtpp_socks) {
+		LM_ERR("no more pkg memory for rtpp_socks\n");
 		return -1;
 	}
 
-	for(rtpp_list = rtpp_set_list->rset_first; rtpp_list != 0;
-		rtpp_list = rtpp_list->rset_next){
+	lock_get(rtpp_set_list->rset_head_lock);
+	for (rtpp_list = rtpp_set_list->rset_first; rtpp_list != 0;
+		rtpp_list = rtpp_list->rset_next) {
 
-		for (pnode=rtpp_list->rn_first; pnode!=0; pnode = pnode->rn_next){
+		lock_get(rtpp_list->rset_lock);
+		for (pnode=rtpp_list->rn_first; pnode!=0; pnode = pnode->rn_next) {
 			char *hostname;
 
 			if (pnode->rn_umode == 0) {
@@ -1664,7 +1964,8 @@
 			hostname = (char*)pkg_malloc(sizeof(char) * (strlen(pnode->rn_address) + 1));
 			if (hostname==NULL) {
 				LM_ERR("no more pkg memory\n");
-				return -1;
+				rtpp_socks[pnode->idx] = -1;
+				continue;
 			}
 			strcpy(hostname, pnode->rn_address);
 
@@ -1683,24 +1984,31 @@
 			if ((n = getaddrinfo(hostname, cp, &hints, &res)) != 0) {
 				LM_ERR("%s\n", gai_strerror(n));
 				pkg_free(hostname);
-				return -1;
+				rtpp_socks[pnode->idx] = -1;
+				continue;
 			}
 			pkg_free(hostname);
 
 			rtpp_socks[pnode->idx] = socket((pnode->rn_umode == 6)
-			    ? AF_INET6 : AF_INET, SOCK_DGRAM, 0);
+				? AF_INET6 : AF_INET, SOCK_DGRAM, 0);
 			if (rtpp_socks[pnode->idx] == -1) {
 				LM_ERR("can't create socket\n");
 				freeaddrinfo(res);
-				return -1;
+				continue;
 			}
 
+#ifdef IP_MTU_DISCOVER
+			setsockopt(rtpp_socks[pnode->idx], IPPROTO_IP,
+				IP_MTU_DISCOVER, &ip_mtu_discover,
+				sizeof(ip_mtu_discover));
+#endif
+
 			if (bind_force_send_ip(pnode->idx) == -1) {
 				LM_ERR("can't bind socket\n");
 				close(rtpp_socks[pnode->idx]);
 				rtpp_socks[pnode->idx] = -1;
 				freeaddrinfo(res);
-				return -1;
+				continue;
 			}
 
 			if (connect(rtpp_socks[pnode->idx], res->ai_addr, res->ai_addrlen) == -1) {
@@ -1708,13 +2016,41 @@
 				close(rtpp_socks[pnode->idx]);
 				rtpp_socks[pnode->idx] = -1;
 				freeaddrinfo(res);
-				return -1;
+				continue;
 			}
 
 			freeaddrinfo(res);
 rptest:
 			pnode->rn_disabled = rtpp_test(pnode, 0, 1);
 		}
+		lock_release(rtpp_list->rset_lock);
+	}
+	lock_release(rtpp_set_list->rset_head_lock);
+
+	return 0;
+}
+
+static int
+child_init(int rank)
+{
+	if(!rtpp_set_list)
+		return 0;
+
+	mypid = getpid();
+
+	lock_get(rtpp_no_lock);
+	rtpp_socks_size = *rtpp_no;
+	lock_release(rtpp_no_lock);
+
+	rtpp_socks = (int*)pkg_malloc(sizeof(int)*(rtpp_socks_size));
+	if (!rtpp_socks) {
+		LM_ERR("no more pkg memory for rtpp_socks\n");
+		return -1;
+	}
+
+	/* Iterate known RTP proxies - create sockets */
+	if (rtpp_socks_size) {
+		build_rtpp_socks(rtpp_socks_size);
 	}
 
 	return 0;
@@ -1730,11 +2066,39 @@
 	if (natping_state)
 		shm_free(natping_state);
 
-	if(rtpp_set_list == NULL)
+	if (rtpp_no) {
+		shm_free(rtpp_no);
+		rtpp_no = NULL;
+	}
+
+	if (rtpp_no_lock) {
+		lock_destroy(rtpp_no_lock);
+		lock_dealloc(rtpp_no_lock);
+		rtpp_no_lock = NULL;
+	}
+
+	if (!rtpp_set_list) {
+		return;
+	}
+
+	if (!rtpp_set_list->rset_head_lock) {
+		shm_free(rtpp_set_list);
+		rtpp_set_list = NULL;
 		return;
+	}
 
+	lock_get(rtpp_set_list->rset_head_lock);
 	for(crt_list = rtpp_set_list->rset_first; crt_list != NULL; ){
+		last_list = crt_list;
+
+		if (!crt_list->rset_lock) {
+			crt_list = last_list->rset_next;
+			shm_free(last_list);
+			last_list = NULL;
+			continue;
+		}
 
+		lock_get(last_list->rset_lock);
 		for(crt_rtpp = crt_list->rn_first; crt_rtpp != NULL;  ){
 
 			if(crt_rtpp->rn_url.s)
@@ -1744,13 +2108,24 @@
 			crt_rtpp = last_rtpp->rn_next;
 			shm_free(last_rtpp);
 		}
-
-		last_list = crt_list;
 		crt_list = last_list->rset_next;
+		lock_release(last_list->rset_lock);
+
+		lock_destroy(last_list->rset_lock);
+		lock_dealloc((void*)last_list->rset_lock);
+		last_list->rset_lock = NULL;
+
 		shm_free(last_list);
+		last_list = NULL;
 	}
+	lock_release(rtpp_set_list->rset_head_lock);
+
+	lock_destroy(rtpp_set_list->rset_head_lock);
+	lock_dealloc((void*)rtpp_set_list->rset_head_lock);
+	rtpp_set_list->rset_head_lock = NULL;
 
 	shm_free(rtpp_set_list);
+	rtpp_set_list = NULL;
 
 	/* destroy the hastable which keeps the call-id <-> selected_node relation */
 	if (!rtpengine_hash_table_destroy()) {
@@ -2220,8 +2595,8 @@
 
 	cp = send_rtpp_command(node, dict, &ret);
 	if (!cp) {
-	    node->rn_disabled = 1;
-    	node->rn_recheck_ticks = get_ticks() + rtpengine_disable_tout;
+		node->rn_disabled = 1;
+		node->rn_recheck_ticks = get_ticks() + rtpengine_disable_tout;
 		LM_ERR("proxy did not respond to ping\n");
 		goto error;
 	}
@@ -2367,16 +2742,24 @@
 	struct rtpp_set * rtpp_list;
 	/*is it a valid set_id?*/
 
-	if(!rtpp_set_list || !rtpp_set_list->rset_first){
-		LM_ERR("no rtp_proxy configured\n");
+	if (!rtpp_set_list) {
+		LM_ERR("no rtpp_set_list\n");
 		return 0;
 	}
 
-	for(rtpp_list=rtpp_set_list->rset_first; rtpp_list!=0 &&
-		rtpp_list->id_set!=id_set; rtpp_list=rtpp_list->rset_next);
-	if(!rtpp_list){
+	lock_get(rtpp_set_list->rset_head_lock);
+	if (!rtpp_set_list->rset_first) {
+		LM_ERR("no rtpp_set_list->rset_first\n");
+		lock_release(rtpp_set_list->rset_head_lock);
+		return 0;
+	}
+
+	for (rtpp_list=rtpp_set_list->rset_first; rtpp_list!=0 &&
+			rtpp_list->id_set!=id_set; rtpp_list=rtpp_list->rset_next);
+	if (!rtpp_list) {
 		LM_ERR(" script error-invalid id_set to be selected\n");
 	}
+	lock_release(rtpp_set_list->rset_head_lock);
 
 	return rtpp_list;
 }
@@ -2400,7 +2783,13 @@
 retry:
 	weight_sum = 0;
 
+	lock_get(active_rtpp_set->rset_lock);
 	for (node=active_rtpp_set->rn_first; node!=NULL; node=node->rn_next) {
+		/* Select only between displayed machines */
+		if (!node->rn_displayed) {
+			continue;
+		}
+
 		/* Try to enable if it's time to try. */
 		if (node->rn_disabled && node->rn_recheck_ticks <= get_ticks()){
 			node->rn_disabled = rtpp_test(node, 1, 0);
@@ -2411,6 +2800,7 @@
 			weight_sum += node->rn_weight;
 		}
 	}
+	lock_release(active_rtpp_set->rset_lock);
 
 	/* No proxies? Force all to be redetected, if not yet */
 	if (weight_sum == 0) {
@@ -2420,9 +2810,16 @@
 
 		was_forced = 1;
 
+		lock_get(active_rtpp_set->rset_lock);
 		for(node=active_rtpp_set->rn_first; node!=NULL; node=node->rn_next) {
+			/* Select only between displayed machines */
+			if (!node->rn_displayed) {
+				continue;
+			}
+
 			node->rn_disabled = rtpp_test(node, 1, 1);
 		}
+		lock_release(active_rtpp_set->rset_lock);
 
 		goto retry;
 	}
@@ -2433,27 +2830,40 @@
 	/*
 	 * Scan proxy list and decrease until appropriate proxy is found.
 	 */
+	lock_get(active_rtpp_set->rset_lock);
 	for (node=active_rtpp_set->rn_first; node!=NULL; node=node->rn_next) {
+		/* Select only between displayed machines */
+		if (!node->rn_displayed) {
+			continue;
+		}
+
 		/* Select only between enabled machines */
 		if (node->rn_disabled)
 			continue;
 
 		/* Found enabled machine */
-		if (sumcut < node->rn_weight)
+		if (sumcut < node->rn_weight) {
+			lock_release(active_rtpp_set->rset_lock);
 			goto found;
+		}
 
 		/* Update sumcut if enabled machine */
 		sumcut -= node->rn_weight;
 	}
+	lock_release(active_rtpp_set->rset_lock);
 
 	/* No node list */
 	return NULL;
 
 found:
 	if (do_test) {
+		lock_get(active_rtpp_set->rset_lock);
 		node->rn_disabled = rtpp_test(node, node->rn_disabled, 0);
-		if (node->rn_disabled)
+		if (node->rn_disabled) {
+			lock_release(active_rtpp_set->rset_lock);
 			goto retry;
+		}
+		lock_release(active_rtpp_set->rset_lock);
 	}
 
 	/* build the entry */
@@ -2531,8 +2941,22 @@
 select_rtpp_node(str callid, str viabranch, int do_test)
 {
 	struct rtpp_node *node = NULL;
+	unsigned int current_rtpp_no;
 
-	if(!active_rtpp_set) {
+	lock_get(rtpp_no_lock);
+	current_rtpp_no = *rtpp_no;
+	lock_release(rtpp_no_lock);
+
+	if (rtpp_socks_size != current_rtpp_no) {
+		build_rtpp_socks(current_rtpp_no);
+	}
+
+	if (!active_rtpp_set) {
+		default_rtpp_set = select_rtpp_set(setid_default);
+		active_rtpp_set = default_rtpp_set;
+	}
+
+	if (!active_rtpp_set) {
 		LM_ERR("script error - no valid set selected\n");
 		return NULL;
 	}
@@ -2570,8 +2994,6 @@
 		return node;
 	}
 
-
-
 	return NULL;
 }
 
@@ -2705,12 +3127,14 @@
 	}
 	current_msg_id = msg->id;
 
+	lock_get((*out)->rset_lock);
 	node = (*out)->rn_first;
 	while (node != NULL)
 	{
 	    if (node->rn_disabled == 0) nb_active_nodes++;
 	    node = node->rn_next;
 	}
+	lock_release((*out)->rset_lock);
 
 	if ( nb_active_nodes > 0 )
 	{
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/rtpengine.h ui-siprouter/modules/rtpengine/rtpengine.h
--- ui-siprouter~/modules/rtpengine/rtpengine.h	2016-01-27 12:57:19.000000000 +0200
+++ ui-siprouter/modules/rtpengine/rtpengine.h	2016-01-27 12:57:19.000000000 +0200
@@ -1,6 +1,6 @@
-/* $Id: nathelper.c 1808 2007-03-10 17:36:19Z bogdan_iancu $
- *
+/*
  * Copyright (C) 2003 Porta Software Ltd
+ * Copyright (C) 2014-2015 Sipwise GmbH, http://www.sipwise.com
  *
  * This file is part of Kamailio, a free SIP server.
  *
@@ -17,10 +17,6 @@
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- * History:
- * ---------
- * 2007-04-13   splitted from nathelper.c (ancuta)
 */
 
 
@@ -30,6 +26,9 @@
 #include "bencode.h"
 #include "../../str.h"
 
+#define MI_MIN_RECHECK_TICKS		0
+#define MI_MAX_RECHECK_TICKS		(unsigned int)-1
+
 struct rtpp_node {
 	unsigned int		idx;			/* overall index */
 	str					rn_url;			/* unparsed, deletable */
@@ -37,6 +36,7 @@
 	char				*rn_address;	/* substring of rn_url */
 	int					rn_disabled;	/* found unaccessible? */
 	unsigned			rn_weight;		/* for load balancing */
+	unsigned int		rn_displayed;		/* for delete at db reload */
 	unsigned int		rn_recheck_ticks;
         int                     rn_rep_supported;
         int                     rn_ptl_supported;
@@ -53,24 +53,34 @@
 	struct rtpp_node	*rn_first;
 	struct rtpp_node	*rn_last;
 	struct rtpp_set     *rset_next;
+	gen_lock_t		*rset_lock;
 };
 
 
 struct rtpp_set_head{
 	struct rtpp_set		*rset_first;
 	struct rtpp_set		*rset_last;
+	gen_lock_t		*rset_head_lock;
 };
 
 
+struct rtpp_node *get_rtpp_node(struct rtpp_set *rtpp_list, str *url);
 struct rtpp_set *get_rtpp_set(int set_id);
-int add_rtpengine_socks(struct rtpp_set * rtpp_list, char * rtpproxy);
+int add_rtpengine_socks(struct rtpp_set * rtpp_list, char * rtpproxy, unsigned int weight, int disabled, unsigned int ticks, int isDB);
+
+int rtpengine_delete_node(struct rtpp_node *rtpp_node);
+int rtpengine_delete_node_set(struct rtpp_set *rtpp_list);
+int rtpengine_delete_node_all();
 
 
 int init_rtpproxy_db(void);
 
 extern str rtpp_db_url;
 extern str rtpp_table_name;
+extern str rtpp_setid_col;
 extern str rtpp_url_col;
+extern str rtpp_weight_col;
+extern str rtpp_disabled_col;
 
 
 #endif
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/rtpengine_db.c ui-siprouter/modules/rtpengine/rtpengine_db.c
--- ui-siprouter~/modules/rtpengine/rtpengine_db.c	2016-01-27 12:57:19.000000000 +0200
+++ ui-siprouter/modules/rtpengine/rtpengine_db.c	2016-01-27 12:57:19.000000000 +0200
@@ -1,7 +1,6 @@
 /*
- * rtpproxy module
- *
  * Copyright (c) 2013 Crocodile RCS Ltd
+ * Copyright (C) 2014-2015 Sipwise GmbH, http://www.sipwise.com
  *
  * This file is part of Kamailio, a free SIP server.
  *
@@ -18,7 +17,6 @@
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
  */
 
 #include "../../lib/srdb1/db.h"
@@ -33,9 +31,11 @@
 static db1_con_t *rtpp_db_handle = NULL;
 
 str rtpp_db_url = {NULL, 0};
-str rtpp_table_name = str_init("rtpproxy");
-str rtpp_set_id_col = str_init("set_id");
+str rtpp_table_name = str_init("rtpengine");
+str rtpp_setid_col = str_init("setid");
 str rtpp_url_col = str_init("url");
+str rtpp_weight_col = str_init("weight");
+str rtpp_disabled_col = str_init("disabled");
 
 static int rtpp_connect_db(void)
 {
@@ -65,13 +65,15 @@
 	db1_res_t *res = NULL;
 	db_val_t *values = NULL;
 	db_row_t *rows = NULL;
-	db_key_t query_cols[] = {&rtpp_set_id_col, &rtpp_url_col};
+	db_key_t query_cols[] = {&rtpp_setid_col, &rtpp_url_col, &rtpp_weight_col, &rtpp_disabled_col};
 
 	str url;
-	int set_id;
+	int setid, disabled;
+	unsigned int weight, ticks;
+
 	/* int weight, flags; */
 	int n_rows = 0;
-	int n_cols = 2;
+	int n_cols = 4;
 
 	if (rtpp_db_handle == NULL)
 	{
@@ -89,6 +91,8 @@
 		return -1;
 	}
 
+	rtpengine_delete_node_all();
+
 	n_rows = RES_ROW_N(res);
 	rows = RES_ROWS(res);
 	if (n_rows == 0)
@@ -96,26 +100,35 @@
 		LM_WARN("No rtpproxy instances in database\n");
 		return 0;
 	}
+
 	for (i=0; i<n_rows; i++)
 	{
 		values = ROW_VALUES(rows + i);
 
-		set_id = VAL_INT(values);
+		setid = VAL_INT(values);
 		url.s = VAL_STR(values+1).s;
 		url.len = strlen(url.s);
+		weight = VAL_INT(values+2);
+		disabled = VAL_INT(values+3);
+		if (disabled) {
+			ticks = MI_MAX_RECHECK_TICKS;
+		} else {
+			ticks = 0;
+		}
 		/*
 		weight = VAL_INT(values+2);
 		flags = VAL_INT(values+3);
 		*/
-		if ((rtpp_list = get_rtpp_set(set_id)) == NULL)
+		if ((rtpp_list = get_rtpp_set(setid)) == NULL)
 		{
-			LM_ERR("error getting rtpp_list for set %d\n", set_id);
+			LM_ERR("error getting rtpp_list for set %d\n", setid);
 			continue;
 		}
 
-		if (add_rtpengine_socks(rtpp_list, url.s) !=  0)
+		if (add_rtpengine_socks(rtpp_list, url.s, weight, disabled, ticks, 1) !=  0)
 		{
-			LM_ERR("error inserting '%.*s' into set %d\n", url.len, url.s, set_id);
+			LM_ERR("error inserting '%.*s' into set %d disabled=%d\n",
+				url.len, url.s, setid, disabled);
 		}
 	}
 
