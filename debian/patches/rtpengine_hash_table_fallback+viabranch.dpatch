#! /bin/sh /usr/share/dpatch/dpatch-run
## rtpengine_hash_table_fallback+viabranch.dpatch by  <miti@dell>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/rtpengine.c ui-siprouter/modules/rtpengine/rtpengine.c
--- ui-siprouter~/modules/rtpengine/rtpengine.c	2015-12-07 13:20:52.000000000 +0200
+++ ui-siprouter/modules/rtpengine/rtpengine.c	2015-12-07 13:24:08.689284563 +0200
@@ -343,9 +343,9 @@
 static int fixup_set_id(void ** param, int param_no);
 static int set_rtpengine_set_f(struct sip_msg * msg, char * str1, char * str2);
 static struct rtpp_set * select_rtpp_set(int id_set);
-static struct rtpp_node *select_rtpp_node_new(str, int, int);
-static struct rtpp_node *select_rtpp_node_old(str, int, int);
-static struct rtpp_node *select_rtpp_node(str, int, int);
+static struct rtpp_node *select_rtpp_node_new(str, str, int);
+static struct rtpp_node *select_rtpp_node_old(str, str, int);
+static struct rtpp_node *select_rtpp_node(str, str, int);
 static char *send_rtpp_command(struct rtpp_node *, bencode_item_t *, int *);
 static int get_extra_id(struct sip_msg* msg, str *id_str);
 
@@ -368,6 +368,7 @@
 
 /* Pseudo-Variables */
 static int pv_get_rtpstat_f(struct sip_msg *, pv_param_t *, pv_value_t *);
+static int set_rtp_inst_pvar(struct sip_msg *msg, const str * const uri);
 
 /*mi commands*/
 static struct mi_root* mi_enable_rtp_proxy(struct mi_root* cmd_tree, void* param);
@@ -385,7 +386,7 @@
 static unsigned int myseqn = 0;
 static str extra_id_pv_param = {NULL, 0};
 static char *setid_avp_param = NULL;
-static int hash_table_tout = 120;
+static int hash_table_tout = 3600;
 static int hash_table_size = 256;
 
 static char ** rtpp_strings=0;
@@ -1966,8 +1967,9 @@
 {
 	struct ng_flags_parse ng_flags;
 	bencode_item_t *item, *resp;
-	str callid, from_tag, to_tag, body, viabranch, error;
-	str temp,temp_fromtag;
+	str callid = STR_NULL, from_tag = STR_NULL, to_tag = STR_NULL, viabranch = STR_NULL;
+	str body = STR_NULL, error = STR_NULL;
+	str temp = STR_NULL, temp_fromtag = STR_NULL;
 	int ret, queried_nodes;
 	struct rtpp_node *node;
 	char *cp;
@@ -2096,9 +2098,9 @@
             goto error;
         }
 		if (temp.s)
-			node = select_rtpp_node(temp, 1, op);
+			node = select_rtpp_node(temp, viabranch, 1);
 		else 
-			node = select_rtpp_node(callid, 1, op);
+			node = select_rtpp_node(callid, viabranch, 1);
 		if (!node) {
 			LM_ERR("no available proxies\n");
 			goto error;
@@ -2141,12 +2143,12 @@
 
 	if (op == OP_DELETE) {
 		/* Delete the key<->value from the hashtable */
-		if (!rtpengine_hash_table_remove(&callid)) {
-			LM_ERR("rtpengine hash table failed to remove entry for callen=%d callid=%.*s\n",
-				callid.len, callid.len, callid.s);
+		if (!rtpengine_hash_table_remove(callid, viabranch)) {
+			LM_ERR("rtpengine hash table failed to remove entry for callen=%d callid=%.*s viabranch=%.*s\n",
+				callid.len, callid.len, callid.s, viabranch.len, viabranch.s);
 		} else {
-			LM_DBG("rtpengine hash table remove entry for callen=%d callid=%.*s\n",
-				callid.len, callid.len, callid.s);
+			LM_DBG("rtpengine hash table remove entry for callen=%d callid=%.*s viabranch=%.*s\n",
+				callid.len, callid.len, callid.s, viabranch.len, viabranch.s);
 		}
 	}
 
@@ -2383,13 +2385,14 @@
  * run the selection algorithm and return the new selected node
  */
 static struct rtpp_node *
-select_rtpp_node_new(str callid, int do_test, int op)
+select_rtpp_node_new(str callid, str viabranch, int do_test)
 {
 	struct rtpp_node* node;
 	unsigned i, sum, sumcut, weight_sum;
 	int was_forced = 0;
 
 	/* XXX Use quick-and-dirty hashing algo */
+	sum = 0;
 	for(i = 0; i < callid.len; i++)
 		sum += callid.s[i];
 	sum &= 0xff;
@@ -2453,26 +2456,48 @@
 			goto retry;
 	}
 
-	/* build hash table entry */
-	struct rtpengine_hash_entry *entry = shm_malloc(sizeof(struct rtpp_node));
-	if (shm_str_dup(&entry->callid, &callid) < 0) {
-		LM_ERR("rtpengine hash table fail to duplicate calllen=%d callid=%.*s",
-			callid.len, callid.len, callid.s);
+	/* build the entry */
+	struct rtpengine_hash_entry *entry = shm_malloc(sizeof(struct rtpengine_hash_entry));
+	if (!entry) {
+		LM_ERR("rtpengine hash table fail to create entry for calllen=%d callid=%.*s viabranch=%.*s\n",
+			callid.len, callid.len, callid.s, viabranch.len, viabranch.s);
+		return node;
+	}
+        memset(entry, 0, sizeof(struct rtpengine_hash_entry));
+
+	/* fill the entry */
+	if (callid.s && callid.len > 0) {
+		if (shm_str_dup(&entry->callid, &callid) < 0) {
+			LM_ERR("rtpengine hash table fail to duplicate calllen=%d callid=%.*s\n",
+				callid.len, callid.len, callid.s);
+			rtpengine_hash_table_free_entry(entry);
+			return node;
+		}
+	}
+	if (viabranch.s && viabranch.len > 0) {
+		if (shm_str_dup(&entry->viabranch, &viabranch) < 0) {
+			LM_ERR("rtpengine hash table fail to duplicate calllen=%d viabranch=%.*s\n",
+				callid.len, viabranch.len, viabranch.s);
+			rtpengine_hash_table_free_entry(entry);
+			return node;
+		}
 	}
 	entry->node = node;
 	entry->next = NULL;
 	entry->tout = get_ticks() + hash_table_tout;
 
-	/* Insert the key<->entry from the hashtable */
-	if (!rtpengine_hash_table_insert(&callid, entry)) {
-		LM_ERR("rtpengine hash table fail to insert node=%.*s for calllen=%d callid=%.*s",
-			node->rn_url.len, node->rn_url.s, callid.len, callid.len, callid.s);
+	/* insert the key<->entry from the hashtable */
+	if (!rtpengine_hash_table_insert(callid, viabranch, entry)) {
+		LM_ERR("rtpengine hash table fail to insert node=%.*s for calllen=%d callid=%.*s viabranch=%.*s\n",
+			node->rn_url.len, node->rn_url.s, callid.len, callid.len, callid.s, viabranch.len, viabranch.s);
+		rtpengine_hash_table_free_entry(entry);
+		return node;
 	} else {
-		LM_DBG("rtpengine hash table insert node=%.*s for calllen=%d callid=%.*s\n",
-			node->rn_url.len, node->rn_url.s, callid.len, callid.len, callid.s);
+		LM_DBG("rtpengine hash table insert node=%.*s for calllen=%d callid=%.*s viabranch=%.*s\n",
+			node->rn_url.len, node->rn_url.s, callid.len, callid.len, callid.s, viabranch.len, viabranch.s);
 	}
 
-	/* Return selected node  */
+	/* return selected node */
 	return node;
 }
 
@@ -2480,50 +2505,22 @@
  * lookup the hastable (key=callid value=node) and get the old node (e.g. for answer/delete)
  */
 static struct rtpp_node *
-select_rtpp_node_old(str callid, int do_test, int op)
+select_rtpp_node_old(str callid, str viabranch, int do_test)
 {
 	struct rtpp_node *node = NULL;
-	struct rtpengine_hash_entry *entry = NULL;
 
-	entry = rtpengine_hash_table_lookup(&callid);
-	if (!entry) {
-		LM_ERR("rtpengine hash table lookup failed to find entry for calllen=%d callid=%.*s\n",
-			callid.len, callid.len, callid.s);
-	} else {
-		LM_DBG("rtpengine hash table lookup find entry for calllen=%d callid=%.*s\n",
-			callid.len, callid.len, callid.s);
-		node = entry->node;
-	}
+	node = rtpengine_hash_table_lookup(callid, viabranch);
 
 	if (!node) {
-		LM_ERR("rtpengine hash table lookup failed to find node for calllen=%d callid=%.*s\n",
-			callid.len, callid.len, callid.s);
+		LM_NOTICE("rtpengine hash table lookup failed to find node for calllen=%d callid=%.*s viabranch=%.*s\n",
+			callid.len, callid.len, callid.s, viabranch.len, viabranch.s);
 		return NULL;
 	} else {
-		LM_DBG("rtpengine hash table lookup find node=%.*s for calllen=%d callid=%.*s\n",
-			node->rn_url.len, node->rn_url.s, callid.len, callid.len, callid.s);
-	}
-
-	// if node enabled, return it
-	if (!node->rn_disabled) {
-		return node;
-	}
-
-	// if node _manually_ disabled(e.g kamctl) and proper configuration, return it
-	if (node->rn_recheck_ticks == MI_MAX_RECHECK_TICKS) {
-		if (rtpengine_allow_op) {
-			LM_DBG("node=%.*s for calllen=%d callid=%.*s is disabled(permanent) (probably still UP)! Return it\n",
-				node->rn_url.len, node->rn_url.s, callid.len, callid.len, callid.s);
-			return node;
-		}
-		LM_DBG("node=%.*s for calllen=%d callid=%.*s is disabled(permanent) (probably still UP)! Return NULL\n",
-			node->rn_url.len, node->rn_url.s, callid.len, callid.len, callid.s);
-	} else {
-		LM_DBG("node=%.*s for calllen=%d callid=%.*s is disabled (probably BROKE)! Return NULL\n",
-			node->rn_url.len, node->rn_url.s, callid.len, callid.len, callid.s);
+		LM_DBG("rtpengine hash table lookup find node=%.*s for calllen=%d callid=%.*s viabranch=%.*s\n",
+			node->rn_url.len, node->rn_url.s, callid.len, callid.len, callid.s, viabranch.len, viabranch.s);
 	}
 
-	return NULL;
+	return node;
 }
 
 /*
@@ -2531,21 +2528,51 @@
  * the call if some proxies were disabled or enabled (e.g. kamctl command)
  */
 static struct rtpp_node *
-select_rtpp_node(str callid, int do_test, int op)
+select_rtpp_node(str callid, str viabranch, int do_test)
 {
+	struct rtpp_node *node = NULL;
+
 	if(!active_rtpp_set) {
 		LM_ERR("script error - no valid set selected\n");
 		return NULL;
 	}
 
-	// calculate and choose a node
-	if (op == OP_OFFER) {
+	// lookup node
+	node = select_rtpp_node_old(callid, viabranch, do_test);
+
+	// check node
+	if (!node) {
 		// run the selection algorithm
-		return select_rtpp_node_new(callid, do_test, op);
-	} else {
-		// lookup the hastable (key=callid value=node) and get the old node
-		return select_rtpp_node_old(callid, do_test, op);
+		node = select_rtpp_node_new(callid, viabranch, do_test);
+
+		// check node
+		if (!node) {
+			LM_ERR("rtpengine failed to select new for calllen=%d callid=%.*s\n",
+				callid.len, callid.len, callid.s);
+			return NULL;
+		}
+	}
+
+	// if node enabled, return it
+	if (!node->rn_disabled) {
+		return node;
+	}
+
+	// if proper configuration and node manually or timeout disabled, return it
+	if (rtpengine_allow_op) {
+		if (node->rn_recheck_ticks == MI_MAX_RECHECK_TICKS) {
+			LM_DBG("node=%.*s for calllen=%d callid=%.*s is disabled(permanent) (probably still UP)! Return it\n",
+				node->rn_url.len, node->rn_url.s, callid.len, callid.len, callid.s);
+		} else {
+			LM_DBG("node=%.*s for calllen=%d callid=%.*s is disabled, either broke or timeout disabled! Return it\n",
+				node->rn_url.len, node->rn_url.s, callid.len, callid.len, callid.s);
+		}
+		return node;
 	}
+
+
+
+	return NULL;
 }
 
 static int
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/rtpengine.h ui-siprouter/modules/rtpengine/rtpengine.h
--- ui-siprouter~/modules/rtpengine/rtpengine.h	2015-12-07 13:20:52.000000000 +0200
+++ ui-siprouter/modules/rtpengine/rtpengine.h	2015-12-07 13:20:52.000000000 +0200
@@ -65,7 +65,6 @@
 struct rtpp_set *get_rtpp_set(int set_id);
 int add_rtpengine_socks(struct rtpp_set * rtpp_list, char * rtpproxy);
 
-int set_rtp_inst_pvar(struct sip_msg *msg, const str * const uri);
 
 int init_rtpproxy_db(void);
 
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/rtpengine_hash.c ui-siprouter/modules/rtpengine/rtpengine_hash.c
--- ui-siprouter~/modules/rtpengine/rtpengine_hash.c	2015-12-07 13:20:52.000000000 +0200
+++ ui-siprouter/modules/rtpengine/rtpengine_hash.c	2015-12-07 13:20:52.000000000 +0200
@@ -11,26 +11,25 @@
 static int hash_table_size;
 
 /* from sipwise rtpengine */
-static int str_cmp_str(const str *a, const str *b) {
-	if (a->len < b->len)
+static int str_cmp_str(const str a, const str b) {
+	if (a.len < b.len)
 		return -1;
-	if (a->len > b->len)
+	if (a.len > b.len)
 		return 1;
-	if (a->len == 0 && b->len == 0)
+	if (a.len == 0 && b.len == 0)
 		return 0;
-	return memcmp(a->s, b->s, a->len);
+	return memcmp(a.s, b.s, a.len);
 }
 
 /* from sipwise rtpengine */
-static int str_equal(void *a, void *b) {
-	return (str_cmp_str((str *) a, (str *) b) == 0);
+static int str_equal(str a, str b) {
+	return (str_cmp_str(a, b) == 0);
 }
 
 /* from sipwise rtpengine */
-static unsigned int str_hash(void *ss) {
-	const str *s = (str*) ss;
+static unsigned int str_hash(str s) {
 	unsigned int ret = 5381;
-	str it = *s;
+	str it = s;
 
 	while (it.len > 0) {
 		ret = (ret << 5) + ret + *it.s;
@@ -41,7 +40,7 @@
 	return ret % hash_table_size;
 }
 
-/* rtpengine glib hash API */
+/* rtpengine hash API */
 int rtpengine_hash_table_init(int size) {
 	int i;
 
@@ -59,17 +58,26 @@
 		LM_ERR("no shm left to create rtpengine_hash_table\n");
 		return 0;
 	}
+	memset(rtpengine_hash_table, 0, sizeof(struct rtpengine_hash_table));
 
 	// init hashtable entry_list
 	rtpengine_hash_table->entry_list = shm_malloc(hash_table_size * sizeof(struct rtpengine_hash_entry));
+	if (!rtpengine_hash_table->entry_list) {
+		LM_ERR("no shm left to create rtpengine_hash_table->entry_list\n");
+		rtpengine_hash_table_destroy();
+		return 0;
+	}
+	memset(rtpengine_hash_table->entry_list, 0, hash_table_size * sizeof(struct rtpengine_hash_entry));
 
-	// init hashtable entry_list[i] (head never filled)
+	// init hashtable entry_list[i] (head never filled); destroy table on error
 	for (i = 0; i < hash_table_size; i++) {
 		rtpengine_hash_table->entry_list[i] = shm_malloc(sizeof(struct rtpengine_hash_entry));
 		if (!rtpengine_hash_table->entry_list[i]) {
 			LM_ERR("no shm left to create rtpengine_hash_table->entry_list[%d]\n", i);
+			rtpengine_hash_table_destroy();
 			return 0;
 		}
+		memset(rtpengine_hash_table->entry_list[i], 0, sizeof(struct rtpengine_hash_entry));
 
 		// never expire the head of the hashtable index lists
 		rtpengine_hash_table->entry_list[i]->tout = -1;
@@ -81,6 +89,7 @@
 	rtpengine_hash_lock = lock_alloc();
 	if (!rtpengine_hash_lock) {
 		LM_ERR("no shm left to init rtpengine_hash_table lock");
+		rtpengine_hash_table_destroy();
 		return 0;
 	}
 
@@ -89,7 +98,6 @@
 
 int rtpengine_hash_table_destroy() {
 	int i;
-	struct rtpengine_hash_entry *entry, *last_entry;
 
 	// check rtpengine hashtable
 	if (!rtpengine_hash_table) {
@@ -97,24 +105,29 @@
 		return 0;
 	}
 
-	// destroy hashtable entry_list[i]
+	// check rtpengine hashtable->entry_list
+	if (!rtpengine_hash_table->entry_list) {
+		LM_ERR("NULL rtpengine_hash_table->entry_list");
+		shm_free(rtpengine_hash_table);
+		rtpengine_hash_table = NULL;
+		return 0;
+	}
+
 	lock_get(rtpengine_hash_lock);
+
+	// destroy hashtable entry_list[i]
 	for (i = 0; i < hash_table_size; i++) {
-		entry = rtpengine_hash_table->entry_list[i];
-		while (entry) {
-			last_entry = entry;
-			entry = entry->next;
-			shm_free(last_entry->callid.s);
-			shm_free(last_entry);
-		}
+		rtpengine_hash_table_free_entry_list(rtpengine_hash_table->entry_list[i]);
 	}
 
 	// destroy hashtable entry_list
 	shm_free(rtpengine_hash_table->entry_list);
+	rtpengine_hash_table->entry_list = NULL;
 
 	// destroy hashtable
 	shm_free(rtpengine_hash_table);
 	rtpengine_hash_table = NULL;
+
 	lock_release(rtpengine_hash_lock);
 
 	// destroy lock
@@ -128,7 +141,7 @@
 	return 1;
 }
 
-int rtpengine_hash_table_insert(void *key, void *value) {
+int rtpengine_hash_table_insert(str callid, str viabranch, struct rtpengine_hash_entry *value) {
 	struct rtpengine_hash_entry *entry, *last_entry;
 	struct rtpengine_hash_entry *new_entry = (struct rtpengine_hash_entry *) value;
 	unsigned int hash_index;
@@ -139,19 +152,28 @@
 		return 0;
 	}
 
+	// check rtpengine hashtable->entry_list
+	if (!rtpengine_hash_table->entry_list) {
+		LM_ERR("NULL rtpengine_hash_table->entry_list");
+		return 0;
+	}
+
 	// get entry list
-	hash_index = str_hash(key);
+	hash_index = str_hash(callid);
 	entry = rtpengine_hash_table->entry_list[hash_index];
 	last_entry = entry;
 
 	// lock
 	lock_get(rtpengine_hash_lock);
 	while (entry) {
-		// if key found, don't add new entry
-		if (str_equal(&entry->callid, &new_entry->callid)) {
+		// if found, don't add new entry
+		if (str_equal(entry->callid, new_entry->callid) &&
+		    str_equal(entry->viabranch, new_entry->viabranch)) {
 			// unlock
 			lock_release(rtpengine_hash_lock);
-			LM_ERR("Call id %.*s already in hashtable, ignore new value", entry->callid.len, entry->callid.s);
+			LM_NOTICE("callid=%.*s, viabranch=%.*s already in hashtable, ignore new value",
+				entry->callid.len, entry->callid.s,
+				entry->viabranch.len, entry->viabranch.s);
 			return 0;
 		}
 
@@ -161,8 +183,7 @@
 			last_entry->next = entry->next;
 
 			// free current entry; entry points to unknown
-			shm_free(entry->callid.s);
-			shm_free(entry);
+			rtpengine_hash_table_free_entry(entry);
 
 			// set pointers
 			entry = last_entry;
@@ -177,6 +198,8 @@
 	}
 
 	last_entry->next = new_entry;
+
+	// update total
 	rtpengine_hash_table->total++;
 
 	// unlock
@@ -185,7 +208,7 @@
 	return 1;
 }
 
-int rtpengine_hash_table_remove(void *key) {
+int rtpengine_hash_table_remove(str callid, str viabranch) {
 	struct rtpengine_hash_entry *entry, *last_entry;
 	unsigned int hash_index;
 
@@ -195,20 +218,26 @@
 		return 0;
 	}
 
+	// check rtpengine hashtable->entry_list
+	if (!rtpengine_hash_table->entry_list) {
+		LM_ERR("NULL rtpengine_hash_table->entry_list");
+		return 0;
+	}
+
 	// get first entry from entry list; jump over unused list head
-	hash_index = str_hash(key);
+	hash_index = str_hash(callid);
 	entry = rtpengine_hash_table->entry_list[hash_index];
 	last_entry = entry;
 
 	// lock
 	lock_get(rtpengine_hash_lock);
 	while (entry) {
-		// if key found, delete entry
-		if (str_equal(&entry->callid, (str *)key)) {
+		// if callid found, delete entry
+		if (str_equal(entry->callid, callid) &&
+		    str_equal(entry->viabranch, viabranch)) {
 			// free entry
 			last_entry->next = entry->next;
-			shm_free(entry->callid.s);
-			shm_free(entry);
+			rtpengine_hash_table_free_entry(entry);
 
 			// update total
 			rtpengine_hash_table->total--;
@@ -225,8 +254,7 @@
 			last_entry->next = entry->next;
 
 			// free current entry; entry points to unknown
-			shm_free(entry->callid.s);
-			shm_free(entry);
+			rtpengine_hash_table_free_entry(entry);
 
 			// set pointers
 			entry = last_entry;
@@ -245,30 +273,40 @@
 	return 0;
 }
 
-void* rtpengine_hash_table_lookup(void *key) {
+struct rtpp_node *rtpengine_hash_table_lookup(str callid, str viabranch) {
 	struct rtpengine_hash_entry *entry, *last_entry;
 	unsigned int hash_index;
+	struct rtpp_node *node;
 
 	// check rtpengine hashtable
 	if (!rtpengine_hash_table) {
 		LM_ERR("NULL rtpengine_hash_table");
-		return 0;
+		return NULL;
+	}
+
+	// check rtpengine hashtable->entry_list
+	if (!rtpengine_hash_table->entry_list) {
+		LM_ERR("NULL rtpengine_hash_table->entry_list");
+		return NULL;
 	}
 
 	// get first entry from entry list; jump over unused list head
-	hash_index = str_hash(key);
+	hash_index = str_hash(callid);
 	entry = rtpengine_hash_table->entry_list[hash_index];
 	last_entry = entry;
 
 	// lock
 	lock_get(rtpengine_hash_lock);
 	while (entry) {
-		// if key found, return entry
-		if (str_equal(&entry->callid, (str *)key)) {
+		// if callid found, return entry
+		if (str_equal(entry->callid, callid) &&
+		    str_equal(entry->viabranch, viabranch)) {
+			node = entry->node;
+
 			// unlock
 			lock_release(rtpengine_hash_lock);
 
-			return entry;
+			return node;
 		}
 
 		// if expired entry discovered, delete it
@@ -277,8 +315,7 @@
 			last_entry->next = entry->next;
 
 			// free current entry; entry points to unknown
-			shm_free(entry->callid.s);
-			shm_free(entry);
+			rtpengine_hash_table_free_entry(entry);
 
 			// set pointers
 			entry = last_entry;
@@ -308,6 +345,12 @@
 		return ;
 	}
 
+	// check rtpengine hashtable->entry_list
+	if (!rtpengine_hash_table->entry_list) {
+		LM_ERR("NULL rtpengine_hash_table->entry_list");
+		return ;
+	}
+
 	// lock
 	lock_get(rtpengine_hash_lock);
 
@@ -323,8 +366,7 @@
 				last_entry->next = entry->next;
 
 				// free current entry; entry points to unknown
-				shm_free(entry->callid.s);
-				shm_free(entry);
+				rtpengine_hash_table_free_entry(entry);
 
 				// set pointers
 				entry = last_entry;
@@ -355,3 +397,41 @@
 
 	return rtpengine_hash_table->total;
 }
+
+void rtpengine_hash_table_free_entry(struct rtpengine_hash_entry *entry) {
+	if (!entry) {
+		return ;
+	}
+
+	// free callid
+	if (entry->callid.s) {
+		shm_free(entry->callid.s);
+	}
+
+	// free viabranch
+	if (entry->viabranch.s) {
+		shm_free(entry->viabranch.s);
+	}
+
+	// free entry
+	shm_free(entry);
+
+	return ;
+}
+
+void rtpengine_hash_table_free_entry_list(struct rtpengine_hash_entry *entry_list) {
+	struct rtpengine_hash_entry *entry, *last_entry;
+
+	if (!entry_list) {
+		return ;
+	}
+
+	entry = entry_list;
+	while (entry) {
+		last_entry = entry;
+		entry = entry->next;
+		rtpengine_hash_table_free_entry(last_entry);
+	}
+
+	return ;
+}
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/rtpengine_hash.h ui-siprouter/modules/rtpengine/rtpengine_hash.h
--- ui-siprouter~/modules/rtpengine/rtpengine_hash.h	2015-12-07 13:20:52.000000000 +0200
+++ ui-siprouter/modules/rtpengine/rtpengine_hash.h	2015-12-07 13:20:52.000000000 +0200
@@ -6,10 +6,11 @@
 
 /* table entry */
 struct rtpengine_hash_entry {
-	unsigned int tout;			// call timeout
 	str callid;				// call callid
+	str viabranch;				// call viabranch
 	struct rtpp_node *node;			// call selected node
 
+	unsigned int tout;			// call timeout
 	struct rtpengine_hash_entry *next;	// call next
 };
 
@@ -22,10 +23,13 @@
 
 int rtpengine_hash_table_init(int size);
 int rtpengine_hash_table_destroy();
-int rtpengine_hash_table_insert(void *key, void *value);
-int rtpengine_hash_table_remove(void *key);
-void* rtpengine_hash_table_lookup(void *key);
+int rtpengine_hash_table_insert(str callid, str viabranch, struct rtpengine_hash_entry *value);
+int rtpengine_hash_table_remove(str callid, str viabranch);
+struct rtpp_node *rtpengine_hash_table_lookup(str callid, str viabranch);
 void rtpengine_hash_table_print();
 unsigned int rtpengine_hash_table_total();
 
+void rtpengine_hash_table_free_entry(struct rtpengine_hash_entry *entry);
+void rtpengine_hash_table_free_entry_list(struct rtpengine_hash_entry *entry_list);
+
 #endif
