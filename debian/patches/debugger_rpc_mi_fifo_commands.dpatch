#! /bin/sh /usr/share/dpatch/dpatch-run
## debugger_mi_fifo_commands.dpatch by  <miti@dell>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/dprint.c ui-siprouter/dprint.c
--- ui-siprouter~/dprint.c	2016-01-07 12:16:06.000000000 +0200
+++ ui-siprouter/dprint.c	2016-01-07 12:16:06.000000000 +0200
@@ -84,13 +84,27 @@
 {
 	int i;
 
-	for( i=0; str_fac[i] ; i++) {
+	for (i=0; str_fac[i]; i++) {
 		if (!strcasecmp(s,str_fac[i]))
 			return int_fac[i];
 	}
 	return -1;
 }
 
+char* facility2str(int fl, int *len)
+{
+	int i;
+
+	for (i=0; str_fac[i]; i++) {
+		if (fl == int_fac[i]) {
+			*len = strlen(str_fac[i]);
+			return str_fac[i];
+		}
+	}
+
+	return NULL;
+}
+
 /* fixup function for log_facility cfg parameter */
 int log_facility_fixup(void *handle, str *gname, str *name, void **val)
 {
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/dprint.h ui-siprouter/dprint.h
--- ui-siprouter~/dprint.h	2016-01-07 12:16:06.000000000 +0200
+++ ui-siprouter/dprint.h	2016-01-07 12:16:06.000000000 +0200
@@ -150,6 +150,8 @@
 #endif
 
 int str2facility(char *s);
+char* facility2str(int fl, int *len);
+
 int log_facility_fixup(void *handle, str *gname, str *name, void **val);
 
 void dprint_color(int level);
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/debugger/Makefile ui-siprouter/modules/debugger/Makefile
--- ui-siprouter~/modules/debugger/Makefile	2016-01-07 12:16:04.000000000 +0200
+++ ui-siprouter/modules/debugger/Makefile	2016-01-07 12:16:06.000000000 +0200
@@ -1,4 +1,3 @@
-# $Id$
 #
 # WARNING: do not run this directly, it should be run by the master Makefile
 
@@ -11,4 +10,5 @@
 
 SERLIBPATH=../../lib
 SER_LIBS+=$(SERLIBPATH)/srutils/srutils
+SER_LIBS+=$(SERLIBPATH)/kmi/kmi
 include ../../Makefile.modules
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/debugger/debugger_api.c ui-siprouter/modules/debugger/debugger_api.c
--- ui-siprouter~/modules/debugger/debugger_api.c	2016-01-07 12:16:06.000000000 +0200
+++ ui-siprouter/modules/debugger/debugger_api.c	2016-01-07 12:18:38.770875490 +0200
@@ -935,12 +935,12 @@
 /**
  *
  */
-static const char* dbg_rpc_mod_level_doc[2] = {
-	"Specify module log level",
+static const char* dbg_rpc_set_mod_level_doc[2] = {
+	"Set module log level",
 	0
 };
 
-static void dbg_rpc_mod_level(rpc_t* rpc, void* ctx){
+static void dbg_rpc_set_mod_level(rpc_t* rpc, void* ctx){
 	int l;
 	str value = {0,0};
 
@@ -961,12 +961,12 @@
 /**
  *
  */
-static const char* dbg_rpc_mod_facility_doc[2] = {
-	"Specify module log facility",
+static const char* dbg_rpc_set_mod_facility_doc[2] = {
+	"Set module log facility",
 	0
 };
 
-static void dbg_rpc_mod_facility(rpc_t* rpc, void* ctx) {
+static void dbg_rpc_set_mod_facility(rpc_t* rpc, void* ctx) {
 	int fl;
 	str value = {0, 0};
 	str facility = {0, 0};
@@ -993,6 +993,55 @@
 /**
  *
  */
+static const char* dbg_rpc_get_mod_level_doc[2] = {
+	"Get module log level",
+	0
+};
+
+static void dbg_rpc_get_mod_level(rpc_t* rpc, void* ctx){
+	int l;
+	str value = {0,0};
+
+	if (rpc->scan(ctx, "S", &value) < 1)
+	{
+		rpc->fault(ctx, 500, "invalid parameters");
+		return;
+	}
+
+	l = get_debug_level(value.s, value.len);
+
+	rpc->add(ctx, "d", l);
+}
+
+/**
+ *
+ */
+static const char* dbg_rpc_get_mod_facility_doc[2] = {
+	"Get module log facility",
+	0
+};
+
+static void dbg_rpc_get_mod_facility(rpc_t* rpc, void* ctx) {
+	int fl;
+	str value = {0, 0};
+	str facility = {0, 0};
+
+	if (rpc->scan(ctx, "S", &value) < 1)
+	{
+	    rpc->fault(ctx, 500, "invalid parameters");
+	    return;
+	}
+
+	fl = get_debug_facility(value.s, value.len);
+	facility.s = facility2str(fl, &facility.len);
+
+	rpc->add(ctx, "S", &facility);
+}
+
+
+/**
+ *
+ */
 static const char* dbg_rpc_reset_msgid_doc[2] = {
 	"Reset msgid on all process",
 	0
@@ -1030,8 +1079,10 @@
 	{"dbg.bp",        dbg_rpc_bp,        dbg_rpc_bp_doc,        0},
 	{"dbg.ls",        dbg_rpc_list,      dbg_rpc_list_doc,      0},
 	{"dbg.trace",     dbg_rpc_trace,     dbg_rpc_trace_doc,     0},
-	{"dbg.mod_level", dbg_rpc_mod_level, dbg_rpc_mod_level_doc, 0},
-	{"dbg.mod_facility", dbg_rpc_mod_facility, dbg_rpc_mod_facility_doc, 0},
+	{"dbg.set_mod_level", dbg_rpc_set_mod_level, dbg_rpc_set_mod_level_doc, 0},
+	{"dbg.set_mod_facility", dbg_rpc_set_mod_facility, dbg_rpc_set_mod_facility_doc, 0},
+	{"dbg.get_mod_level", dbg_rpc_get_mod_level, dbg_rpc_get_mod_level_doc, 0},
+	{"dbg.get_mod_facility", dbg_rpc_get_mod_facility, dbg_rpc_get_mod_facility_doc, 0},
 	{"dbg.reset_msgid", dbg_rpc_reset_msgid, dbg_rpc_reset_msgid_doc, 0},
 	{0, 0, 0, 0}
 };
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/debugger/debugger_mod.c ui-siprouter/modules/debugger/debugger_mod.c
--- ui-siprouter~/modules/debugger/debugger_mod.c	2016-01-07 12:16:06.000000000 +0200
+++ ui-siprouter/modules/debugger/debugger_mod.c	2016-01-07 12:16:06.000000000 +0200
@@ -27,6 +27,8 @@
 #include <stdlib.h>
 #include <string.h>
 
+#include "../../lib/kmi/mi.h"
+#include "../../lib/kmi/tree.h"
 #include "../../sr_module.h"
 #include "../../dprint.h"
 #include "../../ut.h"
@@ -59,6 +61,12 @@
 
 extern char* dump_lump_list(struct lump *list, int s_offset, char *s_buf);
 
+/* mi commands */
+static struct mi_root* mi_set_dbg_mod_level(struct mi_root *cmd_tree, void *param);
+static struct mi_root* mi_set_dbg_mod_facility(struct mi_root *cmd_tree, void *param);
+static struct mi_root* mi_get_dbg_mod_level(struct mi_root *cmd_tree, void *param);
+static struct mi_root* mi_get_dbg_mod_facility(struct mi_root *cmd_tree, void *param);
+
 /* parameters */
 extern int _dbg_cfgtrace;
 extern int _dbg_cfgpkgcheck;
@@ -111,13 +119,21 @@
 	{0, 0, 0}
 };
 
+static mi_export_t mi_cmds[] = {
+	{"set_dbg_mod_level",         mi_set_dbg_mod_level, 0, 0, 0},
+	{"set_dbg_mod_facility",      mi_set_dbg_mod_facility, 0, 0, 0},
+	{"get_dbg_mod_level",         mi_get_dbg_mod_level, 0, 0, 0},
+	{"get_dbg_mod_facility",      mi_get_dbg_mod_facility, 0, 0, 0},
+	{ 0, 0, 0, 0, 0}
+};
+
 struct module_exports exports = {
 	"debugger",
 	DEFAULT_DLFLAGS, /* dlopen flags */
 	cmds,
 	params,
 	0,
-	0,              /* exported MI functions */
+	mi_cmds,        /* exported MI functions */
 	0,              /* exported pseudo-variables */
 	0,              /* extra processes */
 	mod_init,       /* module initialization function */
@@ -127,12 +143,266 @@
 };
 
 
+static struct mi_root* mi_set_dbg_mod_level(struct mi_root *cmd_tree, void *param) {
+	struct mi_node *node;
+	str mod_str, level_str;
+	int l;
+
+	/* get first param */
+	node = cmd_tree->node.kids;
+	if (node == NULL) {
+		return init_mi_tree(400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
+	}
+
+	if (node->value.s == NULL || node->value.len == 0) {
+		return init_mi_tree(400, MI_BAD_PARM_S, MI_BAD_PARM_LEN);
+	}
+
+	/* get module str */
+	mod_str = node->value;
+
+	/* get second param */
+	node = node->next;
+	if (node == NULL) {
+		return init_mi_tree(400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
+	}
+
+	if (node->value.s == NULL || node->value.len == 0) {
+		return init_mi_tree(400, MI_BAD_PARM_S, MI_BAD_PARM_LEN);
+	}
+
+	/* get level str */
+	level_str = node->value;
+
+	/* no further params expected */
+	node = node->next;
+	if (node != NULL) {
+		return init_mi_tree(400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
+	}
+
+	/* get level int */
+	if (str2sint(&level_str, &l) < 0) {
+		LM_ERR("invalid parameter - level value: %.*s\n",
+			level_str.len, level_str.s);
+		return init_mi_tree(400, MI_BAD_PARM_S, MI_BAD_PARM_LEN);
+	}
+
+	/* set level int */
+	if (default_dbg_cfg.mod_hash_size <= 0 || default_dbg_cfg.mod_level_mode <= 0) {
+		LM_ERR("can't set level for module=%.*s; enable mod_hash_size and mod_level_mode config parameters!\n",
+			mod_str.len, mod_str.s);
+		return init_mi_tree(500, MI_INTERNAL_ERR_S, MI_INTERNAL_ERR_LEN);
+	} else if (dbg_set_mod_debug_level(mod_str.s, mod_str.len, &l) < 0) {
+		LM_ERR("failed set level for module=%.*s\n", mod_str.len, mod_str.s);
+		return init_mi_tree(500, MI_INTERNAL_ERR_S, MI_INTERNAL_ERR_LEN);
+	} else {
+		LM_DBG("module=%.*s level_str=%.*s level_int=%d\n",
+			mod_str.len, mod_str.s, level_str.len, level_str.s, l);
+	}
+
+	return init_mi_tree(200, MI_OK_S, MI_OK_LEN);
+}
+
+static struct mi_root* mi_set_dbg_mod_facility(struct mi_root *cmd_tree, void *param) {
+	struct mi_node *node;
+	str mod_str, facility_str;
+	int fl;
+
+	/* get first param */
+	node = cmd_tree->node.kids;
+	if (node == NULL) {
+		return init_mi_tree(400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
+	}
+
+	if (node->value.s == NULL || node->value.len == 0) {
+		return init_mi_tree(400, MI_BAD_PARM_S, MI_BAD_PARM_LEN);
+	}
+
+	/* get module str */
+	mod_str = node->value;
+
+	/* get second param */
+	node = node->next;
+	if (node == NULL) {
+		return init_mi_tree(400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
+	}
+
+	if (node->value.s == NULL || node->value.len == 0) {
+		return init_mi_tree(400, MI_BAD_PARM_S, MI_BAD_PARM_LEN);
+	}
+
+	/* get facility str */
+	facility_str = node->value;
+
+	/* no further params expected */
+	node = node->next;
+	if (node != NULL) {
+		return init_mi_tree(400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
+	}
+
+	/* get facility int */
+	facility_str.s[facility_str.len] = '\0';
+	if ((fl = str2facility(facility_str.s)) == -1) {
+		LM_ERR("invalid parameter - facility value: %.*s\n",
+			facility_str.len, facility_str.s);
+		return init_mi_tree(400, MI_BAD_PARM_S, MI_BAD_PARM_LEN);
+	}
+
+	/* set facility int */
+	if (default_dbg_cfg.mod_hash_size <= 0 || default_dbg_cfg.mod_facility_mode <= 0) {
+		LM_ERR("can't set facility for module=%.*s; enable mod_hash_size and mod_facility_mode config parameters!\n",
+			mod_str.len, mod_str.s);
+		return init_mi_tree(500, MI_INTERNAL_ERR_S, MI_INTERNAL_ERR_LEN);
+	} else if (dbg_set_mod_debug_facility(mod_str.s, mod_str.len, &fl) < 0) {
+		LM_ERR("failed set facility for module=%.*s\n", mod_str.len, mod_str.s);
+		return init_mi_tree(500, MI_INTERNAL_ERR_S, MI_INTERNAL_ERR_LEN);
+	} else {
+		LM_DBG("module=%.*s facility_str=%.*s facility_int=%d\n",
+			mod_str.len, mod_str.s, facility_str.len, facility_str.s, fl);
+	}
+
+	return init_mi_tree(200, MI_OK_S, MI_OK_LEN);
+}
+
+static struct mi_root* mi_get_dbg_mod_level(struct mi_root *cmd_tree, void *param) {
+	struct mi_node *node, *crt_node;
+	struct mi_root *root = NULL;
+	struct mi_attr *attr;
+	int l;
+	str mod_str, level_str;
+	str level_attr = {"level", strlen("level")};
+
+	/* get first param */
+	node = cmd_tree->node.kids;
+	if (node == NULL) {
+		return init_mi_tree(400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
+	}
+
+	if (node->value.s == NULL || node->value.len == 0) {
+		return init_mi_tree(400, MI_BAD_PARM_S, MI_BAD_PARM_LEN);
+	}
+
+	/* get module str */
+	mod_str = node->value;
+
+	/* no further params expected */
+	node = node->next;
+	if (node != NULL) {
+		return init_mi_tree(400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
+	}
+
+	/* get module log level */
+	l = get_debug_level(mod_str.s, mod_str.len);
+	level_str.s = sint2str(l, &level_str.len);
+	LM_DBG("module=%.*s level_str=%.*s level_int=%d\n",
+		mod_str.len, mod_str.s, level_str.len, level_str.s, l);
+
+	/* return module log level */
+	root = init_mi_tree(200, MI_OK_S, MI_OK_LEN);
+	if (!root) {
+		LM_ERR("the MI tree cannot be initialized!\n");
+		goto error;
+	}
+	node = &root->node;
+
+	if (!(crt_node = add_mi_node_child(node, 0, mod_str.s, mod_str.len, 0, 0)) ) {
+		LM_ERR("cannot add the child node to the tree\n");
+		goto error;
+	}
+
+	if ((attr = add_mi_attr(crt_node, MI_DUP_VALUE,
+	    level_attr.s, level_attr.len,
+	    level_str.s, level_str.len)) == 0) {
+		LM_ERR("cannot add attributes to the node\n");
+		goto error;
+	}
+
+	return root;
+
+error:
+	if (root) {
+		free_mi_tree(root);
+	}
+
+	return NULL;
+}
+
+static struct mi_root* mi_get_dbg_mod_facility(struct mi_root *cmd_tree, void *param) {
+	struct mi_node *node, *crt_node;
+	struct mi_root *root = NULL;
+	struct mi_attr *attr;
+	int fl;
+	str mod_str, facility_str;
+	str facility_attr = {"facility", strlen("facility")};
+
+	/* get first param */
+	node = cmd_tree->node.kids;
+	if (node == NULL) {
+		return init_mi_tree(400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
+	}
+
+	if (node->value.s == NULL || node->value.len == 0) {
+		return init_mi_tree(400, MI_BAD_PARM_S, MI_BAD_PARM_LEN);
+	}
+
+	/* get module str */
+	mod_str = node->value;
+
+	/* no further params expected */
+	node = node->next;
+	if (node != NULL) {
+		return init_mi_tree(400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
+	}
+
+	/* get module log facility */
+	fl = get_debug_facility(mod_str.s, mod_str.len);
+	facility_str.s = facility2str(fl, &facility_str.len);
+	LM_DBG("module=%.*s facility_str=%.*s facility_int=%d\n",
+		mod_str.len, mod_str.s, facility_str.len, facility_str.s, fl);
+
+	/* return module log facility */
+	root = init_mi_tree(200, MI_OK_S, MI_OK_LEN);
+	if (!root) {
+		LM_ERR("the MI tree cannot be initialized!\n");
+		goto error;
+	}
+	node = &root->node;
+
+	if (!(crt_node = add_mi_node_child(node, 0, mod_str.s, mod_str.len, 0, 0)) ) {
+		LM_ERR("cannot add the child node to the tree\n");
+		goto error;
+	}
+
+	if ((attr = add_mi_attr(crt_node, MI_DUP_VALUE,
+	    facility_attr.s, facility_attr.len,
+	    facility_str.s, facility_str.len)) == 0) {
+		LM_ERR("cannot add attributes to the node\n");
+		goto error;
+	}
+
+	return root;
+
+error:
+	if (root) {
+		free_mi_tree(root);
+	}
+
+	return NULL;
+}
+
 /**
  * init module function
  */
 static int mod_init(void)
 {
 	int fl;
+
+	if (register_mi_mod(exports.name, mi_cmds) != 0)
+	{
+		LM_ERR("failed to register MI commands\n");
+		return -1;
+	}
+
 	if (_dbg_cfgtrace_facility_str!=NULL)
 	{
 		fl = str2facility(_dbg_cfgtrace_facility_str);
