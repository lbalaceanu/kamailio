#! /bin/sh /usr/share/dpatch/dpatch-run
## sipcapture_mtNEW.dpatch by  <Pawel Kuzak <pawel.kuzak@schlund.de>>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/sipcapture/sipcapture.c ui-siprouter/modules/sipcapture/sipcapture.c
--- ui-siprouter~/modules/sipcapture/sipcapture.c	2014-06-02 10:46:30.000000000 +0200
+++ ui-siprouter/modules/sipcapture/sipcapture.c	2014-06-02 10:47:54.474964030 +0200
@@ -198,6 +198,7 @@
 int promisc_on = 0;
 int bpf_on = 0;
 int hep_capture_on   = 0;
+int parse_bad_msgs = 0;
 int hep_offset = 0;
 str raw_socket_listen = { 0, 0 };
 str raw_interface = { 0, 0 };
@@ -225,8 +226,6 @@
 
 unsigned int no_tables = 0;
 
-
-
 enum e_mt_mode mtmode = mode_random ;
 enum hash_source source = hs_error;
 
@@ -234,6 +233,10 @@
 
 struct hep_timehdr* heptime;
 
+unsigned long int retry_failed_cnt = 0;
+int disable_retry = 0;
+time_t retry_failed_time = 0;
+
 
 /*! \brief
  * Exported functions
@@ -305,6 +308,7 @@
         {"promiscious_on",  		INT_PARAM, &promisc_on   },		
         {"raw_moni_bpf_on",  		INT_PARAM, &bpf_on   },		
         {"callid_aleg_header",          STR_PARAM, &callid_aleg_header.s},
+        {"capture_bad_msgs",   INT_PARAM, &parse_bad_msgs },
         {"capture_mode",		STR_PARAM|USE_FUNC_PARAM, (void *)capture_mode_param},
 		{0, 0, 0}
 };
@@ -354,7 +358,68 @@
 	child_init  /*!< child initialization function */
 };
 
+/*
+ * Find the first occurrence of find in s, where the search is limited to the
+ * first slen characters of s.
+ */
+char *strnstr(s, find, slen)
+   const char *s;
+   const char *find;
+   size_t slen;
+{
+   char c, sc;
+   size_t len;
+
+   if ((c = *find++) != '\0') {
+       len = strlen(find);
+       do {
+           do {
+               if ((sc = *s++) == '\0' || slen-- < 1)
+                   return (NULL);
+           } while (sc != c);
+           if (len > slen)
+               return (NULL);
+       } while (strncmp(s, find, len) != 0);
+       s--;
+   }
+   return ((char *)s);
+}
+
+int force_capture_callid (struct sip_msg *msg, struct _sipcapture_object *sco){
+
+   char *tmp = NULL;
+   char *end;
+   struct hdr_field *hdr = NULL;
 
+   tmp= msg->unparsed;
+   end = msg->buf+msg->len;
+   tmp = strnstr(tmp, "Call-ID", (int)(end - tmp) );
+   if (tmp == NULL)
+   {
+       LM_DBG("Bad msg callid not found\n");
+       EMPTY_STR(sco->callid);
+   }
+   else {
+       hdr=pkg_malloc(sizeof(struct hdr_field));
+       if (unlikely(hdr==0)){
+           LOG(L_ERR, "ERROR:parse_headers: memory allocation error\n");
+           return -1;
+       }
+       memset(hdr,0, sizeof(struct hdr_field));
+       hdr->type=HDR_ERROR_T;
+       get_hdr_field(tmp ,end, hdr);
+       if (hdr->type != HDR_CALLID_T )
+       {
+           LM_DBG("Bad msg callid error\n");
+           pkg_free(hdr);
+           EMPTY_STR(sco->callid);
+       }
+       else {
+           sco->callid = hdr->body;
+       }
+   }
+   return 0;
+}
 
 /* returns number of tables if successful
  * <0 if failed
@@ -1106,10 +1171,13 @@
 {
         /* We need parse all headers */
         if (parse_headers(msg, HDR_CALLID_F|HDR_EOH_F, 0) != 0) {
-                LM_ERR("cannot parse headers\n");
-                return 0;
+            LM_DBG("cannot parse headers\n");
+            if (parse_bad_msgs == 0){
+                return -1;
+            } else {
+                LM_DBG("trying to capture bad message\n");
+            }
         }
-
         return 0;
 }
 
@@ -1120,6 +1188,9 @@
 
 	str tmp;
 	int ii = 0;
+	int times = 0;
+	int ret = 0;
+
 	str *table = NULL;
 	_capture_mode_data_t *c = NULL;
 
@@ -1367,17 +1438,69 @@
 	c->db_funcs.use_table(c->db_con, table);
 
 	LM_DBG("storing info...\n");
-	
+
+try_again:
 	if(db_insert_mode==1 && c->db_funcs.insert_delayed!=NULL) {
-                if (c->db_funcs.insert_delayed(c->db_con, db_keys, db_vals, NR_KEYS) < 0) {
-                	LM_ERR("failed to insert delayed into database\n");
-                        goto error;
+	    if ((ret  = c->db_funcs.insert_delayed(c->db_con, db_keys, db_vals, NR_KEYS)) < 0) {
+	        if (ret == -2 && times == 0){
+	            times ++;
+	            LM_DBG("failed to insert into database(first attempt)\n");
+	            if (!disable_retry)
+	                goto try_again;
+            } else if (ret == -2 && times == 1 ){//retry failed
+                retry_failed_cnt++;
+                if (retry_failed_cnt == 1){//first failed retry
+                    retry_failed_time = time(NULL);
                 }
-        } else if (c->db_funcs.insert(c->db_con, db_keys, db_vals, NR_KEYS) < 0) {
-		LM_ERR("failed to insert into database\n");
-                goto error;               
-	}
-	
+                if (retry_failed_cnt > 100){
+                    if  (time(NULL) - retry_failed_time < 60){
+                        disable_retry  = 1;
+                    }
+                    retry_failed_cnt= 0;
+                    retry_failed_time = 0;
+                }
+                LM_ERR("failed to insert into database(second attempt)\n");
+                goto error;
+            }
+        } else {//query successful
+            if (retry_failed_time){
+                retry_failed_cnt= 0;
+                retry_failed_time = 0;
+            }
+            if (disable_retry){
+                disable_retry = 0;
+            }
+        }
+    } else if ((ret = c->db_funcs.insert(c->db_con, db_keys, db_vals, NR_KEYS)) < 0) {
+        if (ret == -2 && times == 0){
+            times ++;
+            LM_DBG("failed to insert into database(first attempt)\n");
+            if (!disable_retry) //retry
+                goto try_again;
+        } else if (ret == -2 && times == 1 ){//retry failed
+            retry_failed_cnt++;
+            if (retry_failed_cnt == 1){//first failed retry
+                retry_failed_time = time(NULL);
+            }
+            if (retry_failed_cnt > 100){
+                if  (time(NULL) - retry_failed_time < 60){
+                    disable_retry  = 1;
+                }
+                retry_failed_cnt= 0;
+                retry_failed_time = 0;
+            }
+            LM_ERR("failed to insert into database(second attempt)\n");
+            goto error;
+        }
+    } else {//query successful
+        if (retry_failed_time){
+            retry_failed_cnt= 0;
+            retry_failed_time = 0;
+        }
+        if (disable_retry){
+            disable_retry = 0;
+        }
+    }
 	
 #ifdef STATISTICS
 	update_stat(sco->stat, 1);
@@ -1420,7 +1543,12 @@
 		return -1;
 	}
 	
-	if(sip_capture_prepare(msg)<0) return -1;
+	if(sip_capture_prepare(msg)<0) {
+	    if (parse_bad_msgs == 0) {
+	        LM_ERR("sip prepare failed\n");
+	        return -1;
+	    }
+	}
 
 	if(msg->first_line.type == SIP_REQUEST) {
 
@@ -1460,46 +1588,70 @@
 	
 	/* Parse FROM */
         if(msg->from) {
-
-              if (parse_from_header(msg)!=0){
-                   LOG(L_ERR, "ERROR: eval_elem: bad or missing" " From: header\n");
-                   return -1;
-              }
-
-              if (parse_uri(get_from(msg)->uri.s, get_from(msg)->uri.len, &from)<0){
-                   LOG(L_ERR, "ERROR: do_action: bad from dropping"" packet\n");
-                   return -1;
-              }
-              
-              sco.from_user = from.user;
-              sco.from_tag = get_from(msg)->tag_value;              
-        }
-        else {
-		EMPTY_STR(sco.from_user);
-		EMPTY_STR(sco.from_tag);
+            if (parse_from_header(msg)!=0){
+                if (!parse_bad_msgs){
+                    LOG(L_ERR, "ERROR: eval_elem: bad or missing" " From: header\n");
+                    return -1;
+                } else {
+                    LM_DBG("bad From header\n");
+                    memset(&from, 0 ,sizeof(from));
+                }
+            } else {
+                if (parse_uri(get_from(msg)->uri.s, get_from(msg)->uri.len, &from)<0){
+                    if (!parse_bad_msgs){
+                        LOG(L_ERR, "ERROR: do_action: bad from dropping"" packet\n");
+                        return -1;
+                    } else {
+                        LM_DBG("bad From URI\n");
+                        memset(&from, 0 ,sizeof(from));
+                    }
+                }
+            }
+            sco.from_user = from.user;
+            if(get_from(msg) && get_from(msg)->tag_value.len){
+                sco.from_tag = get_from(msg)->tag_value;
+            } else {
+                EMPTY_STR(sco.from_tag);
+            }
+        } else {
+    		EMPTY_STR(sco.from_user);
+    		EMPTY_STR(sco.from_tag);
         }
 
         /* Parse TO */
         if(msg->to) {
-
-              if (parse_uri(get_to(msg)->uri.s, get_to(msg)->uri.len, &to)<0){
+            if (parse_uri(get_to(msg)->uri.s, get_to(msg)->uri.len, &to)<0){
+                if (!parse_bad_msgs){
                     LOG(L_ERR, "ERROR: do_action: bad to dropping"" packet\n");
                     return -1;
-              }
-        
-              sco.to_user = to.user;
-              if(get_to(msg)->tag_value.len) 
-              		sco.to_tag = get_to(msg)->tag_value;              
-              else { EMPTY_STR(sco.to_tag); }
-        }
-        else {        
+                } else {
+                    LM_DBG("bad To URI\n");
+                    memset(&to, 0, sizeof(to));
+                }
+            }
+            sco.to_user = to.user;
+            if(get_to(msg)->tag_value.len) {
+            	sco.to_tag = get_to(msg)->tag_value;              
+            }else { 
+                EMPTY_STR(sco.to_tag); 
+            }
+        } else {        
         	EMPTY_STR(sco.to_user);
         	EMPTY_STR(sco.to_tag);
         }
 
 	/* Call-id */
-	if(msg->callid) sco.callid = msg->callid->body;
-	else { EMPTY_STR(sco.callid); }
+	if(msg->callid) {
+	    sco.callid = msg->callid->body;
+	} else { 
+	    if( parse_bad_msgs ){
+	        if (force_capture_callid(msg, &sco) < 0){
+	            return -1;
+	        }
+	    } else {
+	        EMPTY_STR(sco.callid); 
+	    }
+	}
 
 	/* P-Asserted-Id */
 	if((parse_pai_header(msg) == 0) && (msg->pai) && (msg->pai->parsed)) {
@@ -1537,32 +1689,39 @@
         else { EMPTY_STR(sco.auth_user);}
 
 	if(msg->contact) {
-
-              if (msg->contact->parsed == 0 && parse_contact(msg->contact) == -1) {
-                     LOG(L_ERR,"assemble_msg: error while parsing <Contact:> header\n");
-                     return -1;
-              }
-
-              cb = (contact_body_t*)msg->contact->parsed;
-
-              if(cb) {
-            	    if (cb->contacts) {
-			if(parse_uri( cb->contacts->uri.s, cb->contacts->uri.len, &contact)<0){
-                		LOG(L_ERR, "ERROR: do_action: bad contact dropping"" packet\n");
-                 	    	return -1;
-                  	}
-              	    } else {
-              		if(cb->star){ /* in the case Contact is "*" */
-			    memset(&contact, 0, sizeof(contact));
-			    contact.user.s =  star_contact.s;
-			    contact.user.len = star_contact.len;
-			} else {
-			    LOG(L_NOTICE,"Invalid contact\n");
-			    memset(&contact, 0, sizeof(contact));
-			}
-		    }
-	    }
+	    if (msg->contact->parsed == 0 && parse_contact(msg->contact) < 0) {
+	        if (!parse_bad_msgs){
+	            LOG(L_ERR,"assemble_msg: error while parsing <Contact:> header\n");
+	            return -1;
+	        } else {
+	            LM_DBG("error while parsing <Contact:> header\n");
+	        }
+        } else {
+            cb = (contact_body_t*)msg->contact->parsed;
+            if(cb) {
+                if (cb->contacts) {
+                    if(parse_uri( cb->contacts->uri.s, cb->contacts->uri.len, &contact)<0){
+                        if (!parse_bad_msgs){
+                            LOG(L_ERR, "ERROR: do_action: bad contact dropping"" packet\n");
+                            return -1;
+                        } else {
+                            LM_DBG("bad contact URI\n");
+                            memset(&contact, 0, sizeof(contact));
+                        }
+                    }
+                }  else {
+                    if(cb->star){ /* in the case Contact is "*" */
+                        memset(&contact, 0, sizeof(contact));
+                        contact.user.s =  star_contact.s;
+                        contact.user.len = star_contact.len;
+                    } else {
+                        LOG(L_NOTICE,"Invalid contact\n");
+                        memset(&contact, 0, sizeof(contact));
+                    }
+                }
+            }
         }
+    }
 
 	/* callid_aleg - default is X-CID but configurable via modul params */
         if((tmphdr[0] = get_hdr_by_name(msg, callid_aleg_header.s, callid_aleg_header.len)) != NULL) {	
@@ -1571,7 +1730,9 @@
 	else { EMPTY_STR(sco.callid_aleg);}
 		
 	/* VIA 1 */
-	sco.via_1 = msg->h_via1->body;
+	if (msg->h_via1){
+	    sco.via_1 = msg->h_via1->body;
+	}
 
 	/* Via branch */
 	if(msg->via1->branch) sco.via_1_branch = msg->via1->branch->value;
