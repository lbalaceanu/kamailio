#! /bin/sh /usr/share/dpatch/dpatch-run
## rtpengine_hash_table_improved_locks.dpatch by  <miti@dell>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/rtpengine_hash.c ui-siprouter/modules/rtpengine/rtpengine_hash.c
--- ui-siprouter~/modules/rtpengine/rtpengine_hash.c	2016-01-22 13:44:46.000000000 +0200
+++ ui-siprouter/modules/rtpengine/rtpengine_hash.c	2016-01-22 13:45:22.613979902 +0200
@@ -6,9 +6,10 @@
 #include "../../locking.h"
 #include "../../timer.h"
 
-static gen_lock_t *rtpengine_hash_lock;
+static void rtpengine_hash_table_free_row_lock(gen_lock_t *row_lock);
+
+
 static struct rtpengine_hash_table *rtpengine_hash_table;
-static int hash_table_size;
 
 /* from sipwise rtpengine */
 static int str_cmp_str(const str a, const str b) {
@@ -37,12 +38,13 @@
 		it.len--;
 	}
 
-	return ret % hash_table_size;
+	return ret % rtpengine_hash_table->size;
 }
 
 /* rtpengine hash API */
 int rtpengine_hash_table_init(int size) {
 	int i;
+	int hash_table_size;
 
 	// init hash table size
 	if (size < 1) {
@@ -59,38 +61,66 @@
 		return 0;
 	}
 	memset(rtpengine_hash_table, 0, sizeof(struct rtpengine_hash_table));
+	rtpengine_hash_table->size = hash_table_size;
 
-	// init hashtable entry_list
-	rtpengine_hash_table->entry_list = shm_malloc(hash_table_size * sizeof(struct rtpengine_hash_entry));
-	if (!rtpengine_hash_table->entry_list) {
-		LM_ERR("no shm left to create rtpengine_hash_table->entry_list\n");
+	// init hashtable row_locks
+	rtpengine_hash_table->row_locks = shm_malloc(hash_table_size * sizeof(gen_lock_t*));
+	if (!rtpengine_hash_table->row_locks) {
+		LM_ERR("no shm left to create rtpengine_hash_table->row_locks\n");
 		rtpengine_hash_table_destroy();
 		return 0;
 	}
-	memset(rtpengine_hash_table->entry_list, 0, hash_table_size * sizeof(struct rtpengine_hash_entry));
+	memset(rtpengine_hash_table->row_locks, 0, hash_table_size * sizeof(gen_lock_t*));
 
-	// init hashtable entry_list[i] (head never filled); destroy table on error
+	// init hashtable row_entry_list
+	rtpengine_hash_table->row_entry_list = shm_malloc(rtpengine_hash_table->size * sizeof(struct rtpengine_hash_entry*));
+	if (!rtpengine_hash_table->row_entry_list) {
+		LM_ERR("no shm left to create rtpengine_hash_table->row_entry_list\n");
+		rtpengine_hash_table_destroy();
+		return 0;
+	}
+	memset(rtpengine_hash_table->row_entry_list, 0, rtpengine_hash_table->size * sizeof(struct rtpengine_hash_entry*));
+
+	// init hashtable row_totals
+	rtpengine_hash_table->row_totals = shm_malloc(hash_table_size * sizeof(unsigned int));
+	if (!rtpengine_hash_table->row_totals) {
+		LM_ERR("no shm left to create rtpengine_hash_table->row_totals\n");
+		rtpengine_hash_table_destroy();
+		return 0;
+	}
+	memset(rtpengine_hash_table->row_totals, 0, hash_table_size * sizeof(unsigned int));
+
+	// init hashtable  row_locks[i], row_entry_list[i] and row_totals[i]
 	for (i = 0; i < hash_table_size; i++) {
-		rtpengine_hash_table->entry_list[i] = shm_malloc(sizeof(struct rtpengine_hash_entry));
-		if (!rtpengine_hash_table->entry_list[i]) {
-			LM_ERR("no shm left to create rtpengine_hash_table->entry_list[%d]\n", i);
+		// alloc hashtable row_locks[i]
+		rtpengine_hash_table->row_locks[i] = lock_alloc();
+		if (!rtpengine_hash_table->row_locks[i]) {
+			LM_ERR("no shm left to create rtpengine_hash_table->row_locks[%d]\n", i);
 			rtpengine_hash_table_destroy();
 			return 0;
 		}
-		memset(rtpengine_hash_table->entry_list[i], 0, sizeof(struct rtpengine_hash_entry));
 
-		// never expire the head of the hashtable index lists
-		rtpengine_hash_table->entry_list[i]->tout = -1;
-		rtpengine_hash_table->entry_list[i]->next = NULL;
-		rtpengine_hash_table->total = 0;
-	}
+		// init hashtable row_locks[i]
+		if (!lock_init(rtpengine_hash_table->row_locks[i])) {
+			LM_ERR("fail to init rtpengine_hash_table->row_locks[%d]\n", i);
+			rtpengine_hash_table_destroy();
+			return 0;
+		}
 
-	// init lock
-	rtpengine_hash_lock = lock_alloc();
-	if (!rtpengine_hash_lock) {
-		LM_ERR("no shm left to init rtpengine_hash_table lock");
-		rtpengine_hash_table_destroy();
-		return 0;
+		// init hashtable row_entry_list[i]
+		rtpengine_hash_table->row_entry_list[i] = shm_malloc(sizeof(struct rtpengine_hash_entry));
+		if (!rtpengine_hash_table->row_entry_list[i]) {
+			LM_ERR("no shm left to create rtpengine_hash_table->row_entry_list[%d]\n", i);
+			rtpengine_hash_table_destroy();
+			return 0;
+		}
+		memset(rtpengine_hash_table->row_entry_list[i], 0, sizeof(struct rtpengine_hash_entry));
+
+		rtpengine_hash_table->row_entry_list[i]->tout = -1;
+		rtpengine_hash_table->row_entry_list[i]->next = NULL;
+
+		// init hashtable row_totals[i]
+		rtpengine_hash_table->row_totals[i] = 0;
 	}
 
 	return 1;
@@ -101,41 +131,77 @@
 
 	// check rtpengine hashtable
 	if (!rtpengine_hash_table) {
-		LM_ERR("NULL rtpengine_hash_table");
-		return 0;
+		LM_ERR("NULL rtpengine_hash_table\n");
+		return 1;
 	}
 
-	// check rtpengine hashtable->entry_list
-	if (!rtpengine_hash_table->entry_list) {
-		LM_ERR("NULL rtpengine_hash_table->entry_list");
+	// check rtpengine hashtable->row_locks
+	if (!rtpengine_hash_table->row_locks) {
+		LM_ERR("NULL rtpengine_hash_table->row_locks\n");
 		shm_free(rtpengine_hash_table);
 		rtpengine_hash_table = NULL;
-		return 0;
+		return 1;
 	}
 
-	lock_get(rtpengine_hash_lock);
+	// destroy hashtable content
+	for (i = 0; i < rtpengine_hash_table->size; i++) {
+		// lock
+		if (!rtpengine_hash_table->row_locks[i]) {
+			LM_ERR("NULL rtpengine_hash_table->row_locks[%d]\n", i);
+			continue;
+		} else {
+			lock_get(rtpengine_hash_table->row_locks[i]);
+		}
 
-	// destroy hashtable entry_list[i]
-	for (i = 0; i < hash_table_size; i++) {
-		rtpengine_hash_table_free_entry_list(rtpengine_hash_table->entry_list[i]);
+		// check rtpengine hashtable->row_entry_list
+		if (!rtpengine_hash_table->row_entry_list) {
+			LM_ERR("NULL rtpengine_hash_table->row_entry_list\n");
+		} else {
+			// destroy hashtable row_entry_list[i]
+			rtpengine_hash_table_free_row_entry_list(rtpengine_hash_table->row_entry_list[i]);
+			rtpengine_hash_table->row_entry_list[i] = NULL;
+		}
+
+		// unlock
+		lock_release(rtpengine_hash_table->row_locks[i]);
+
+		// destroy hashtable row_locks[i]
+		rtpengine_hash_table_free_row_lock(rtpengine_hash_table->row_locks[i]);
+		rtpengine_hash_table->row_locks[i] = NULL;
 	}
 
-	// destroy hashtable entry_list
-	shm_free(rtpengine_hash_table->entry_list);
-	rtpengine_hash_table->entry_list = NULL;
+	// destroy hashtable row_entry_list
+	if (!rtpengine_hash_table->row_entry_list) {
+		LM_ERR("NULL rtpengine_hash_table->row_entry_list\n");
+	} else {
+		shm_free(rtpengine_hash_table->row_entry_list);
+		rtpengine_hash_table->row_entry_list = NULL;
+	}
 
-	// destroy hashtable
-	shm_free(rtpengine_hash_table);
-	rtpengine_hash_table = NULL;
+	// destroy hashtable row_totals
+	if (!rtpengine_hash_table->row_totals) {
+		LM_ERR("NULL rtpengine_hash_table->row_totals\n");
+	} else {
+		shm_free(rtpengine_hash_table->row_totals);
+		rtpengine_hash_table->row_totals = NULL;
+	}
 
-	lock_release(rtpengine_hash_lock);
+	// destroy hashtable row_locks
+	if (!rtpengine_hash_table->row_locks) {
+		// should not be the case; just for code symmetry
+		LM_ERR("NULL rtpengine_hash_table->row_locks\n");
+	} else {
+		shm_free(rtpengine_hash_table->row_locks);
+		rtpengine_hash_table->row_locks = NULL;
+	}
 
-	// destroy lock
-	if (!rtpengine_hash_lock) {
-		LM_ERR("NULL rtpengine_hash_lock");
+	// destroy hashtable
+	if (!rtpengine_hash_table) {
+		// should not be the case; just for code symmetry
+		LM_ERR("NULL rtpengine_hash_table\n");
 	} else {
-		lock_dealloc(rtpengine_hash_lock);
-		rtpengine_hash_lock = NULL;
+		shm_free(rtpengine_hash_table);
+		rtpengine_hash_table = NULL;
 	}
 
 	return 1;
@@ -146,32 +212,32 @@
 	struct rtpengine_hash_entry *new_entry = (struct rtpengine_hash_entry *) value;
 	unsigned int hash_index;
 
-	// check rtpengine hashtable
-	if (!rtpengine_hash_table) {
-		LM_ERR("NULL rtpengine_hash_table");
-		return 0;
-	}
-
-	// check rtpengine hashtable->entry_list
-	if (!rtpengine_hash_table->entry_list) {
-		LM_ERR("NULL rtpengine_hash_table->entry_list");
+	// sanity checks
+	if (!rtpengine_hash_table_sanity_checks()) {
+		LM_ERR("sanity checks failed\n");
 		return 0;
 	}
 
 	// get entry list
 	hash_index = str_hash(callid);
-	entry = rtpengine_hash_table->entry_list[hash_index];
+	entry = rtpengine_hash_table->row_entry_list[hash_index];
 	last_entry = entry;
 
 	// lock
-	lock_get(rtpengine_hash_lock);
+	if (rtpengine_hash_table->row_locks[hash_index]) {
+		lock_get(rtpengine_hash_table->row_locks[hash_index]);
+	} else {
+		LM_ERR("NULL rtpengine_hash_table->row_locks[%d]\n", hash_index);
+		return 0;
+	}
+
 	while (entry) {
 		// if found, don't add new entry
 		if (str_equal(entry->callid, new_entry->callid) &&
 		    str_equal(entry->viabranch, new_entry->viabranch)) {
 			// unlock
-			lock_release(rtpengine_hash_lock);
-			LM_NOTICE("callid=%.*s, viabranch=%.*s already in hashtable, ignore new value",
+			lock_release(rtpengine_hash_table->row_locks[hash_index]);
+			LM_NOTICE("callid=%.*s, viabranch=%.*s already in hashtable, ignore new value\n",
 				entry->callid.len, entry->callid.s,
 				entry->viabranch.len, entry->viabranch.s);
 			return 0;
@@ -189,7 +255,7 @@
 			entry = last_entry;
 
 			// update total
-			rtpengine_hash_table->total--;
+			rtpengine_hash_table->row_totals[hash_index]--;
 		}
 
 		// next entry in the list
@@ -200,10 +266,10 @@
 	last_entry->next = new_entry;
 
 	// update total
-	rtpengine_hash_table->total++;
+	rtpengine_hash_table->row_totals[hash_index]++;
 
 	// unlock
-	lock_release(rtpengine_hash_lock);
+	lock_release(rtpengine_hash_table->row_locks[hash_index]);
 
 	return 1;
 }
@@ -212,25 +278,25 @@
 	struct rtpengine_hash_entry *entry, *last_entry;
 	unsigned int hash_index;
 
-	// check rtpengine hashtable
-	if (!rtpengine_hash_table) {
-		LM_ERR("NULL rtpengine_hash_table");
-		return 0;
-	}
-
-	// check rtpengine hashtable->entry_list
-	if (!rtpengine_hash_table->entry_list) {
-		LM_ERR("NULL rtpengine_hash_table->entry_list");
+	// sanity checks
+	if (!rtpengine_hash_table_sanity_checks()) {
+		LM_ERR("sanity checks failed\n");
 		return 0;
 	}
 
 	// get first entry from entry list; jump over unused list head
 	hash_index = str_hash(callid);
-	entry = rtpengine_hash_table->entry_list[hash_index];
+	entry = rtpengine_hash_table->row_entry_list[hash_index];
 	last_entry = entry;
 
 	// lock
-	lock_get(rtpengine_hash_lock);
+	if (rtpengine_hash_table->row_locks[hash_index]) {
+		lock_get(rtpengine_hash_table->row_locks[hash_index]);
+	} else {
+		LM_ERR("NULL rtpengine_hash_table->row_locks[%d]\n", hash_index);
+		return 0;
+	}
+
 	while (entry) {
 		// if callid found, delete entry
 		if (str_equal(entry->callid, callid) &&
@@ -240,10 +306,10 @@
 			rtpengine_hash_table_free_entry(entry);
 
 			// update total
-			rtpengine_hash_table->total--;
+			rtpengine_hash_table->row_totals[hash_index]--;
 
 			// unlock
-			lock_release(rtpengine_hash_lock);
+			lock_release(rtpengine_hash_table->row_locks[hash_index]);
 
 			return 1;
 		}
@@ -260,7 +326,7 @@
 			entry = last_entry;
 
 			// update total
-			rtpengine_hash_table->total--;
+			rtpengine_hash_table->row_totals[hash_index]--;
 		}
 
 		last_entry = entry;
@@ -268,7 +334,7 @@
 	}
 
 	// unlock
-	lock_release(rtpengine_hash_lock);
+	lock_release(rtpengine_hash_table->row_locks[hash_index]);
 
 	return 0;
 }
@@ -278,25 +344,25 @@
 	unsigned int hash_index;
 	struct rtpp_node *node;
 
-	// check rtpengine hashtable
-	if (!rtpengine_hash_table) {
-		LM_ERR("NULL rtpengine_hash_table");
-		return NULL;
-	}
-
-	// check rtpengine hashtable->entry_list
-	if (!rtpengine_hash_table->entry_list) {
-		LM_ERR("NULL rtpengine_hash_table->entry_list");
-		return NULL;
+	// sanity checks
+	if (!rtpengine_hash_table_sanity_checks()) {
+		LM_ERR("sanity checks failed\n");
+		return 0;
 	}
 
 	// get first entry from entry list; jump over unused list head
 	hash_index = str_hash(callid);
-	entry = rtpengine_hash_table->entry_list[hash_index];
+	entry = rtpengine_hash_table->row_entry_list[hash_index];
 	last_entry = entry;
 
 	// lock
-	lock_get(rtpengine_hash_lock);
+	if (rtpengine_hash_table->row_locks[hash_index]) {
+		lock_get(rtpengine_hash_table->row_locks[hash_index]);
+	} else {
+		LM_ERR("NULL rtpengine_hash_table->row_locks[%d]\n", hash_index);
+		return 0;
+	}
+
 	while (entry) {
 		// if callid found, return entry
 		if (str_equal(entry->callid, callid) &&
@@ -304,7 +370,7 @@
 			node = entry->node;
 
 			// unlock
-			lock_release(rtpengine_hash_lock);
+			lock_release(rtpengine_hash_table->row_locks[hash_index]);
 
 			return node;
 		}
@@ -321,7 +387,7 @@
 			entry = last_entry;
 
 			// update total
-			rtpengine_hash_table->total--;
+			rtpengine_hash_table->row_totals[hash_index]--;
 		}
 
 		last_entry = entry;
@@ -329,7 +395,7 @@
 	}
 
 	// unlock
-	lock_release(rtpengine_hash_lock);
+	lock_release(rtpengine_hash_table->row_locks[hash_index]);
 
 	return NULL;
 }
@@ -339,24 +405,23 @@
 	int i;
 	struct rtpengine_hash_entry *entry, *last_entry;
 
-	// check rtpengine hashtable
-	if (!rtpengine_hash_table) {
-		LM_ERR("NULL rtpengine_hash_table");
-		return ;
-	}
-
-	// check rtpengine hashtable->entry_list
-	if (!rtpengine_hash_table->entry_list) {
-		LM_ERR("NULL rtpengine_hash_table->entry_list");
+	// sanity checks
+	if (!rtpengine_hash_table_sanity_checks()) {
+		LM_ERR("sanity checks failed\n");
 		return ;
 	}
 
-	// lock
-	lock_get(rtpengine_hash_lock);
-
 	// print hashtable
-	for (i = 0; i < hash_table_size; i++) {
-		entry = rtpengine_hash_table->entry_list[i];
+	for (i = 0; i < rtpengine_hash_table->size; i++) {
+		// lock
+		if (rtpengine_hash_table->row_locks[i]) {
+			lock_get(rtpengine_hash_table->row_locks[i]);
+		} else {
+			LM_ERR("NULL rtpengine_hash_table->row_locks[%d]\n", i);
+			return ;
+		}
+
+		entry = rtpengine_hash_table->row_entry_list[i];
 		last_entry = entry;
 
 		while (entry) {
@@ -372,7 +437,7 @@
 				entry = last_entry;
 
 				// update total
-				rtpengine_hash_table->total--;
+				rtpengine_hash_table->row_totals[i]--;
 			} else {
 				LM_DBG("hash_index=%d callid=%.*s tout=%u\n",
 					i, entry->callid.len, entry->callid.s, entry->tout - get_ticks());
@@ -381,25 +446,33 @@
 			last_entry = entry;
 			entry = entry->next;
 		}
+
+		// unlock
+		lock_release(rtpengine_hash_table->row_locks[i]);
 	}
 
-	// unlock
-	lock_release(rtpengine_hash_lock);
 }
 
 unsigned int rtpengine_hash_table_total() {
+	int i;
+	unsigned int total = 0;
 
-	// check rtpengine hashtable
-	if (!rtpengine_hash_table) {
-		LM_ERR("NULL rtpengine_hash_table");
+	// sanity checks
+	if (!rtpengine_hash_table_sanity_checks()) {
+		LM_ERR("sanity checks failed\n");
 		return 0;
 	}
 
-	return rtpengine_hash_table->total;
+	for (i = 0; i < rtpengine_hash_table->size; i++) {
+		total += rtpengine_hash_table->row_totals[i];
+	}
+
+	return total;
 }
 
 void rtpengine_hash_table_free_entry(struct rtpengine_hash_entry *entry) {
 	if (!entry) {
+		LM_ERR("try to free a NULL entry\n");
 		return ;
 	}
 
@@ -419,19 +492,61 @@
 	return ;
 }
 
-void rtpengine_hash_table_free_entry_list(struct rtpengine_hash_entry *entry_list) {
+void rtpengine_hash_table_free_row_entry_list(struct rtpengine_hash_entry *row_entry_list) {
 	struct rtpengine_hash_entry *entry, *last_entry;
 
-	if (!entry_list) {
+	if (!row_entry_list) {
+		LM_ERR("try to free a NULL row_entry_list\n");
 		return ;
 	}
 
-	entry = entry_list;
+	entry = row_entry_list;
 	while (entry) {
 		last_entry = entry;
 		entry = entry->next;
 		rtpengine_hash_table_free_entry(last_entry);
+		last_entry = NULL;
+	}
+
+	return ;
+}
+
+static void rtpengine_hash_table_free_row_lock(gen_lock_t *row_lock) {
+	if (!row_lock) {
+		LM_ERR("try to free a NULL lock\n");
+		return ;
 	}
 
+	lock_destroy(row_lock);
+	lock_dealloc(row_lock);
+
 	return ;
 }
+
+int rtpengine_hash_table_sanity_checks() {
+	// check rtpengine hashtable
+	if (!rtpengine_hash_table) {
+		LM_ERR("NULL rtpengine_hash_table\n");
+		return 0;
+	}
+
+	// check rtpengine hashtable->row_locks
+	if (!rtpengine_hash_table->row_locks) {
+		LM_ERR("NULL rtpengine_hash_table->row_locks\n");
+		return 0;
+	}
+
+	// check rtpengine hashtable->row_entry_list
+	if (!rtpengine_hash_table->row_entry_list) {
+		LM_ERR("NULL rtpengine_hash_table->row_entry_list\n");
+		return 0;
+	}
+
+	// check rtpengine hashtable->row_totals
+	if (!rtpengine_hash_table->row_totals) {
+		LM_ERR("NULL rtpengine_hash_table->row_totals\n");
+		return 0;
+	}
+
+	return 1;
+}
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/rtpengine_hash.h ui-siprouter/modules/rtpengine/rtpengine_hash.h
--- ui-siprouter~/modules/rtpengine/rtpengine_hash.h	2016-01-22 13:44:46.000000000 +0200
+++ ui-siprouter/modules/rtpengine/rtpengine_hash.h	2016-01-22 13:44:46.000000000 +0200
@@ -2,6 +2,7 @@
 #define _RTPENGINE_HASH_H
 
 #include "../../str.h"
+#include "../../locking.h"
 
 
 /* table entry */
@@ -16,8 +17,10 @@
 
 /* table */
 struct rtpengine_hash_table {
-	struct rtpengine_hash_entry **entry_list;	// hastable
-	unsigned int total;				// total number of entries in the hashtable
+	struct rtpengine_hash_entry **row_entry_list;	// vector of size pointers to entry
+	gen_lock_t **row_locks;				// vector of size pointers to locks
+	unsigned int *row_totals;			// vector of size numbers of entries in the hashtable rows
+	unsigned int size;				// hash table size
 };
 
 
@@ -30,6 +33,8 @@
 unsigned int rtpengine_hash_table_total();
 
 void rtpengine_hash_table_free_entry(struct rtpengine_hash_entry *entry);
-void rtpengine_hash_table_free_entry_list(struct rtpengine_hash_entry *entry_list);
+void rtpengine_hash_table_free_row_entry_list(struct rtpengine_hash_entry *row_entry_list);
+
+int rtpengine_hash_table_sanity_checks();
 
 #endif
