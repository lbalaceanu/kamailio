#! /bin/sh /usr/share/dpatch/dpatch-run
## siptrace.dpatch by  <lbalaceanu@dxbu-czc1524bcy>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/forward.c ui-siprouter/forward.c
--- ui-siprouter~/forward.c	2014-12-05 14:45:18.000000000 +0200
+++ ui-siprouter/forward.c	2014-12-05 14:45:34.518189597 +0200
@@ -839,6 +839,16 @@
 		STATS_RPL_FWD_DROP();
 		goto error;
 	}
+	/* call onsend_route */
+	if(dst.send_sock == NULL) {
+	    dst.send_sock=get_send_socket(msg, &dst.to, dst.proto);
+	    if (dst.send_sock==0){
+	        LOG(L_ERR, "forward_reply: ERROR: cannot forward reply\n");
+	        goto done;
+	    }
+	}
+	run_onsend(msg, &dst, new_buf, new_len);
+done:
 #ifdef STATS
 	STATS_TX_RESPONSE(  (msg->first_line.u.reply.statuscode/100) );
 #endif
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/siptrace/sipcapture.h ui-siprouter/modules/siptrace/sipcapture.h
--- ui-siprouter~/modules/siptrace/sipcapture.h	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/siptrace/sipcapture.h	2014-12-05 14:45:34.518189597 +0200
@@ -0,0 +1,77 @@
+/*
+ * $Id$
+ *
+ * hep related structure
+ *
+ * Copyright (C) 2011 Alexandr Dubovikov (QSC AG) (alexandr.dubovikov@gmail.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * Kamailio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * Kamailio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifdef STATISTICS
+#include "../../lib/kcore/statistics.h"
+#endif
+#include "../../str.h"
+
+#ifdef __OS_solaris
+typedef uint8_t u_int8_t;
+typedef uint16_t u_int16_t;
+#define IPPROTO_IPIP IPPROTO_ENCAP /* Solaris IPIP protocol has name ENCAP */
+#endif
+
+struct sipcapture_object {
+   str method;
+   str reply_reason;
+   str ruri;
+   str ruri_user;
+   str from_user;
+   str from_tag;
+   str to_user;
+   str to_tag;
+   str pid_user;
+   str contact_user;
+   str auth_user;
+   str callid;
+   str callid_aleg;
+   str via_1;
+   str via_1_branch;
+   str cseq;
+   str diversion;
+   str reason;
+   str content_type;
+   str authorization;
+   str user_agent;
+   str source_ip;
+   int source_port;
+   str destination_ip;
+   int destination_port;
+   str contact_ip;
+   int contact_port;
+   str originator_ip;
+   int originator_port;
+   int proto;
+   int family;
+   str rtp_stat;
+   int type;
+   long long tmstamp;
+   str node;
+   str msg;
+#ifdef STATISTICS
+   stat_var *stat;
+#endif
+};
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/siptrace/siptrace.c ui-siprouter/modules/siptrace/siptrace.c
--- ui-siprouter~/modules/siptrace/siptrace.c	2014-12-05 14:45:18.000000000 +0200
+++ ui-siprouter/modules/siptrace/siptrace.c	2014-12-05 14:45:34.518189597 +0200
@@ -54,6 +54,7 @@
 #include "../../onsend.h"
 
 #include "../../modules/sipcapture/hep.h"
+//#include "sipcapture.h"
 
 #ifdef STATISTICS
 #include "../../lib/kcore/statistics.h"
@@ -91,10 +92,11 @@
 static int siptrace_init_rpc(void);
 static int child_init(int rank);
 static void destroy(void);
-static int sip_trace(struct sip_msg*, char*, char*);
+static int sip_trace(struct sip_msg*, struct dest_info*, char*);
+static int fixup_siptrace(void ** param, int param_no);
 
 static int sip_trace_store_db(struct _siptrace_data* sto);
-static int trace_send_duplicate(char *buf, int len);
+static int trace_send_duplicate(char *buf, int len, struct dest_info*);
 
 static void trace_onreq_in(struct cell* t, int type, struct tmcb_params *ps);
 static void trace_onreq_out(struct cell* t, int type, struct tmcb_params *ps);
@@ -103,7 +105,7 @@
 static void trace_sl_onreply_out(sl_cbp_t *slcb);
 static void trace_sl_ack_in(sl_cbp_t *slcb);
 
-static int trace_send_hep_duplicate(str *body, str *from, str *to);
+static int trace_send_hep_duplicate(str *body, str *from, str *to, struct dest_info*);
 static int pipport2su (char *pipport, union sockaddr_union *tmp_su, unsigned int *proto);
 
 
@@ -140,6 +142,9 @@
 int xheaders_write = 0;
 int xheaders_read = 0;
 
+str force_send_sock_str = {0, 0};
+struct sip_uri * force_send_sock_uri = 0;
+
 str    dup_uri_str      = {0, 0};
 struct sip_uri *dup_uri = 0;
 
@@ -169,7 +174,8 @@
  */
 static cmd_export_t cmds[] = {
 	{"sip_trace", (cmd_function)sip_trace, 0, 0, 0, ANY_ROUTE},
-	{"sip_trace", (cmd_function)sip_trace, 1, 0, 0, ANY_ROUTE},
+    {"sip_trace", (cmd_function)sip_trace, 1, fixup_siptrace, 0, ANY_ROUTE},
+    {"sip_trace", (cmd_function)sip_trace, 2, fixup_siptrace, 0, ANY_ROUTE},
 	{0, 0, 0, 0, 0, 0}
 };
 
@@ -201,6 +207,7 @@
 	{"xheaders_write",     INT_PARAM, &xheaders_write       },
 	{"xheaders_read",      INT_PARAM, &xheaders_read        },
 	{"hep_mode_on",        INT_PARAM, &hep_mode_on          },	 
+    {"force_send_sock",    STR_PARAM, &force_send_sock_str.s},
 	{"hep_version",        INT_PARAM, &hep_version          },
 	{"hep_capture_id",     INT_PARAM, &hep_capture_id       },	        
 	{"trace_delayed",      INT_PARAM, &trace_delayed        },
@@ -294,6 +301,8 @@
 		dup_uri_str.len = strlen(dup_uri_str.s);
 	if (trace_local_ip.s)
 		trace_local_ip.len = strlen(trace_local_ip.s);
+	if (force_send_sock_str.s)
+	    force_send_sock_str.len = strlen(force_send_sock_str.s);
 
 	if (trace_flag<0 || trace_flag>(int)MAX_FLAG)
 	{
@@ -310,6 +319,11 @@
 
 	*trace_to_database_flag = trace_to_database;
 
+	if(hep_version != 1 && hep_version != 2) {
+	    LM_ERR("unsupported version of HEP");
+	    return -1;
+	}
+
 	/* Find a database module if needed */
 	if(trace_to_database_flag!=NULL && *trace_to_database_flag!=0) {
 		if (db_bind_mod(&db_url, &db_funcs))
@@ -399,6 +413,23 @@
 		}
 	}
 
+	if(force_send_sock_str.s!=0)
+	{
+	    force_send_sock_str.len = strlen(force_send_sock_str.s);
+	    force_send_sock_uri = (struct sip_uri *)pkg_malloc(sizeof(struct sip_uri));
+	    if(force_send_sock_uri==0)
+	    {
+	        LM_ERR("no more pkg memory left\n");
+	        return -1;
+	    }
+	    memset(force_send_sock_uri, 0, sizeof(struct sip_uri));
+	    if(parse_uri(force_send_sock_str.s, force_send_sock_str.len, force_send_sock_uri)<0)
+	    {
+	        LM_ERR("bad dup uri\n");
+	        return -1;
+	    }
+	}
+
 	if(traced_user_avp_str.s && traced_user_avp_str.len > 0)
 	{
 		if (pv_parse_spec(&traced_user_avp_str, &avp_spec)==0
@@ -709,7 +740,7 @@
 	return 0;
 }
 
-static int sip_trace_store(struct _siptrace_data *sto)
+static int sip_trace_store(struct _siptrace_data *sto, struct dest_info *dst)
 {
 	if(sto==NULL)
 	{
@@ -726,8 +757,8 @@
 	if (sip_trace_xheaders_write(sto) != 0)
 		return -1;
 
-	if(hep_mode_on) trace_send_hep_duplicate(&sto->body, &sto->fromip, &sto->toip);
-	else trace_send_duplicate(sto->body.s, sto->body.len);
+	if(hep_mode_on) trace_send_hep_duplicate(&sto->body, &sto->fromip, &sto->toip, dst);
+    else trace_send_duplicate(sto->body.s, sto->body.len, dst);
 
 	if (sip_trace_xheaders_free(sto) != 0)
 		return -1;
@@ -866,11 +897,79 @@
 	return -1;
 }
 
-static int sip_trace(struct sip_msg *msg, char *dir, char *s2)
+static int fixup_siptrace(void** param, int param_no){
+
+   if (param_no == 1)
+   {
+       LM_DBG("sip_trace URI:%s\n", (char*)*param);
+       char *duri = (char*)*param;
+       struct sip_uri dup_uri;
+       struct dest_info *dst=NULL;
+       struct proxy_l * p=NULL;
+       str dup_uri_str = {0,0};
+       if (*duri){//string ""?
+           dup_uri_str.s = duri;
+           dup_uri_str.len = strlen(dup_uri_str.s);
+
+           memset(&dup_uri, 0, sizeof(struct sip_uri));
+           if(parse_uri(dup_uri_str.s, dup_uri_str.len, &dup_uri)<0)
+           {
+               LM_ERR("bad dup uri\n");
+               return -1;
+           }
+
+           dst = (struct dest_info *)pkg_malloc(sizeof(struct dest_info));
+           if(dst==0)
+           {
+               LM_ERR("no more pkg memory left\n");
+               return -1;
+           }
+           init_dest_info(dst);
+           /* create a temporary proxy*/
+           dst->proto = PROTO_UDP;
+           p=mk_proxy(&dup_uri.host, (dup_uri.port_no)?dup_uri.port_no:SIP_PORT,
+                   dst->proto);
+           if (p==0)
+           {
+               LM_ERR("bad host name in uri\n");
+               pkg_free(dst);
+               return -1;
+           }
+
+           hostent2su(&dst->to, &p->host, p->addr_idx, (p->port)?p->port:SIP_PORT);
+
+           *param = (void*)dst;
+       }
+       else {
+           LM_ERR("invalid dup URI\n");
+           return -1;
+       }
+
+       return 0;
+   }
+   else
+   {
+       LM_DBG("params:%s\n", (char*)*param);
+       return 0;
+   }
+}
+
+static int sip_trace(struct sip_msg *msg, struct dest_info * dst, char *dir)
 {
 	struct _siptrace_data sto;
 	struct onsend_info *snd_inf = NULL;
 
+	if (dst){
+	    if (dst->send_sock == 0){
+	        dst->send_sock=get_send_socket(0, &dst->to, dst->proto);
+	        if (dst->send_sock==0){
+	            LM_ERR("can't forward to af %d, proto %d no corresponding"
+	                    " listening socket\n", dst->to.s.sa_family, dst->proto);
+	            return -1;
+	        }
+	    }
+	}
+
 	if(msg==NULL) {
 		LM_DBG("nothing to trace\n");
 		return -1;
@@ -956,7 +1055,7 @@
 		sto.stat = siptrace_req;
 	}
 #endif
-	return sip_trace_store(&sto);
+	return sip_trace_store(&sto, dst);
 }
 
 #define trace_is_off(_msg) \
@@ -1138,7 +1237,7 @@
 	sto.stat = siptrace_req;
 #endif
 
-	sip_trace_store(&sto);
+	sip_trace_store(&sto, NULL);
 	return;
 }
 
@@ -1209,7 +1308,7 @@
 	sto.stat = siptrace_rpl;
 #endif
 
-	sip_trace_store(&sto);
+	sip_trace_store(&sto, NULL);
 	return;
 }
 
@@ -1318,7 +1417,7 @@
 	sto.stat = siptrace_rpl;
 #endif
 
-	sip_trace_store(&sto);
+	sip_trace_store(&sto, NULL);
 	return;
 }
 
@@ -1404,7 +1503,7 @@
 	sto.stat = siptrace_rpl;
 #endif
 
-	sip_trace_store(&sto);
+	sip_trace_store(&sto, NULL);
 	return;
 }
 
@@ -1456,10 +1555,10 @@
 	}
 }
 
-static int trace_send_duplicate(char *buf, int len)
+static int trace_send_duplicate(char *buf, int len, struct dest_info *dst2)
 {
 	struct dest_info dst;
-	struct proxy_l * p;
+	struct proxy_l * p = NULL;
 
 	if(buf==NULL || len <= 0)
 		return -1;
@@ -1478,17 +1577,27 @@
 		return -1;
 	}
 
-	hostent2su(&dst.to, &p->host, p->addr_idx, (p->port)?p->port:SIP_PORT);
+	if (!dst2){
+	    init_dest_info(&dst);
+	    /* create a temporary proxy*/
+	    dst.proto = PROTO_UDP;
+	    p=mk_proxy(&dup_uri->host, (dup_uri->port_no)?dup_uri->port_no:SIP_PORT,
+	             dst.proto);
+	    if (p==0){
+	        LM_ERR("bad host name in uri\n");
+	        return -1;
+	    }
+	    hostent2su(&dst.to, &p->host, p->addr_idx, (p->port)?p->port:SIP_PORT);
 
-	dst.send_sock=get_send_socket(0, &dst.to, dst.proto);
-	if (dst.send_sock==0)
-	{
-		LM_ERR("can't forward to af %d, proto %d no corresponding"
-				" listening socket\n", dst.to.s.sa_family, dst.proto);
-		goto error;
+	    dst.send_sock=get_send_socket(0, &dst.to, dst.proto);
+	    if (dst.send_sock==0){
+	        LM_ERR("can't forward to af %d, proto %d no corresponding"
+	                " listening socket\n", dst.to.s.sa_family, dst.proto);
+	        goto error;
+	    }
 	}
 
-	if (msg_send(&dst, buf, len)<0)
+	if (msg_send((dst2)?dst2:&dst, buf, len)<0)
 	{
 		LM_ERR("cannot send duplicate message\n");
 		goto error;
@@ -1496,16 +1605,24 @@
 
 	free_proxy(p); /* frees only p content, not p itself */
 	pkg_free(p);
+	if (p){
+	    free_proxy(p); /* frees only p content, not p itself */
+	    pkg_free(p);
+	}
 	return 0;
 error:
-	free_proxy(p); /* frees only p content, not p itself */
-	pkg_free(p);
+    if (p){
+    	free_proxy(p); /* frees only p content, not p itself */
+    	pkg_free(p);
+    }
 	return -1;
 }
 
-static int trace_send_hep_duplicate(str *body, str *from, str *to)
+static int trace_send_hep_duplicate(str *body, str *from, str *to, struct dest_info * dst2)
 {
 	struct dest_info dst;
+	struct socket_info *si;
+	struct dest_info* dst_fin = NULL;
 	struct proxy_l * p=NULL /* make gcc happy */;
 	void* buffer = NULL;
 	union sockaddr_union from_su;
@@ -1550,26 +1667,46 @@
 		goto error;
 	}
 
-	init_dest_info(&dst);
-	/* create a temporary proxy*/
-	dst.proto = PROTO_UDP;
-	p=mk_proxy(&dup_uri->host, (dup_uri->port_no)?dup_uri->port_no:SIP_PORT,
+    if (!dst2){
+    	init_dest_info(&dst);
+    	/* create a temporary proxy*/
+    	dst.proto = PROTO_UDP;
+    	p=mk_proxy(&dup_uri->host, (dup_uri->port_no)?dup_uri->port_no:SIP_PORT,
 			dst.proto);
-	if (p==0)
-	{
-		LM_ERR("bad host name in uri\n");
-		goto error;
-	}
+    	if (p==0)
+    	{
+    		LM_ERR("bad host name in uri\n");
+    		goto error;
+    	}
 
-	hostent2su(&dst.to, &p->host, p->addr_idx, (p->port)?p->port:SIP_PORT);
+    	hostent2su(&dst.to, &p->host, p->addr_idx, (p->port)?p->port:SIP_PORT);
+    	LM_DBG("setting up the socket_info\n");
+    	dst_fin = &dst;
+    } else {
+        dst_fin = dst2;
+    }
 
-	dst.send_sock=get_send_socket(0, &dst.to, dst.proto);
-	if (dst.send_sock==0)
-	{
-		LM_ERR("can't forward to af %d, proto %d no corresponding"
-				" listening socket\n", dst.to.s.sa_family, dst.proto);
-		goto error;
-	}
+    if (force_send_sock_str.s) {
+        LM_DBG("force_send_sock activated, grep for the sock_info\n");
+        si = grep_sock_info(&force_send_sock_uri->host,
+                (force_send_sock_uri->port_no)?force_send_sock_uri->port_no:SIP_PORT,
+                PROTO_UDP);
+        if (!si) {
+             LM_WARN("cannot grep socket info\n");
+        } else {
+            LM_DBG("found socket while grep: [%.*s] [%.*s]\n", si->name.len, si->name.s, si->address_str.len, si->address_str.s);
+            dst_fin->send_sock = si;
+        }
+    }
+
+    if (dst_fin->send_sock == 0) {
+        dst_fin->send_sock=get_send_socket(0, &dst_fin->to, dst_fin->proto);
+        if (dst_fin->send_sock == 0) {
+            LM_ERR("can't forward to af %d, proto %d no corresponding"
+                    " listening socket\n", dst_fin->to.s.sa_family, dst_fin->proto);
+            goto error;
+        }
+    }
 
 	/* Version && proto && length */
 	hdr.hp_l = sizeof(struct hep_hdr);
@@ -1649,14 +1786,16 @@
 	memcpy((void*)(buffer + buflen) , (void*)body->s, body->len);
 	buflen +=body->len;
 
-	if (msg_send(&dst, buffer, buflen)<0)
+	if (msg_send(dst_fin, buffer, buflen)<0)
 	{
 		LM_ERR("cannot send hep duplicate message\n");
 		goto error;
 	}
 
-	free_proxy(p); /* frees only p content, not p itself */
-	pkg_free(p);
+    if (p) {
+    	free_proxy(p); /* frees only p content, not p itself */
+    	pkg_free(p);
+    }
 	pkg_free(buffer);
 	return 0;
 error:
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/tm/t_reply.c ui-siprouter/modules/tm/t_reply.c
--- ui-siprouter~/modules/tm/t_reply.c	2014-12-05 14:45:18.000000000 +0200
+++ ui-siprouter/modules/tm/t_reply.c	2014-12-05 14:57:13.626478730 +0200
@@ -1811,6 +1811,7 @@
 	relayed_code=0;
 	totag_retr=0;
 
+	struct ip_addr ip;
 
 	/* remember, what was sent upstream to know whether we are
 	 * forwarding a first final reply or not */
@@ -1995,19 +1996,28 @@
 		if (reply_status == RPS_COMPLETED) {
 			start_final_repl_retr(t);
 		}
-		if (likely(uas_rb->dst.send_sock &&
-					SEND_PR_BUFFER( uas_rb, buf, res_len ) >= 0)){
-			if (unlikely(!totag_retr && has_tran_tmcbs(t, TMCB_RESPONSE_OUT))){
-				run_trans_callbacks_with_buf( TMCB_RESPONSE_OUT, uas_rb, t->uas.request,
-				                              relayed_msg, relayed_code);
+		if (likely(uas_rb->dst.send_sock )){
+			if ( p_msg && (p_msg != FAKED_REPLY)) {
+				if (run_onsend(p_msg, &uas_rb->dst, buf, res_len)==0) {
+					su2ip_addr(&ip, &(uas_rb->dst.to));
+					LOG(L_ERR, "forward_reply: reply to %s:%d(%d) dropped"
+							" (onsend_route)\n", ip_addr2a(&ip),
+								su_getport(&(uas_rb->dst.to)), uas_rb->dst.proto);
+				}
 			}
-			if (unlikely(has_tran_tmcbs(t, TMCB_RESPONSE_SENT))){
-				INIT_TMCB_ONSEND_PARAMS(onsend_params, t->uas.request,
-									relayed_msg, uas_rb, &uas_rb->dst, buf,
-									res_len,
-									(relayed_msg==FAKED_REPLY)?TMCB_LOCAL_F:0,
-									uas_rb->branch, relayed_code);
-				run_trans_callbacks_off_params(TMCB_RESPONSE_SENT, t, &onsend_params);
+			if ( SEND_PR_BUFFER( uas_rb, buf, res_len ) >= 0) {
+				if (unlikely(!totag_retr && has_tran_tmcbs(t, TMCB_RESPONSE_OUT))) {
+					run_trans_callbacks_with_buf( TMCB_RESPONSE_OUT, uas_rb, t->uas.request,
+												  relayed_msg, relayed_code);
+				}
+				if (unlikely(has_tran_tmcbs(t, TMCB_RESPONSE_SENT))) {
+					INIT_TMCB_ONSEND_PARAMS(onsend_params, t->uas.request,
+										relayed_msg, uas_rb, &uas_rb->dst, buf,
+										res_len,
+										(relayed_msg==FAKED_REPLY)?TMCB_LOCAL_F:0,
+										uas_rb->branch, relayed_code);
+					run_trans_callbacks_off_params(TMCB_RESPONSE_SENT, t, &onsend_params);
+				}
 			}
 		} else if (unlikely(uas_rb->dst.send_sock == 0))
 			ERR("no resolved dst to send reply to\n");
