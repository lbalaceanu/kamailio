#! /bin/sh /usr/share/dpatch/dpatch-run
## rtpengine_module.dpatch by  <miti@dell>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/Makefile ui-siprouter/modules/rtpengine/Makefile
--- ui-siprouter~/modules/rtpengine/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/Makefile	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,15 @@
+# WARNING: do not run this directly, it should be run by the master Makefile
+
+include ../../Makefile.defs
+auto_gen=
+NAME=rtpengine.so
+LIBS=
+
+DEFS+=-DKAMAILIO_MOD_INTERFACE
+
+SERLIBPATH=../../lib
+SER_LIBS+=$(SERLIBPATH)/kmi/kmi
+SER_LIBS+=$(SERLIBPATH)/kcore/kcore
+SER_LIBS+=$(SERLIBPATH)/srdb1/srdb1
+include ../../Makefile.modules
+
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/README ui-siprouter/modules/rtpengine/README
--- ui-siprouter~/modules/rtpengine/README	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/README	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,880 @@
+rtpengine Module
+
+Maxim Sobolev
+
+   Sippy Software, Inc.
+
+Juha Heinanen
+
+   TuTPro, Inc.
+
+Edited by
+
+Maxim Sobolev
+
+Edited by
+
+Bogdan-Andrei Iancu
+
+Edited by
+
+Juha Heinanen
+
+Edited by
+
+Sas Ovidiu
+
+Edited by
+
+Carsten Bock
+
+   ng-voice GmbH
+
+Edited by
+
+Richard Fuchs
+
+   Sipwise GmbH
+
+   Copyright © 2003-2008 Sippy Software, Inc.
+
+   Copyright © 2005 Voice Sistem SRL
+
+   Copyright © 2009-2014 TuTPro Inc.
+
+   Copyright © 2010 VoIPEmbedded Inc.
+
+   Copyright © 2013-2015 Sipwise GmbH
+     __________________________________________________________________
+
+   Table of Contents
+
+   1. Admin Guide
+
+        1. Overview
+        2. Multiple RTP proxy usage
+        3. Dependencies
+
+              3.1. Kamailio Modules
+              3.2. External Libraries or Applications
+
+        4. Parameters
+
+              4.1. rtpengine_sock (string)
+              4.2. rtpengine_disable_tout (integer)
+              4.3. rtpengine_tout_ms (integer)
+              4.4. queried_nodes_limit (integer)
+              4.5. rtpengine_retr (integer)
+              4.6. extra_id_pv (string)
+              4.7. setid_avp (string)
+              4.8. force_send_interface (string)
+              4.9. write_sdp_pv (string)
+              4.10. rtp_inst_pvar (string)
+
+        5. Functions
+
+              5.1. set_rtpengine_set(setid[, setid])
+              5.2. rtpengine_offer([flags])
+              5.3. rtpengine_answer([flags])
+              5.4. rtpengine_delete([flags])
+              5.5. rtpengine_manage([flags])
+              5.6. start_recording()
+
+        6. Exported Pseudo Variables
+
+              6.1. $rtpstat
+
+        7. MI Commands
+
+              7.1. nh_enable_rtpp proxy_url/all 0/1
+              7.2. nh_show_rtpp proxy_url/all
+              7.3. nh_ping_rtpp proxy_url/all
+
+   2. Frequently Asked Questions
+
+   List of Examples
+
+   1.1. Set rtpengine_sock parameter
+   1.2. Set rtpengine_disable_tout parameter
+   1.3. Set rtpengine_tout_ms parameter
+   1.4. Set queried_nodes_limit parameter
+   1.5. Set rtpengine_retr parameter
+   1.6. Set extra_id_pv parameter
+   1.7. Set setid_avp parameter
+   1.8. Set force_send_interface parameter
+   1.9. Set write_sdp_pv parameter
+   1.10. Set rtp_inst_pvar parameter
+   1.11. set_rtpengine_set usage
+   1.12. rtpengine_offer usage
+   1.13. rtpengine_answer usage
+   1.14. rtpengine_delete usage
+   1.15. rtpengine_manage usage
+   1.16. start_recording usage
+   1.17. $rtpstat Usage
+   1.18. nh_enable_rtpp usage
+   1.19. nh_show_rtpp usage
+   1.20. nh_ping_rtpp usage
+
+Chapter 1. Admin Guide
+
+   Table of Contents
+
+   1. Overview
+   2. Multiple RTP proxy usage
+   3. Dependencies
+
+        3.1. Kamailio Modules
+        3.2. External Libraries or Applications
+
+   4. Parameters
+
+        4.1. rtpengine_sock (string)
+        4.2. rtpengine_disable_tout (integer)
+        4.3. rtpengine_tout_ms (integer)
+        4.4. queried_nodes_limit (integer)
+        4.5. rtpengine_retr (integer)
+        4.6. extra_id_pv (string)
+        4.7. setid_avp (string)
+        4.8. force_send_interface (string)
+        4.9. write_sdp_pv (string)
+        4.10. rtp_inst_pvar (string)
+
+   5. Functions
+
+        5.1. set_rtpengine_set(setid[, setid])
+        5.2. rtpengine_offer([flags])
+        5.3. rtpengine_answer([flags])
+        5.4. rtpengine_delete([flags])
+        5.5. rtpengine_manage([flags])
+        5.6. start_recording()
+
+   6. Exported Pseudo Variables
+
+        6.1. $rtpstat
+
+   7. MI Commands
+
+        7.1. nh_enable_rtpp proxy_url/all 0/1
+        7.2. nh_show_rtpp proxy_url/all
+        7.3. nh_ping_rtpp proxy_url/all
+
+1. Overview
+
+   This is a module that enables media streams to be proxied via an RTP
+   proxy. The only RTP proxy currently known to work with this module is
+   the Sipwise rtpengine https://github.com/sipwise/rtpengine. The
+   rtpengine module is a modified version of the original rtpproxy module
+   using a new control protocol. The module is designed to be a drop-in
+   replacement for the old module from a configuration file point of view,
+   however due to the incompatible control protocol, it only works with
+   RTP proxies which specifically support it.
+
+2. Multiple RTP proxy usage
+
+   The rtpengine module can support multiple RTP proxies for
+   balancing/distribution and control/selection purposes.
+
+   The module allows definition of several sets of rtpproxies.
+   Load-balancing will be performed over a set and the admin has the
+   ability to choose what set should be used. The set is selected via its
+   id - the id being defined with the set. Refer to the "rtpengine_sock"
+   module parameter definition for syntax description.
+
+   The balancing inside a set is done automatically by the module based on
+   the weight of each RTP proxy from the set.
+
+   The selection of the set is done from script prior using
+   rtpengine_delete(), rtpengine_offer() or rtpengine_answer() functions -
+   see the set_rtpengine_set() function.
+
+   Another way to select the set is to define setid_avp module parameter
+   and assign setid to the defined avp before calling rtpengine_offer() or
+   rtpengine_manage() function. If forwarding of the requests fails and
+   there is another branch to try, remember to unset the avp after calling
+   rtpengine_delete() function.
+
+   For backward compatibility reasons, a set with no id take by default
+   the id 0. Also if no set is explicitly set before rtpengine_delete(),
+   rtpengine_offer() or rtpengine_answer() the 0 id set will be used.
+
+   IMPORTANT: if you use multiple sets, take care and use the same set for
+   both rtpengine_offer()/rtpengine_answer() and rtpengine_delete()!! If
+   the set was selected using setid_avp, the avp needs to be set only once
+   before rtpengine_offer() or rtpengine_manage() call.
+
+3. Dependencies
+
+   3.1. Kamailio Modules
+   3.2. External Libraries or Applications
+
+3.1. Kamailio Modules
+
+   The following modules must be loaded before this module:
+     * tm module - (optional) if you want to have rtpengine_manage() fully
+       functional
+
+3.2. External Libraries or Applications
+
+   The following libraries or applications must be installed before
+   running Kamailio with this module loaded:
+     * None.
+
+4. Parameters
+
+   4.1. rtpengine_sock (string)
+   4.2. rtpengine_disable_tout (integer)
+   4.3. rtpengine_tout_ms (integer)
+   4.4. queried_nodes_limit (integer)
+   4.5. rtpengine_retr (integer)
+   4.6. extra_id_pv (string)
+   4.7. setid_avp (string)
+   4.8. force_send_interface (string)
+   4.9. write_sdp_pv (string)
+   4.10. rtp_inst_pvar (string)
+
+4.1. rtpengine_sock (string)
+
+   Definition of socket(s) used to connect to (a set) RTP proxy. It may
+   specify a UNIX socket or an IPv4/IPv6 UDP socket.
+
+   Default value is "NONE" (disabled).
+
+   Example 1.1. Set rtpengine_sock parameter
+...
+# single rtproxy
+modparam("rtpengine", "rtpengine_sock", "udp:localhost:12221")
+# multiple rtproxies for LB with weights (missing weight defaults to 1)
+modparam("rtpengine", "rtpengine_sock",
+        "udp:localhost:12221=2 udp:localhost:12222=1")
+# multiple sets of multiple rtproxies
+modparam("rtpengine", "rtpengine_sock",
+        "1 == udp:localhost:12221 udp:localhost:12222")
+modparam("rtpengine", "rtpengine_sock",
+        "2 == udp:localhost:12225")
+...
+
+4.2. rtpengine_disable_tout (integer)
+
+   Once an RTP proxy was found unreachable and marked as disabled, the
+   rtpengine module will not attempt to establish communication to that
+   RTP proxy for rtpengine_disable_tout seconds.
+
+   Default value is "60".
+
+   Example 1.2. Set rtpengine_disable_tout parameter
+...
+modparam("rtpengine", "rtpengine_disable_tout", 20)
+...
+
+4.3. rtpengine_tout_ms (integer)
+
+   Timeout value expressed in milliseconds in waiting for reply from RTP
+   proxy.
+
+   Default value is "1000".
+
+   Example 1.3. Set rtpengine_tout_ms parameter
+...
+modparam("rtpengine", "rtpengine_tout_ms", 2000)
+...
+
+4.4. queried_nodes_limit (integer)
+
+   The total number of nodes inside a set (sets are configurable via
+   rtpengine_sock function) to be queried before giving up establishing a
+   session. This brings more flexibility in case checking all rtpengines
+   would take too long. Max limit is 50.
+
+   By default all nodes in a set are tried before giving up communicating
+   with the rtpengines.
+
+   Example 1.4. Set queried_nodes_limit parameter
+...
+modparam("rtpengine", "queried_nodes_limit", 5)
+...
+
+4.5. rtpengine_retr (integer)
+
+   How many times the module should retry to send and receive after
+   timeout was generated.
+
+   Default value is "5".
+
+   Example 1.5. Set rtpengine_retr parameter
+...
+modparam("rtpengine", "rtpengine_retr", 2)
+...
+
+4.6. extra_id_pv (string)
+
+   The parameter sets the PV defination to use when the "b" parameter is
+   used on rtpengine_delete(), rtpengine_offer(), rtpengine_answer() or
+   rtpengine_manage() command.
+
+   Default is empty, the "b" parameter may not be used then.
+
+   Example 1.6. Set extra_id_pv parameter
+...
+modparam("rtpengine", "extra_id_pv", "$avp(extra_id)")
+...
+
+4.7. setid_avp (string)
+
+   The parameter defines an AVP that, if set, determines which RTP proxy
+   set rtpengine_offer(), rtpengine_answer(), rtpengine_delete(), and
+   rtpengine_manage() functions use.
+
+   There is no default value.
+
+   Example 1.7. Set setid_avp parameter
+...
+modparam("rtpengine", "setid_avp", "$avp(setid)")
+...
+
+4.8. force_send_interface (string)
+
+   Forces all control messages between the SIP proxy and the RTP proxy to
+   be sent from the specified local interface. Both IPv4 and IPv6
+   addresses are supported. If not specified, the default interface
+   selected by the operating system will be used. Note: when
+   rtpengine_sock is a IPv6 link-local address, one _must_ set this
+   parameter in order to successfully connect to RTP engine. This is
+   necessarely because OS needs additional scope_id hint to communicate
+   over IPv6 link locals. The scope_id is resolved based on the given
+   IPv6.
+
+   There is no default value.
+
+   Example 1.8. Set force_send_interface parameter
+...
+modparam("rtpengine", "force_send_interface", "10.3.7.123")
+modparam("rtpengine", "force_send_interface", "2001:8d8:1ff:10c0:9a90:96ff:fea8:
+fd99")
+...
+
+4.9. write_sdp_pv (string)
+
+   If this parameter is set to a valid AVP or script var specifier, the
+   SDP returned by rtpengine in the offer/answer operations is returned in
+   the specified variable instead of the message body.
+
+   There is no default value.
+
+   Example 1.9. Set write_sdp_pv parameter
+...
+modparam("rtpengine", "write_sdp_pv", "$avp(sdp)")
+  ...  or
+modparam("rtpengine", "write_sdp_pv", "$pv(sdp)")
+...
+
+4.10. rtp_inst_pvar (string)
+
+   A pseudo variable to store the chosen RTP Engine IP address. If this
+   parameter is set, the IP address and port of the instance chosen will
+   be stored in the given variable.
+
+   By default, this parameter is not set.
+
+   Example 1.10. Set rtp_inst_pvar parameter
+...
+modparam("rtpproxy", "rtp_inst_pvar", "$avp(RTP_INSTANCE)")
+...
+
+5. Functions
+
+   5.1. set_rtpengine_set(setid[, setid])
+   5.2. rtpengine_offer([flags])
+   5.3. rtpengine_answer([flags])
+   5.4. rtpengine_delete([flags])
+   5.5. rtpengine_manage([flags])
+   5.6. start_recording()
+
+5.1. set_rtpengine_set(setid[, setid])
+
+   Sets the ID of the RTP proxy set to be used for the next
+   rtpengine_delete(), rtpengine_offer(), rtpengine_answer() or
+   rtpengine_manage() command. The parameter can be an integer or a config
+   variable holding an integer.
+
+   A second set ID can be specified to daisy-chain two RTP proxies. The
+   two set IDs must be distinct from each other and there must not be any
+   overlap in the proxies present in both sets. In this use case, the
+   request (offer, answer, etc) is first sent to an RTP proxy from the
+   first set, which rewrites the SDP body and sends it back to the module.
+   The rewritten SDP body is then used to make another request to an RTP
+   proxy from the second set, which rewrites the SDP body another time and
+   sends it back to the module to be placed back into the SIP message.
+   This is useful if you have a set of RTP proxies that the caller must
+   use, and another distinct set of RTP proxies that the callee must use.
+   This is supported by all rtpengine commands except rtpengine_manage().
+
+   This function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,
+   BRANCH_ROUTE.
+
+   Example 1.11. set_rtpengine_set usage
+...
+set_rtpengine_set("2");
+rtpengine_offer();
+...
+
+5.2. rtpengine_offer([flags])
+
+   Rewrites SDP body to ensure that media is passed through an RTP proxy.
+   To be invoked on INVITE for the cases the SDP bodies are in INVITE and
+   200 OK and on 200 OK when SDP bodies are in 200 OK and ACK.
+
+   Meaning of the parameters is as follows:
+     * flags - flags to turn on some features.
+       The "flags" string is a list of space-separated items. Each item is
+       either an individual token, or a token in "key=value" format. The
+       possible tokens are described below.
+          + via-branch=... - Include the "branch" value of one of the
+            "Via" headers in the request to the RTP proxy. Possible values
+            are: "1" - use the first "Via" header; "2" - use the second
+            "Via" header; "auto" - use the first "Via" header if this is a
+            request, or the second one if this is a reply; "extra" - don't
+            take the value from a header, but instead use the value of the
+            "extra_id_pv" variable. This can be used to create one media
+            session per branch on the RTP proxy. When sending a subsequent
+            "delete" command to the RTP proxy, you can then stop just the
+            session for a specific branch when passing the flag '1' or '2'
+            in the "rtpengine_delete", or stop all sessions for a call
+            when not passing one of those two flags there. This is
+            especially useful if you have serially forked call scenarios
+            where the RTP proxy gets an "offer" command for a new branch,
+            and then a "delete" command for the previous branch, which
+            would otherwise delete the full call, breaking the subsequent
+            "answer" for the new branch. This flag is only supported by
+            the Sipwise rtpengine RTP proxy at the moment!
+          + asymmetric - flags that UA from which message is received
+            doesn't support symmetric RTP. Disables learning of endpoint
+            addresses in the Sipwise rtpengine proxy.
+          + force-answer - force "answer", that is, only rewrite SDP when
+            corresponding session already exists in the RTP proxy. By
+            default is on when the session is to be completed.
+          + direction=... - this option specifies a logical network
+            interface and should be given exactly twice. It enables RTP
+            bridging between different addresses or networks of the same
+            family (e.g. IPv4 to IPv4). The first instance of the option
+            specifies the interface that the originator of this message
+            should be using, while the second instance specifies the
+            interface that the target should be using. For example, if the
+            SIP message was sent by an endpoint on a private network and
+            will be sent to an endpoint on the public internet, you would
+            use "direction=priv direction=pub" if those two logical
+            network interfaces were called "priv" and "pub" in your RTP
+            proxy's configuration respectively. The direction must only be
+            specified in for initial SDP offer; answers or subsequent
+            offers can omit this option.
+          + internal, external - shorthand for "direction=internal" and
+            "direction=external" respectively. Useful for brevity or as
+            legacy option if the RTP proxy only supports two network
+            interfaces instead of multiple, arbitrarily named ones.
+          + auto-bridge - this flag an alternative to the "internal" and
+            "external" flags in order to do automatic bridging between
+            IPv4 on the "internal network" and IPv6 on the "external
+            network". Instead of explicitly instructing the RTP proxy to
+            select a particular address family, the distinction is done by
+            the given IP in the SDP body by the RTP proxy itself. Not
+            supported by Sipwise rtpengine.
+          + address-family=... - instructs the RTP proxy that the
+            recipient of this SDP body expects to see addresses of a
+            particular family. Possible values are "IP4" and "IP6". For
+            example, if the SDP body contains IPv4 addresses but the
+            recipient only speaks IPv6, you would use "address-family=IP6"
+            to bridge between the two address families.
+            Sipwise rtpengine remembers the address family preference of
+            each party after it has seen an SDP body from them. This means
+            that normally it is only necessary to explicitly specify the
+            address family in the "offer", but not in the "answer".
+            Note: Please note, that this will only work properly with
+            non-dual-stack user-agents or with dual-stack clients
+            according to RFC6157 (which suggest ICE for Dual-Stack
+            implementations). This short-cut will not work properly with
+            RFC4091 (ANAT) compatible clients, which suggests having
+            different m-lines with different IP-protocols grouped
+            together.
+          + force - instructs the RTP proxy to ignore marks inserted by
+            another RTP proxy in transit to indicate that the session is
+            already goes through another proxy. Allows creating a chain of
+            proxies. Not supported and ignored by Sipwise rtpengine.
+          + trust-address - flags that IP address in SDP should be
+            trusted. Starting with rtpengine 3.8, this is the default
+            behaviour. In older versions, without this flag the RTP proxy
+            ignores the address in the SDP and uses source address of the
+            SIP message as media address which is passed to the RTP proxy.
+          + SIP-source-address - the opposite of trust-address. Restores
+            the old default behaviour of ignoring endpoint addresses in
+            the SDP body.
+          + replace-origin - flags that IP from the origin description
+            (o=) should be also changed.
+          + replace-session-connection - flags to change the session-level
+            SDP connection (c=) IP if media description also includes
+            connection information.
+          + symmetric - flags that for the UA from which message is
+            received, support symmetric RTP must be forced. Does nothing
+            with the Sipwise rtpengine proxy as it is the default.
+          + repacketize=NN - requests the RTP proxy to perform
+            re-packetization of RTP traffic coming from the UA which has
+            sent the current message to increase or decrease payload size
+            per each RTP packet forwarded if possible. The NN is the
+            target payload size in ms, for the most codecs its value
+            should be in 10ms increments, however for some codecs the
+            increment could differ (e.g. 30ms for GSM or 20ms for G.723).
+            The RTP proxy would select the closest value supported by the
+            codec. This feature could be used for significantly reducing
+            bandwith overhead for low bitrate codecs, for example with
+            G.729 going from 10ms to 100ms saves two thirds of the network
+            bandwith. Not supported by Sipwise rtpengine.
+          + ICE=... - controls the RTP proxy's behaviour regarding ICE
+            attributes within the SDP body. Possible values are: "force" -
+            discard any ICE attributes already present in the SDP body and
+            then generate and insert new ICE data, leaving itself as the
+            only ICE candidates; "force-relay" - discard any "relay" type
+            ICE attributes already present in the SDP body and then
+            generate and insert itself as the only ICE "relay" candidates;
+            "remove" instructs the RTP proxy to discard any ICE attributes
+            and not insert any new ones into the SDP. The default (if no
+            "ICE=..." is given at all), new ICE data will only be
+            generated if no ICE was present in the SDP originally;
+            otherwise the RTP proxy will only insert itself as additional
+            ICE candidate. Other SDP substitutions (c=, m=, etc) are
+            unaffected by this flag.
+          + RTP, SRTP, AVP, AVPF - These flags control the RTP transport
+            protocol that should be used towards the recipient of the SDP.
+            If none of them are specified, the protocol given in the SDP
+            is left untouched. Otherwise, the "SRTP" flag indicates that
+            SRTP should be used, while "RTP" indicates that SRTP should
+            not be used. "AVPF" indicates that the advanced RTCP profile
+            with feedback messages should be used, and "AVP" indicates
+            that the regular RTCP profile should be used. See also the
+            next set of flags below.
+          + RTP/AVP, RTP/SAVP, RTP/AVPF, RTP/SAVPF - these serve as an
+            alternative, more explicit way to select between the different
+            RTP protocols and profiles supported by the RTP proxy. For
+            example, giving the flag "RTP/SAVPF" has the same effect as
+            giving the two flags "SRTP AVPF".
+          + to-tag - force inclusion of the "To" tag. Normally, the "To"
+            tag is always included when present, except for "delete"
+            messages. Including the "To" tag in a "delete" messages allows
+            you to be more selective about which dialogues within a call
+            are being torn down.
+          + rtcp-mux-demux - if rtcp-mux (RFC 5761) was offered, make the
+            RTP proxy accept the offer, but not offer it to the recipient
+            of this message.
+          + rtcp-mux-reject - if rtcp-mux was offered, make the RTP proxy
+            reject the offer, but still offer it to the recipient. Can be
+            combined with "rtcp-mux-offer" to always offer it.
+          + rtcp-mux-offer - make the RTP proxy offer rtcp-mux to the
+            recipient of this message, regardless of whether it was
+            offered originally or not.
+          + rtcp-mux-accept - if rtcp-mux was offered, make the RTP proxy
+            accept the offer and also offer it to the recipient of this
+            message. Can be combined with "rtcp-mux-offer" to always offer
+            it.
+          + media-address=... - force a particular media address to be
+            used in the SDP body. Address family is detected
+            automatically.
+          + TOS=... - change the IP TOS value for all outgoing RTP packets
+            within the entire call in both directions. Only honoured in an
+            "offer", ignored for an "answer". Valid values are 0 through
+            255, given in decimal. If this option is not specified, the
+            TOS value will revert to the default TOS (normally 184). A
+            value of -1 may be used to leave the currently used TOS
+            unchanged.
+          + delete-delay=... - override the default delay (in seconds)
+            before a call is actually deleted from memory. Can be set to
+            zero to effectuate immediate deletion. This option only makes
+            sense for delete operations.
+          + strict-source - instructs the RTP proxy to check the source
+            addresses of all incoming RTP packets and drop the packets if
+            the address doesn't match.
+          + media-handover - the antithesis of strict-source. Instructs
+            the RTP proxy not only to accept mismatching RTP source
+            addresses (as it normally would), but also to accept them as
+            the new endpoint address of the opposite media flow. Not
+            recommended as it allows media streams to be hijacked by an
+            attacker.
+          + DTLS=... - influence the behaviour of DTLS-SRTP. Possible
+            values are "no" or "off" to suppress offering or accepting
+            DTLS-SRTP, and "passive" to prefer participating in DTLS-SRTP
+            in a passive role.
+          + SDES-off - don't offer SDES when it normally would. In an SRTP
+            context, this leaves DTLS-SRTP as the only other option.
+          + SDES-unencrypted_srtp, SDES-unencrypted_srtcp,
+            SDES-unauthenticated_srtp - these directly reflect the SDES
+            session parameters from RFC 4568 and will make the RTP proxy
+            offer these parameters when offering SDES.
+          + SDES-encrypted_srtp, SDES-encrypted_srtcp,
+            SDES-authenticated_srtp - the opposites of the flags above.
+            Useful if accepting these parameters is not desired and they
+            should be rejected instead.
+
+   This function can be used from ANY_ROUTE.
+
+   Example 1.12. rtpengine_offer usage
+route {
+...
+    if (is_method("INVITE")) {
+        if (has_body("application/sdp")) {
+            if (rtpengine_offer())
+                t_on_reply("1");
+        } else {
+            t_on_reply("2");
+        }
+    }
+    if (is_method("ACK") && has_body("application/sdp"))
+        rtpengine_answer();
+...
+}
+
+onreply_route[1]
+{
+...
+    if (has_body("application/sdp"))
+        rtpengine_answer();
+...
+}
+
+onreply_route[2]
+{
+...
+    if (has_body("application/sdp"))
+        rtpengine_offer();
+...
+}
+
+5.3. rtpengine_answer([flags])
+
+   Rewrites SDP body to ensure that media is passed through an RTP proxy.
+   To be invoked on 200 OK for the cases the SDP bodies are in INVITE and
+   200 OK and on ACK when SDP bodies are in 200 OK and ACK.
+
+   See rtpengine_offer() function description above for the meaning of the
+   parameters.
+
+   This function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,
+   FAILURE_ROUTE, BRANCH_ROUTE.
+
+   Example 1.13. rtpengine_answer usage
+
+   See rtpengine_offer() function example above for example.
+
+5.4. rtpengine_delete([flags])
+
+   Tears down the RTPProxy session for the current call.
+
+   See rtpengine_offer() function description above for the meaning of the
+   parameters. Note that not all flags make sense for a "delete".
+
+   This function can be used from ANY_ROUTE.
+
+   Example 1.14. rtpengine_delete usage
+...
+rtpengine_delete();
+...
+
+5.5. rtpengine_manage([flags])
+
+   Manage the RTPProxy session - it combines the functionality of
+   rtpengine_offer(), rtpengine_answer() and rtpengine_delete(), detecting
+   internally based on message type and method which one to execute.
+
+   It can take the same parameters as rtpengine_offer(). The flags
+   parameter to rtpengine_manage() can be a configuration variable
+   containing the flags as a string.
+
+   Functionality:
+     * If INVITE with SDP, then do rtpengine_offer()
+     * If INVITE with SDP, when the tm module is loaded, mark transaction
+       with internal flag FL_SDP_BODY to know that the 1xx and 2xx are for
+       rtpengine_answer()
+     * If ACK with SDP, then do rtpengine_answer()
+     * If BYE or CANCEL, or called within a FAILURE_ROUTE[], then do
+       rtpengine_delete()
+     * If reply to INVITE with code >= 300 do rtpengine_delete()
+     * If reply with SDP to INVITE having code 1xx and 2xx, then do
+       rtpengine_answer() if the request had SDP or tm is not loaded,
+       otherwise do rtpengine_offer()
+
+   This function can be used from ANY_ROUTE.
+
+   Example 1.15. rtpengine_manage usage
+...
+rtpengine_manage();
+...
+
+5.6. start_recording()
+
+   This function will send a signal to the RTP proxy to record the RTP
+   stream on the RTP proxy. This function is not supported by Sipwise
+   rtpengine at the moment!
+
+   This function can be used from REQUEST_ROUTE and ONREPLY_ROUTE.
+
+   Example 1.16. start_recording usage
+...
+start_recording();
+...
+
+6. Exported Pseudo Variables
+
+   6.1. $rtpstat
+
+6.1. $rtpstat
+
+   Returns the RTP statistics from the RTP proxy. The RTP statistics from
+   the RTP proxy are provided as a string and it does contain several
+   packet counters. The statistics must be retrieved before the session is
+   deleted (before rtpengine_delete()).
+
+   Example 1.17. $rtpstat Usage
+...
+    append_hf("X-RTP-Statistics: $rtpstat\r\n");
+...
+
+7. MI Commands
+
+   7.1. nh_enable_rtpp proxy_url/all 0/1
+   7.2. nh_show_rtpp proxy_url/all
+   7.3. nh_ping_rtpp proxy_url/all
+
+7.1. nh_enable_rtpp proxy_url/all 0/1
+
+   Enables a RTP proxy if the second parameter value is greater than 0.
+   Disables it if a zero value is given. The first parameter is either a
+   specific RTP proxy url (exactly as defined in the config file) or the
+   keyword all. The second parameter value must be a number in decimal.
+
+   When try to enable the RTP proxy, an application ping command is sent
+   to it. If it fails, the proxy is not enabled. Displays success or fail
+   when try to enable/disable.
+
+   NOTE: If a RTP proxy is defined multiple times (in the same or diferent
+   sets), all of its instances will be enabled/disabled.
+
+   NOTE: If a RTP proxy is in the disabled permanent state and one tries
+   to enable it, even if the ping fails, it is moved to a disabled
+   temporary state and a recheck_ticks are given to it. While the
+   recheck_ticks are grater than 0, the proxy is considered disabled
+   temporary, and it is not taken into consideration for sending data.
+   When the recheck_ticks are 0, the proxy is retested when trying to send
+   data(not automatically retested), and data can be send to it on
+   success.
+
+   NOTE: When specify the IPv6 RTP proxy url one must prefix it with :: to
+   escape the :: from the IPv6 address. See the example below.
+
+   Example 1.18. nh_enable_rtpp usage
+...
+$ kamctl fifo nh_enable_rtpp udp:192.168.2.133:8081 0
+$ kamctl fifo nh_enable_rtpp ::udp6:fe80::9a90:96ff:fea8:fd99:9999 1
+$ kamctl fifo nh_enable_rtpp all 1
+...
+
+7.2. nh_show_rtpp proxy_url/all
+
+   Displays all the RTP proxies and their information: set and status
+   (disabled or not, weight and recheck_ticks). If a RTP proxy has been
+   disabled by nh_enable_rtpp mi command a "(permanent)" quote will appear
+   when printing the disabled status. This is to differentiate from a
+   temporary disable due to the proxy being not found responsive by
+   kamailio. In addition, when disabled permanent, recheck_ticks have no
+   meaning and "N\A" is printed instead of the value.
+
+   It takes either a specific RTP proxy url (exactly as defined in the
+   config file) or the keyword all as a parameter.
+
+   NOTE: When specify the IPv6 RTP proxy url one must prefix it with :: to
+   escape the :: from the IPv6 address. See the example below.
+
+   Example 1.19. nh_show_rtpp usage
+...
+$ kamctl fifo nh_show_rtpp udp:192.168.2.133:8081
+$ kamctl fifo nh_show_rtpp ::udp6:fe80::9a90:96ff:fea8:fd99:9999
+$ kamctl fifo nh_show_rtpp all
+...
+
+7.3. nh_ping_rtpp proxy_url/all
+
+   Sends an application ping command to the RTP proxy. If the proxy does
+   not respond, it will be disabled, but not permanent. If the proxy
+   responds, no action is taken. Displays the ping result, i.e. success or
+   fail when try to ping.
+
+   It takes either a specific RTP proxy url (exactly as defined in the
+   config file) or the keyword all as a parameter.
+
+   NOTE: When specify the IPv6 RTP proxy url one must prefix it with :: to
+   escape the :: from the IPv6 address. See the example below.
+
+   Example 1.20. nh_ping_rtpp usage
+...
+$ kamctl fifo nh_ping_rtpp udp:192.168.2.133:8081
+$ kamctl fifo nh_ping_rtpp ::udp6:fe80::9a90:96ff:fea8:fd99:9999
+$ kamctl fifo nh_ping_rtpp all
+...
+
+Chapter 2. Frequently Asked Questions
+
+   2.1. How do I migrate from "rtpproxy" or "rtpproxy-ng" to "rtpengine"?
+   2.2. Where can I find more about Kamailio?
+   2.3. Where can I post a question about this module?
+   2.4. How can I report a bug?
+
+   2.1.
+
+   How do I migrate from "rtpproxy" or "rtpproxy-ng" to "rtpengine"?
+
+   For the most part, only the names of the functions have changed, with
+   "rtpproxy" in each name replaced with "rtpengine". For example,
+   "rtpproxy_manage()" has become "rtpengine_manage()". A few name
+   duplications have also been resolved, for example there is now a single
+   "rtpengine_delete()" instead of "unforce_rtp_proxy()" and the identical
+   "rtpproxy_destroy()".
+
+   The largest difference to the old module is how flags are passed to
+   "rtpengine_offer()", "rtpengine_answer()", "rtpengine_manage()" and
+   "rtpengine_delete()". Instead of having a string of single-letter
+   flags, they now take a string of space-separated items, with each item
+   being either a single token (word) or a "key=value" pair.
+
+   For example, if you had a call "rtpproxy_offer("FRWOC+PS");", this
+   would then become:
+rtpengine_offer("force trust-address symmetric replace-origin replace-session-co
+nnection ICE=force RTP/SAVPF");
+
+   Finally, if you were using the second paramater (explicit media
+   address) to any of these functions, this has been replaced by the
+   "media-address=..." option within the first string of flags.
+
+   2.2.
+
+   Where can I find more about Kamailio?
+
+   Take a look at http://www.kamailio.org/.
+
+   2.3.
+
+   Where can I post a question about this module?
+
+   First at all check if your question was already answered on one of our
+   mailing lists:
+     * User Mailing List -
+       http://lists.sip-router.org/cgi-bin/mailman/listinfo/sr-users
+     * Developer Mailing List -
+       http://lists.sip-router.org/cgi-bin/mailman/listinfo/sr-dev
+
+   E-mails regarding any stable Kamailio release should be sent to
+   <sr-users@lists.sip-router.org> and e-mails regarding development
+   versions should be sent to <sr-dev@lists.sip-router.org>.
+
+   If you want to keep the mail private, send it to
+   <sr-users@lists.sip-router.org>.
+
+   2.4.
+
+   How can I report a bug?
+
+   Please follow the guidelines provided at:
+   http://sip-router.org/tracker.
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/bencode.c ui-siprouter/modules/rtpengine/bencode.c
--- ui-siprouter~/modules/rtpengine/bencode.c	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/bencode.c	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,703 @@
+#include "bencode.h"
+#include <stdio.h>
+#include <sys/uio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <string.h>
+
+
+/* set to 0 for alloc debugging, e.g. through valgrind */
+#define BENCODE_MIN_BUFFER_PIECE_LEN	512
+
+#define BENCODE_HASH_BUCKETS		31 /* prime numbers work best */
+
+struct __bencode_buffer_piece {
+	char *tail;
+	unsigned int left;
+	struct __bencode_buffer_piece *next;
+	char buf[0];
+};
+struct __bencode_free_list {
+	void *ptr;
+	free_func_t func;
+	struct __bencode_free_list *next;
+};
+struct __bencode_hash {
+	struct bencode_item *buckets[BENCODE_HASH_BUCKETS];
+};
+
+
+
+
+
+static bencode_item_t __bencode_end_marker = {
+	.type = BENCODE_END_MARKER,
+	.iov[0].iov_base = "e",
+	.iov[0].iov_len = 1,
+	.iov_cnt = 1,
+	.str_len = 1,
+};
+
+
+
+
+static bencode_item_t *__bencode_decode(bencode_buffer_t *buf, const char *s, const char *end);
+
+
+
+static void __bencode_item_init(bencode_item_t *item) {
+	item->last_child = item->parent = item->child = item->sibling = NULL;
+}
+
+static void __bencode_container_init(bencode_item_t *cont) {
+	cont->iov[0].iov_len = 1;
+	cont->iov[1].iov_base = "e";
+	cont->iov[1].iov_len = 1;
+	cont->iov_cnt = 2;
+	cont->str_len = 2;
+}
+
+static void __bencode_dictionary_init(bencode_item_t *dict) {
+	dict->type = BENCODE_DICTIONARY;
+	dict->iov[0].iov_base = "d";
+	dict->value = 0;
+	__bencode_container_init(dict);
+}
+
+static void __bencode_list_init(bencode_item_t *list) {
+	list->type = BENCODE_LIST;
+	list->iov[0].iov_base = "l";
+	__bencode_container_init(list);
+}
+
+static struct __bencode_buffer_piece *__bencode_piece_new(unsigned int size) {
+	struct __bencode_buffer_piece *ret;
+
+	if (size < BENCODE_MIN_BUFFER_PIECE_LEN)
+		size = BENCODE_MIN_BUFFER_PIECE_LEN;
+	ret = BENCODE_MALLOC(sizeof(*ret) + size);
+	if (!ret)
+		return NULL;
+
+	ret->tail = ret->buf;
+	ret->left = size;
+	ret->next = NULL;
+
+	return ret;
+}
+
+int bencode_buffer_init(bencode_buffer_t *buf) {
+	buf->pieces = __bencode_piece_new(0);
+	if (!buf->pieces)
+		return -1;
+	buf->free_list = NULL;
+	buf->error = 0;
+	return 0;
+}
+
+static void *__bencode_alloc(bencode_buffer_t *buf, unsigned int size) {
+	struct __bencode_buffer_piece *piece;
+	void *ret;
+
+	if (!buf)
+		return NULL;
+	if (buf->error)
+		return NULL;
+
+	piece = buf->pieces;
+
+	if (size <= piece->left)
+		goto alloc;
+
+	piece = __bencode_piece_new(size);
+	if (!piece) {
+		buf->error = 1;
+		return NULL;
+	}
+	piece->next = buf->pieces;
+	buf->pieces = piece;
+
+	assert(size <= piece->left);
+
+alloc:
+	piece->left -= size;
+	ret = piece->tail;
+	piece->tail += size;
+	return ret;
+}
+
+void bencode_buffer_free(bencode_buffer_t *buf) {
+	struct __bencode_free_list *fl;
+	struct __bencode_buffer_piece *piece, *next;
+
+	for (fl = buf->free_list; fl; fl = fl->next)
+		fl->func(fl->ptr);
+
+	for (piece = buf->pieces; piece; piece = next) {
+		next = piece->next;
+		BENCODE_FREE(piece);
+	}
+}
+
+static bencode_item_t *__bencode_item_alloc(bencode_buffer_t *buf, unsigned int payload) {
+	bencode_item_t *ret;
+
+	ret = __bencode_alloc(buf, sizeof(struct bencode_item) + payload);
+	if (!ret)
+		return NULL;
+	ret->buffer = buf;
+	__bencode_item_init(ret);
+	return ret;
+}
+
+bencode_item_t *bencode_dictionary(bencode_buffer_t *buf) {
+	bencode_item_t *ret;
+
+	ret = __bencode_item_alloc(buf, 0);
+	if (!ret)
+		return NULL;
+	__bencode_dictionary_init(ret);
+	return ret;
+}
+
+bencode_item_t *bencode_list(bencode_buffer_t *buf) {
+	bencode_item_t *ret;
+
+	ret = __bencode_item_alloc(buf, 0);
+	if (!ret)
+		return NULL;
+	__bencode_list_init(ret);
+	return ret;
+}
+
+static void __bencode_container_add(bencode_item_t *parent, bencode_item_t *child) {
+	if (!parent)
+		return;
+	if (!child)
+		return;
+
+	assert(child->parent == NULL);
+	assert(child->sibling == NULL);
+
+	child->parent = parent;
+	if (parent->last_child)
+		parent->last_child->sibling = child;
+	parent->last_child = child;
+	if (!parent->child)
+		parent->child = child;
+
+	while (parent) {
+		parent->iov_cnt += child->iov_cnt;
+		parent->str_len += child->str_len;
+		parent = parent->parent;
+	}
+}
+
+static bencode_item_t *__bencode_string_alloc(bencode_buffer_t *buf, const void *base,
+		int str_len, int iov_len, int iov_cnt, bencode_type_t type)
+{
+	bencode_item_t *ret;
+	int len_len;
+
+	assert((str_len <= 99999) && (str_len >= 0));
+	ret = __bencode_item_alloc(buf, 7);
+	if (!ret)
+		return NULL;
+	len_len = sprintf(ret->__buf, "%d:", str_len);
+
+	ret->type = type;
+	ret->iov[0].iov_base = ret->__buf;
+	ret->iov[0].iov_len = len_len;
+	ret->iov[1].iov_base = (void *) base;
+	ret->iov[1].iov_len = iov_len;
+	ret->iov_cnt = iov_cnt + 1;
+	ret->str_len = len_len + str_len;
+
+	return ret;
+}
+
+bencode_item_t *bencode_string_len_dup(bencode_buffer_t *buf, const char *s, int len) {
+	char *sd = __bencode_alloc(buf, len);
+	if (!sd)
+		return NULL;
+	memcpy(sd, s, len);
+	return bencode_string_len(buf, sd, len);
+}
+
+bencode_item_t *bencode_string_len(bencode_buffer_t *buf, const char *s, int len) {
+	return __bencode_string_alloc(buf, s, len, len, 1, BENCODE_STRING);
+}
+
+bencode_item_t *bencode_string_iovec(bencode_buffer_t *buf, const struct iovec *iov, int iov_cnt, int str_len) {
+	int i;
+
+	if (iov_cnt < 0)
+		return NULL;
+	if (str_len < 0) {
+		str_len = 0;
+		for (i = 0; i < iov_cnt; i++)
+			str_len += iov[i].iov_len;
+	}
+
+	return __bencode_string_alloc(buf, iov, str_len, iov_cnt, iov_cnt, BENCODE_IOVEC);
+}
+
+bencode_item_t *bencode_integer(bencode_buffer_t *buf, long long int i) {
+	bencode_item_t *ret;
+	int alen, rlen;
+
+	alen = 8;
+	while (1) {
+		ret = __bencode_item_alloc(buf, alen + 3);
+		if (!ret)
+			return NULL;
+		rlen = snprintf(ret->__buf, alen, "i%llde", i);
+		if (rlen < alen)
+			break;
+		alen <<= 1;
+	}
+
+	ret->type = BENCODE_INTEGER;
+	ret->iov[0].iov_base = ret->__buf;
+	ret->iov[0].iov_len = rlen;
+	ret->iov[1].iov_base = NULL;
+	ret->iov[1].iov_len = 0;
+	ret->iov_cnt = 1;
+	ret->str_len = rlen;
+
+	return ret;
+}
+
+bencode_item_t *bencode_dictionary_add_len(bencode_item_t *dict, const char *key, int keylen, bencode_item_t *val) {
+	bencode_item_t *str;
+
+	if (!dict || !val)
+		return NULL;
+	assert(dict->type == BENCODE_DICTIONARY);
+
+	str = bencode_string_len(dict->buffer, key, keylen);
+	if (!str)
+		return NULL;
+	__bencode_container_add(dict, str);
+	__bencode_container_add(dict, val);
+	return val;
+}
+
+bencode_item_t *bencode_list_add(bencode_item_t *list, bencode_item_t *item) {
+	if (!list || !item)
+		return NULL;
+	assert(list->type == BENCODE_LIST);
+	__bencode_container_add(list, item);
+	return item;
+}
+
+static int __bencode_iovec_cpy(struct iovec *out, const struct iovec *in, int num) {
+	memcpy(out, in, num * sizeof(*out));
+	return num;
+}
+
+static int __bencode_str_cpy(char *out, const struct iovec *in, int num) {
+	char *orig = out;
+
+	while (--num >= 0) {
+		memcpy(out, in->iov_base, in->iov_len);
+		out += in->iov_len;
+		in++;
+	}
+	return out - orig;
+}
+
+static int __bencode_iovec_dump(struct iovec *out, bencode_item_t *item) {
+	bencode_item_t *child;
+	struct iovec *orig = out;
+
+	assert(item->iov[0].iov_base != NULL);
+	out += __bencode_iovec_cpy(out, &item->iov[0], 1);
+
+	child = item->child;
+	while (child) {
+		out += __bencode_iovec_dump(out, child);
+		child = child->sibling;
+	}
+
+	if (item->type == BENCODE_IOVEC)
+		out += __bencode_iovec_cpy(out, item->iov[1].iov_base, item->iov[1].iov_len);
+	else if (item->iov[1].iov_base)
+		out += __bencode_iovec_cpy(out, &item->iov[1], 1);
+
+	assert((out - orig) == item->iov_cnt);
+	return item->iov_cnt;
+}
+
+static int __bencode_str_dump(char *out, bencode_item_t *item) {
+	char *orig = out;
+	bencode_item_t *child;
+
+	assert(item->iov[0].iov_base != NULL);
+	out += __bencode_str_cpy(out, &item->iov[0], 1);
+
+	child = item->child;
+	while (child) {
+		out += __bencode_str_dump(out, child);
+		child = child->sibling;
+	}
+
+	if (item->type == BENCODE_IOVEC)
+		out += __bencode_str_cpy(out, item->iov[1].iov_base, item->iov[1].iov_len);
+	else if (item->iov[1].iov_base)
+		out += __bencode_str_cpy(out, &item->iov[1], 1);
+
+	assert((out - orig) == item->str_len);
+	*out = '\0';
+	return item->str_len;
+}
+
+struct iovec *bencode_iovec(bencode_item_t *root, int *cnt, unsigned int head, unsigned int tail) {
+	struct iovec *ret;
+
+	if (!root)
+		return NULL;
+	assert(cnt != NULL);
+	assert(root->iov_cnt > 0);
+
+	ret = __bencode_alloc(root->buffer, sizeof(*ret) * (root->iov_cnt + head + tail));
+	if (!ret)
+		return NULL;
+	*cnt = __bencode_iovec_dump(ret + head, root);
+	return ret;
+}
+
+char *bencode_collapse(bencode_item_t *root, int *len) {
+	char *ret;
+	int l;
+
+	if (!root)
+		return NULL;
+	assert(root->str_len > 0);
+
+	ret = __bencode_alloc(root->buffer, root->str_len + 1);
+	if (!ret)
+		return NULL;
+	l = __bencode_str_dump(ret, root);
+	if (len)
+		*len = l;
+	return ret;
+}
+
+char *bencode_collapse_dup(bencode_item_t *root, int *len) {
+	char *ret;
+	int l;
+
+	if (!root)
+		return NULL;
+	assert(root->str_len > 0);
+
+	ret = BENCODE_MALLOC(root->str_len + 1);
+	if (!ret)
+		return NULL;
+
+	l = __bencode_str_dump(ret, root);
+	if (len)
+		*len = l;
+	return ret;
+}
+
+static unsigned int __bencode_hash_str_len(const unsigned char *s, int len) {
+	unsigned long *ul;
+	unsigned int *ui;
+	unsigned short *us;
+
+	if (len >= sizeof(*ul)) {
+		ul = (void *) s;
+		return *ul % BENCODE_HASH_BUCKETS;
+	}
+	if (len >= sizeof(*ui)) {
+		ui = (void *) s;
+		return *ui % BENCODE_HASH_BUCKETS;
+	}
+	if (len >= sizeof(*us)) {
+		us = (void *) s;
+		return *us % BENCODE_HASH_BUCKETS;
+	}
+	if (len >= sizeof(*s))
+		return *s % BENCODE_HASH_BUCKETS;
+
+	return 0;
+}
+
+static unsigned int __bencode_hash_str(bencode_item_t *str) {
+	assert(str->type == BENCODE_STRING);
+	return __bencode_hash_str_len(str->iov[1].iov_base, str->iov[1].iov_len);
+}
+
+static void __bencode_hash_insert(bencode_item_t *key, struct __bencode_hash *hash) {
+	unsigned int bucket, i;
+
+	i = bucket = __bencode_hash_str(key);
+
+	while (1) {
+		if (!hash->buckets[i]) {
+			hash->buckets[i] = key;
+			break;
+		}
+		i++;
+		if (i >= BENCODE_HASH_BUCKETS)
+			i = 0;
+		if (i == bucket)
+			break;
+	}
+}
+
+static bencode_item_t *__bencode_decode_dictionary(bencode_buffer_t *buf, const char *s, const char *end) {
+	bencode_item_t *ret, *key, *value;
+	struct __bencode_hash *hash;
+
+	if (*s != 'd')
+		return NULL;
+	s++;
+
+	ret = __bencode_item_alloc(buf, sizeof(*hash));
+	if (!ret)
+		return NULL;
+	__bencode_dictionary_init(ret);
+	ret->value = 1;
+	hash = (void *) ret->__buf;
+	memset(hash, 0, sizeof(*hash));
+
+	while (s < end) {
+		key = __bencode_decode(buf, s, end);
+		if (!key)
+			return NULL;
+		s += key->str_len;
+		if (key->type == BENCODE_END_MARKER)
+			break;
+		if (key->type != BENCODE_STRING)
+			return NULL;
+		__bencode_container_add(ret, key);
+
+		if (s >= end)
+			return NULL;
+		value = __bencode_decode(buf, s, end);
+		if (!value)
+			return NULL;
+		s += value->str_len;
+		if (value->type == BENCODE_END_MARKER)
+			return NULL;
+		__bencode_container_add(ret, value);
+
+		__bencode_hash_insert(key, hash);
+	}
+
+	return ret;
+}
+
+static bencode_item_t *__bencode_decode_list(bencode_buffer_t *buf, const char *s, const char *end) {
+	bencode_item_t *ret, *item;
+
+	if (*s != 'l')
+		return NULL;
+	s++;
+
+	ret = __bencode_item_alloc(buf, 0);
+	if (!ret)
+		return NULL;
+	__bencode_list_init(ret);
+
+	while (s < end) {
+		item = __bencode_decode(buf, s, end);
+		if (!item)
+			return NULL;
+		s += item->str_len;
+		if (item->type == BENCODE_END_MARKER)
+			break;
+		__bencode_container_add(ret, item);
+	}
+
+	return ret;
+}
+
+static bencode_item_t *__bencode_decode_integer(bencode_buffer_t *buf, const char *s, const char *end) {
+	long long int i;
+	const char *orig = s;
+	char *convend;
+	bencode_item_t *ret;
+
+	if (*s != 'i')
+		return NULL;
+	s++;
+
+	if (s >= end)
+		return NULL;
+
+	if (*s == '0') {
+		i = 0;
+		s++;
+		goto done;
+	}
+
+	i = strtoll(s, &convend, 10);
+	if (convend == s)
+		return NULL;
+	s += (convend - s);
+
+done:
+	if (s >= end)
+		return NULL;
+	if (*s != 'e')
+		return NULL;
+	s++;
+
+	ret = __bencode_item_alloc(buf, 0);
+	if (!ret)
+		return NULL;
+	ret->type = BENCODE_INTEGER;
+	ret->iov[0].iov_base = (void *) orig;
+	ret->iov[0].iov_len = s - orig;
+	ret->iov[1].iov_base = NULL;
+	ret->iov[1].iov_len = 0;
+	ret->iov_cnt = 1;
+	ret->str_len = s - orig;
+	ret->value = i;
+
+	return ret;
+}
+
+static bencode_item_t *__bencode_decode_string(bencode_buffer_t *buf, const char *s, const char *end) {
+	unsigned long int sl;
+	char *convend;
+	const char *orig = s;
+	bencode_item_t *ret;
+
+	if (*s == '0') {
+		sl = 0;
+		s++;
+		goto colon;
+	}
+
+	sl = strtoul(s, &convend, 10);
+	if (convend == s)
+		return NULL;
+	s += (convend - s);
+
+colon:
+	if (s >= end)
+		return NULL;
+	if (*s != ':')
+		return NULL;
+	s++;
+
+	if (s + sl > end)
+		return NULL;
+
+	ret = __bencode_item_alloc(buf, 0);
+	if (!ret)
+		return NULL;
+	ret->type = BENCODE_STRING;
+	ret->iov[0].iov_base = (void *) orig;
+	ret->iov[0].iov_len = s - orig;
+	ret->iov[1].iov_base = (void *) s;
+	ret->iov[1].iov_len = sl;
+	ret->iov_cnt = 2;
+	ret->str_len = s - orig + sl;
+
+	return ret;
+}
+
+static bencode_item_t *__bencode_decode(bencode_buffer_t *buf, const char *s, const char *end) {
+	if (s >= end)
+		return NULL;
+
+	switch (*s) {
+		case 'd':
+			return __bencode_decode_dictionary(buf, s, end);
+		case 'l':
+			return __bencode_decode_list(buf, s, end);
+		case 'i':
+			return __bencode_decode_integer(buf, s, end);
+		case 'e':
+			return &__bencode_end_marker;
+		case '0':
+		case '1':
+		case '2':
+		case '3':
+		case '4':
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			return __bencode_decode_string(buf, s, end);
+		default:
+			return NULL;
+	}
+}
+
+bencode_item_t *bencode_decode(bencode_buffer_t *buf, const char *s, int len) {
+	assert(s != NULL);
+	return __bencode_decode(buf, s, s + len);
+}
+
+
+static int __bencode_dictionary_key_match(bencode_item_t *key, const char *keystr, int keylen) {
+	assert(key->type == BENCODE_STRING);
+
+	if (keylen != key->iov[1].iov_len)
+		return 0;
+	if (memcmp(keystr, key->iov[1].iov_base, keylen))
+		return 0;
+
+	return 1;
+}
+
+bencode_item_t *bencode_dictionary_get_len(bencode_item_t *dict, const char *keystr, int keylen) {
+	bencode_item_t *key;
+	unsigned int bucket, i;
+	struct __bencode_hash *hash;
+
+	if (!dict)
+		return NULL;
+	if (dict->type != BENCODE_DICTIONARY)
+		return NULL;
+
+	/* try hash lookup first if possible */
+	if (dict->value == 1) {
+		hash = (void *) dict->__buf;
+		i = bucket = __bencode_hash_str_len((const unsigned char *) keystr, keylen);
+		while (1) {
+			key = hash->buckets[i];
+			if (!key)
+				return NULL; /* would be there, but isn't */
+			assert(key->sibling != NULL);
+			if (__bencode_dictionary_key_match(key, keystr, keylen))
+				return key->sibling;
+			i++;
+			if (i >= BENCODE_HASH_BUCKETS)
+				i = 0;
+			if (i == bucket)
+				break; /* fall back to regular lookup */
+		}
+	}
+
+	for (key = dict->child; key; key = key->sibling->sibling) {
+		assert(key->sibling != NULL);
+		if (__bencode_dictionary_key_match(key, keystr, keylen))
+			return key->sibling;
+	}
+
+	return NULL;
+}
+
+void bencode_buffer_destroy_add(bencode_buffer_t *buf, free_func_t func, void *p) {
+	struct __bencode_free_list *li;
+
+	if (!p)
+		return;
+	li = __bencode_alloc(buf, sizeof(*li));
+	if (!li)
+		return;
+	li->ptr = p;
+	li->func = func;
+	li->next = buf->free_list;
+	buf->free_list = li;
+}
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/bencode.d ui-siprouter/modules/rtpengine/bencode.d
--- ui-siprouter~/modules/rtpengine/bencode.d	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/bencode.d	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,30 @@
+bencode.o: bencode.c bencode.h ../../mem/mem.h ../../mem/../config.h \
+ ../../mem/../types.h ../../mem/../dprint.h ../../mem/../compiler_opt.h \
+ ../../mem/../cfg_core.h ../../mem/../cfg/cfg.h ../../mem/../cfg/../str.h \
+ ../../mem/q_malloc.h ../../mem/meminfo.h ../../mem/src_loc.h ../../str.h
+
+bencode.h:
+
+../../mem/mem.h:
+
+../../mem/../config.h:
+
+../../mem/../types.h:
+
+../../mem/../dprint.h:
+
+../../mem/../compiler_opt.h:
+
+../../mem/../cfg_core.h:
+
+../../mem/../cfg/cfg.h:
+
+../../mem/../cfg/../str.h:
+
+../../mem/q_malloc.h:
+
+../../mem/meminfo.h:
+
+../../mem/src_loc.h:
+
+../../str.h:
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/bencode.h ui-siprouter/modules/rtpengine/bencode.h
--- ui-siprouter~/modules/rtpengine/bencode.h	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/bencode.h	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,561 @@
+#ifndef _BENCODE_H_
+#define _BENCODE_H_
+
+#include <sys/uio.h>
+#include <string.h>
+
+#if defined(SHM_MEM) || defined(PKG_MALLOC) || defined(pkg_malloc)
+/* kamailio */
+# include "../../mem/mem.h"
+# include "../../str.h"
+# ifndef BENCODE_MALLOC
+# define BENCODE_MALLOC pkg_malloc
+# define BENCODE_FREE pkg_free
+# endif
+# define INLINE static inline
+#else
+/* rtpengine */
+# include "compat.h"
+# include "str.h"
+# ifndef BENCODE_MALLOC
+# define BENCODE_MALLOC malloc
+# define BENCODE_FREE free
+# endif
+#endif
+
+struct bencode_buffer;
+enum bencode_type;
+struct bencode_item;
+struct __bencode_buffer_piece;
+struct __bencode_free_list;
+
+typedef enum bencode_type bencode_type_t;
+typedef struct bencode_buffer bencode_buffer_t;
+typedef struct bencode_item bencode_item_t;
+typedef void (*free_func_t)(void *);
+
+enum bencode_type {
+	BENCODE_INVALID = 0,
+	BENCODE_STRING,		/* byte string */
+	BENCODE_INTEGER,	/* long long int */
+	BENCODE_LIST,		/* flat list of other objects */
+	BENCODE_DICTIONARY,	/* dictionary of key/values pairs. keys are always strings */
+	BENCODE_IOVEC,		/* special case of a string, built through bencode_string_iovec() */
+	BENCODE_END_MARKER,	/* used internally only */
+};
+
+struct bencode_item {
+	bencode_type_t type;
+	struct iovec iov[2];	/* when decoding, iov[1] contains the contents of a string object */
+	unsigned int iov_cnt;
+	unsigned int str_len;	/* length of the whole ENCODED object. NOT the length of a byte string */
+	long long int value;	/* when decoding an integer, contains the value; otherwise used internally */
+	bencode_item_t *parent, *child, *last_child, *sibling;
+	bencode_buffer_t *buffer;
+	char __buf[0];
+};
+
+struct bencode_buffer {
+	struct __bencode_buffer_piece *pieces;
+	struct __bencode_free_list *free_list;
+	int error:1;		/* set to !0 if allocation failed at any point */
+};
+
+
+
+
+
+/* to embed BENCODE_STRING objects into printf-like functions */
+#define BENCODE_FORMAT "%.*s"
+#define BENCODE_FMT(b) (int) (b)->iov[1].iov_len, (char *) (b)->iov[1].iov_base
+
+
+
+
+/*** INIT & DESTROY ***/
+
+/* Initializes a bencode_buffer_t object. This object is used to group together all memory allocations
+ * made when encoding or decoding. Its memory usage is always growing, until it is freed, at which point
+ * all objects created through it become invalid. The actual object must be allocated separately, for
+ * example by being put on the stack.
+ * Returns 0 on success or -1 on failure (if no memory could be allocated). */
+int bencode_buffer_init(bencode_buffer_t *buf);
+
+/* Allocate a piece of memory from the given buffer object */
+void *bencode_buffer_alloc(bencode_buffer_t *, unsigned int);
+
+/* Destroys a previously initialized bencode_buffer_t object. All memory used by the object is freed
+ * and all objects created through it become invalid. */
+void bencode_buffer_free(bencode_buffer_t *buf);
+
+/* Creates a new empty dictionary object. Memory will be allocated from the bencode_buffer_t object.
+ * Returns NULL if no memory could be allocated. */
+bencode_item_t *bencode_dictionary(bencode_buffer_t *buf);
+
+/* Creates a new empty list object. Memory will be allocated from the bencode_buffer_t object.
+ * Returns NULL if no memory could be allocated. */
+bencode_item_t *bencode_list(bencode_buffer_t *buf);
+
+/* Adds a pointer to the bencode_buffer_t object's internal free list. When the bencode_buffer_t
+ * object is destroyed, the specified function will be called on this pointer. */
+void bencode_buffer_destroy_add(bencode_buffer_t *buf, free_func_t, void *);
+
+/* Returns the buffer associated with an item, or NULL if pointer given is NULL */
+INLINE bencode_buffer_t *bencode_item_buffer(bencode_item_t *);
+
+
+
+
+
+/*** DICTIONARY BUILDING ***/
+
+/* Adds a new key/value pair to a dictionary. Memory will be allocated from the same bencode_buffer_t
+ * object as the dictionary was allocated from. Returns NULL if no memory could be allocated, otherwise
+ * returns "val".
+ * The function does not check whether the key being added is already present in the dictionary.
+ * Also, the function does not reorder keys into lexicographical order; keys will be encoded in
+ * the same order as they've been added. The key must a null-terminated string.
+ * The value to be added must not have been previously linked into any other dictionary or list. */
+INLINE bencode_item_t *bencode_dictionary_add(bencode_item_t *dict, const char *key, bencode_item_t *val);
+INLINE bencode_item_t *bencode_dictionary_str_add(bencode_item_t *dict, const str *key, bencode_item_t *val);
+
+/* Identical to bencode_dictionary_add() but doesn't require the key string to be null-terminated */
+bencode_item_t *bencode_dictionary_add_len(bencode_item_t *dict, const char *key, int keylen, bencode_item_t *val);
+
+/* Convenience function to add a string value to a dictionary, possibly duplicated into the
+ * bencode_buffer_t object. */
+INLINE bencode_item_t *bencode_dictionary_add_string(bencode_item_t *dict, const char *key, const char *val);
+INLINE bencode_item_t *bencode_dictionary_add_string_dup(bencode_item_t *dict, const char *key, const char *val);
+
+/* Ditto, but for a "str" object */
+INLINE bencode_item_t *bencode_dictionary_add_str(bencode_item_t *dict, const char *key, const str *val);
+INLINE bencode_item_t *bencode_dictionary_str_add_str(bencode_item_t *dict, const str *key, const str *val);
+INLINE bencode_item_t *bencode_dictionary_add_str_dup(bencode_item_t *dict, const char *key, const str *val);
+
+/* Ditto, but adds a string created through an iovec array to the dictionary. See
+ * bencode_string_iovec(). */
+INLINE bencode_item_t *bencode_dictionary_add_iovec(bencode_item_t *dict, const char *key,
+	const struct iovec *iov, int iov_cnt, int str_len);
+
+/* Convenience functions to add the respective (newly created) objects to a dictionary */
+INLINE bencode_item_t *bencode_dictionary_add_integer(bencode_item_t *dict, const char *key, long long int val);
+INLINE bencode_item_t *bencode_dictionary_add_dictionary(bencode_item_t *dict, const char *key);
+INLINE bencode_item_t *bencode_dictionary_add_list(bencode_item_t *dict, const char *key);
+
+
+
+
+
+/*** LIST BUILDING ***/
+
+/* Adds a new item to a list. Returns "item".
+ * The item to be added must not have been previously linked into any other dictionary or list. */
+bencode_item_t *bencode_list_add(bencode_item_t *list, bencode_item_t *item);
+
+/* Convenience function to add the respective (newly created) objects to a list */
+INLINE bencode_item_t *bencode_list_add_string(bencode_item_t *list, const char *s);
+INLINE bencode_item_t *bencode_list_add_str(bencode_item_t *list, const str *s);
+INLINE bencode_item_t *bencode_list_add_list(bencode_item_t *list);
+INLINE bencode_item_t *bencode_list_add_dictionary(bencode_item_t *list);
+
+
+
+
+
+/*** STRING BUILDING & HANDLING ***/
+
+/* Creates a new byte-string object. The given string does not have to be null-terminated, instead
+ * the length of the string is specified by the "len" parameter. Returns NULL if no memory could
+ * be allocated.
+ * Strings are not copied or duplicated, so the string pointed to by "s" must remain valid until
+ * the complete document is finally encoded or sent out. */
+bencode_item_t *bencode_string_len(bencode_buffer_t *buf, const char *s, int len);
+
+/* Creates a new byte-string object. The given string must be null-terminated. Otherwise identical
+ * to bencode_string_len(). */
+INLINE bencode_item_t *bencode_string(bencode_buffer_t *buf, const char *s);
+
+/* Creates a new byte-string object from a "str" object. The string does not have to be null-
+ * terminated. */
+INLINE bencode_item_t *bencode_str(bencode_buffer_t *buf, const str *s);
+
+/* Identical to the above three functions, but copies the string into the bencode_buffer_t object.
+ * Thus, the given string doesn't have to remain valid and accessible afterwards. */
+bencode_item_t *bencode_string_len_dup(bencode_buffer_t *buf, const char *s, int len);
+INLINE bencode_item_t *bencode_string_dup(bencode_buffer_t *buf, const char *s);
+INLINE bencode_item_t *bencode_str_dup(bencode_buffer_t *buf, const str *s);
+
+/* Creates a new byte-string object from an iovec array. The created object has different internal
+ * semantics (not a BENCODE_STRING, but a BENCODE_IOVEC) and must not be treated like other string
+ * objects. The array pointer and contents must still be valid and accessible when the complete
+ * document is encoded. The full length of the string composed of the iovec array is given in the
+ * "str_len" parameter, which can be negative, in which case the array is iterated to calculate the
+ * length. */
+bencode_item_t *bencode_string_iovec(bencode_buffer_t *buf, const struct iovec *iov, int iov_cnt, int str_len);
+
+/* Convenience function to compare a string object to a regular C string. Returns 2 if object
+ * isn't a string object, otherwise returns according to strcmp(). */
+INLINE int bencode_strcmp(bencode_item_t *a, const char *b);
+
+/* Converts the string object "in" into a str object "out". Returns "out" on success, or NULL on
+ * error ("in" was NULL or not a string object). */
+INLINE str *bencode_get_str(bencode_item_t *in, str *out);
+
+
+
+
+
+/*** INTEGER BUILDING ***/
+
+/* Creates a new integer object. Returns NULL if no memory could be allocated. */
+bencode_item_t *bencode_integer(bencode_buffer_t *buf, long long int i);
+
+
+
+
+
+/*** COLLAPSING & ENCODING ***/
+
+/* Collapses and encodes the complete document structure under the "root" element (which normally
+ * is either a dictionary or a list) into an array of "iovec" structures. This array can then be
+ * passed to functions ala writev() or sendmsg() to output the encoded document as a whole. Memory
+ * is allocated from the same bencode_buffer_t object as the "root" object was allocated from.
+ * The "head" and "tail" parameters specify additional "iovec" structures that should be included
+ * in the allocated array before or after (respectively) the iovec structures used by the encoded
+ * document. Both parameters can be zero if no additional elements in the array are required.
+ * Returns a pointer to the allocated array or NULL if no memory could be allocated. The number of
+ * array elements is returned in "cnt" which must be a valid pointer to an int. This number does
+ * not include any additional elements allocated through the "head" or "tail" parameters.
+ *
+ * Therefore, the contents of the returned array are:
+ * [0 .. (head - 1)]                         = unused and uninitialized iovec structures
+ * [(head) .. (head + cnt - 1)]              = the encoded document
+ * [(head + cnt) .. (head + cnt + tail - 1)] = unused and uninitialized iovec structures
+ *
+ * The returned array will be freed when the corresponding bencode_buffer_t object is destroyed. */
+struct iovec *bencode_iovec(bencode_item_t *root, int *cnt, unsigned int head, unsigned int tail);
+
+/* Similar to bencode_iovec(), but instead returns the encoded document as a null-terminated string.
+ * Memory for the string is allocated from the same bencode_buffer_t object as the "root" object
+ * was allocated from. If "len" is a non-NULL pointer, the length of the genrated string is returned
+ * in *len. This is important if the encoded document contains binary data, in which case null
+ * termination cannot be trusted. The returned string is freed when the corresponding
+ * bencode_buffer_t object is destroyed. */
+char *bencode_collapse(bencode_item_t *root, int *len);
+
+/* Identical to bencode_collapse() but fills in a "str" object. Returns "out". */
+static str *bencode_collapse_str(bencode_item_t *root, str *out);
+
+/* Identical to bencode_collapse(), but the memory for the returned string is not allocated from
+ * a bencode_buffer_t object, but instead using the function defined as BENCODE_MALLOC (normally
+ * malloc() or pkg_malloc()), similar to strdup(). Using this function, the bencode_buffer_t
+ * object can be destroyed, but the returned string remains valid and usable. */
+char *bencode_collapse_dup(bencode_item_t *root, int *len);
+
+
+
+
+
+/*** DECODING ***/
+
+/* Decodes an encoded document from a string into a tree of bencode_item_t objects. The string does
+ * not need to be null-terminated, instead the length of the string is given through the "len"
+ * parameter. Memory is allocated from the bencode_buffer_t object. Returns NULL if no memory could
+ * be allocated or if the document could not be successfully decoded.
+ *
+ * The returned element is the "root" of the document tree and normally is either a list object or
+ * a dictionary object, but can also be a single string or integer object with no other objects
+ * underneath or besides it (no childred and no siblings). The type of the object can be determined
+ * by its ->type property.
+ *
+ * The number of bytes that could successfully be decoded into an object tree can be accessed through
+ * the root element's ->str_len property. Normally, this number should be equal to the "len" parameter
+ * passed, in which case the full string could be decoded. If ->str_len is less than "len", then there
+ * was additional stray byte data after the end of the encoded document.
+ *
+ * The document tree can be traversed through the ->child and ->sibling pointers in each object. The
+ * ->child pointer will be NULL for string and integer objects, as they don't contain other objects.
+ * For lists and dictionaries, ->child will be a pointer to the first contained object. This first
+ * contained object's ->sibling pointer will point to the next (second) contained object of the list
+ * or the dictionary, and so on. The last contained element of a list of dictionary will have a
+ * NULL ->sibling pointer.
+ *
+ * Dictionaries are like lists with ordered key/value pairs. When traversing dictionaries like
+ * lists, the following applies: The first element in the list (where ->child points to) will be the
+ * key of the first key/value pair (guaranteed to be a string and guaranteed to be present). The
+ * next element (following one ->sibling) will be the value of the first key/value pair. Following
+ * another ->sibling will point to the key of the next (second) key/value pair, and so on.
+ *
+ * However, to access children objects of dictionaries, the special functions following the naming
+ * scheme bencode_dictionary_get_* below should be used. They perform key lookup through a simple
+ * hash built into the dictionary object and so perform the lookup much faster. Only dictionaries
+ * created through a decoding process (i.e. not ones created from bencode_dictionary()) have this
+ * property. The hash is efficient only up to a certain number of elements (BENCODE_HASH_BUCKETS
+ * in bencode.c) contained in the dictionary. If the number of children object exceeds this number,
+ * key lookup will be slower than simply linearily traversing the list.
+ *
+ * The decoding function for dictionary object does not check whether keys are unique within the
+ * dictionary. It also does not care about lexicographical order of the keys.
+ *
+ * Decoded string objects will contain the raw decoded byte string in ->iov[1] (including the correct
+ * length). Strings are NOT null-terminated. Decoded integer objects will contain the decoded value
+ * in ->value.
+ *
+ * All memory is freed when the bencode_buffer_t object is destroyed.
+ */
+bencode_item_t *bencode_decode(bencode_buffer_t *buf, const char *s, int len);
+
+/* Identical to bencode_decode(), but returns successfully only if the type of the decoded object match
+ * "expect". */
+INLINE bencode_item_t *bencode_decode_expect(bencode_buffer_t *buf, const char *s, int len, bencode_type_t expect);
+
+/* Identical to bencode_decode_expect() but takes a "str" argument. */
+INLINE bencode_item_t *bencode_decode_expect_str(bencode_buffer_t *buf, const str *s, bencode_type_t expect);
+
+
+
+
+
+/*** DICTIONARY LOOKUP & EXTRACTION ***/
+
+/* Searches the given dictionary object for the given key and returns the respective value. Returns
+ * NULL if the given object isn't a dictionary or if the key doesn't exist. The key must be a
+ * null-terminated string. */
+INLINE bencode_item_t *bencode_dictionary_get(bencode_item_t *dict, const char *key);
+
+/* Identical to bencode_dictionary_get() but doesn't require the key to be null-terminated. */
+bencode_item_t *bencode_dictionary_get_len(bencode_item_t *dict, const char *key, int key_len);
+
+/* Identical to bencode_dictionary_get() but returns the value only if its type is a string, and
+ * returns it as a pointer to the string itself. Returns NULL if the value is of some other type. The
+ * returned string is NOT null-terminated. Length of the string is returned in *len, which must be a
+ * valid pointer. The returned string will be valid until dict's bencode_buffer_t object is destroyed. */
+INLINE char *bencode_dictionary_get_string(bencode_item_t *dict, const char *key, int *len);
+
+/* Identical to bencode_dictionary_get_string() but fills in a "str" struct. Returns str->s, which
+ * may be NULL. */
+INLINE char *bencode_dictionary_get_str(bencode_item_t *dict, const char *key, str *str);
+
+/* Looks up the given key in the dictionary and compares the corresponding value to the given
+ * null-terminated string. Returns 2 if the key isn't found or if the value isn't a string, otherwise
+ * returns according to strcmp(). */
+INLINE int bencode_dictionary_get_strcmp(bencode_item_t *dict, const char *key, const char *str);
+
+/* Identical to bencode_dictionary_get() but returns the string in a newly allocated buffer (using the
+ * BENCODE_MALLOC function), which remains valid even after bencode_buffer_t is destroyed. */
+INLINE char *bencode_dictionary_get_string_dup(bencode_item_t *dict, const char *key, int *len);
+
+/* Combines bencode_dictionary_get_str() and bencode_dictionary_get_string_dup(). Fills in a "str"
+ * struct, but copies the string into a newly allocated buffer. Returns str->s. */
+INLINE char *bencode_dictionary_get_str_dup(bencode_item_t *dict, const char *key, str *str);
+
+/* Identical to bencode_dictionary_get_string() but expects an integer object. The parameter "defval"
+ * specified which value should be returned if the key is not found or if the value is not an integer. */
+INLINE long long int bencode_dictionary_get_integer(bencode_item_t *dict, const char *key, long long int defval);
+
+/* Identical to bencode_dictionary_get(), but returns the object only if its type matches "expect". */
+INLINE bencode_item_t *bencode_dictionary_get_expect(bencode_item_t *dict, const char *key, bencode_type_t expect);
+
+
+
+
+
+/**************************/
+
+INLINE bencode_buffer_t *bencode_item_buffer(bencode_item_t *i) {
+	if (!i)
+		return NULL;
+	return i->buffer;
+}
+
+INLINE bencode_item_t *bencode_string(bencode_buffer_t *buf, const char *s) {
+	return bencode_string_len(buf, s, strlen(s));
+}
+
+INLINE bencode_item_t *bencode_string_dup(bencode_buffer_t *buf, const char *s) {
+	return bencode_string_len_dup(buf, s, strlen(s));
+}
+
+INLINE bencode_item_t *bencode_str(bencode_buffer_t *buf, const str *s) {
+	return bencode_string_len(buf, s->s, s->len);
+}
+
+INLINE bencode_item_t *bencode_str_dup(bencode_buffer_t *buf, const str *s) {
+	return bencode_string_len_dup(buf, s->s, s->len);
+}
+
+INLINE bencode_item_t *bencode_dictionary_add(bencode_item_t *dict, const char *key, bencode_item_t *val) {
+	if (!key)
+		return NULL;
+	return bencode_dictionary_add_len(dict, key, strlen(key), val);
+}
+
+INLINE bencode_item_t *bencode_dictionary_str_add(bencode_item_t *dict, const str *key, bencode_item_t *val) {
+	if (!key)
+		return NULL;
+	return bencode_dictionary_add_len(dict, key->s, key->len, val);
+}
+
+INLINE bencode_item_t *bencode_dictionary_add_string(bencode_item_t *dict, const char *key, const char *val) {
+	if (!val)
+		return NULL;
+	return bencode_dictionary_add(dict, key, bencode_string(bencode_item_buffer(dict), val));
+}
+
+INLINE bencode_item_t *bencode_dictionary_add_string_dup(bencode_item_t *dict, const char *key, const char *val) {
+	if (!val)
+		return NULL;
+	return bencode_dictionary_add(dict, key, bencode_string_dup(bencode_item_buffer(dict), val));
+}
+
+INLINE bencode_item_t *bencode_dictionary_add_str(bencode_item_t *dict, const char *key, const str *val) {
+	if (!val)
+		return NULL;
+	return bencode_dictionary_add(dict, key, bencode_str(bencode_item_buffer(dict), val));
+}
+
+INLINE bencode_item_t *bencode_dictionary_str_add_str(bencode_item_t *dict, const str *key, const str *val) {
+	if (!val)
+		return NULL;
+	return bencode_dictionary_str_add(dict, key, bencode_str(bencode_item_buffer(dict), val));
+}
+
+INLINE bencode_item_t *bencode_dictionary_add_str_dup(bencode_item_t *dict, const char *key, const str *val) {
+	if (!val)
+		return NULL;
+	return bencode_dictionary_add(dict, key, bencode_str_dup(bencode_item_buffer(dict), val));
+}
+
+INLINE bencode_item_t *bencode_dictionary_add_integer(bencode_item_t *dict, const char *key, long long int val) {
+	return bencode_dictionary_add(dict, key, bencode_integer(bencode_item_buffer(dict), val));
+}
+
+INLINE bencode_item_t *bencode_dictionary_add_dictionary(bencode_item_t *dict, const char *key) {
+	return bencode_dictionary_add(dict, key, bencode_dictionary(bencode_item_buffer(dict)));
+}
+
+INLINE bencode_item_t *bencode_dictionary_add_list(bencode_item_t *dict, const char *key) {
+	return bencode_dictionary_add(dict, key, bencode_list(bencode_item_buffer(dict)));
+}
+
+INLINE bencode_item_t *bencode_list_add_string(bencode_item_t *list, const char *s) {
+	return bencode_list_add(list, bencode_string(bencode_item_buffer(list), s));
+}
+
+INLINE bencode_item_t *bencode_list_add_str(bencode_item_t *list, const str *s) {
+	return bencode_list_add(list, bencode_str(bencode_item_buffer(list), s));
+}
+
+INLINE bencode_item_t *bencode_list_add_list(bencode_item_t *list) {
+	return bencode_list_add(list, bencode_list(bencode_item_buffer(list)));
+}
+
+INLINE bencode_item_t *bencode_list_add_dictionary(bencode_item_t *list) {
+	return bencode_list_add(list, bencode_dictionary(bencode_item_buffer(list)));
+}
+
+INLINE bencode_item_t *bencode_dictionary_get(bencode_item_t *dict, const char *key) {
+	if (!key)
+		return NULL;
+	return bencode_dictionary_get_len(dict, key, strlen(key));
+}
+
+INLINE char *bencode_dictionary_get_string(bencode_item_t *dict, const char *key, int *len) {
+	bencode_item_t *val;
+	val = bencode_dictionary_get(dict, key);
+	if (!val || val->type != BENCODE_STRING)
+		return NULL;
+	*len = val->iov[1].iov_len;
+	return val->iov[1].iov_base;
+}
+
+INLINE char *bencode_dictionary_get_str(bencode_item_t *dict, const char *key, str *str) {
+	str->s = bencode_dictionary_get_string(dict, key, &str->len);
+	if (!str->s)
+		str->len = 0;
+	return str->s;
+}
+
+INLINE char *bencode_dictionary_get_string_dup(bencode_item_t *dict, const char *key, int *len) {
+	const char *s;
+	char *ret;
+	s = bencode_dictionary_get_string(dict, key, len);
+	if (!s)
+		return NULL;
+	ret = BENCODE_MALLOC(*len);
+	if (!ret)
+		return NULL;
+	memcpy(ret, s, *len);
+	return ret;
+}
+
+INLINE char *bencode_dictionary_get_str_dup(bencode_item_t *dict, const char *key, str *str) {
+	str->s = bencode_dictionary_get_string_dup(dict, key, &str->len);
+	return str->s;
+}
+
+INLINE long long int bencode_dictionary_get_integer(bencode_item_t *dict, const char *key, long long int defval) {
+	bencode_item_t *val;
+	val = bencode_dictionary_get(dict, key);
+	if (!val || val->type != BENCODE_INTEGER)
+		return defval;
+	return val->value;
+}
+
+INLINE bencode_item_t *bencode_decode_expect(bencode_buffer_t *buf, const char *s, int len, bencode_type_t expect) {
+	bencode_item_t *ret;
+	ret = bencode_decode(buf, s, len);
+	if (!ret || ret->type != expect)
+		return NULL;
+	return ret;
+}
+
+INLINE bencode_item_t *bencode_decode_expect_str(bencode_buffer_t *buf, const str *s, bencode_type_t expect) {
+	return bencode_decode_expect(buf, s->s, s->len, expect);
+}
+
+INLINE bencode_item_t *bencode_dictionary_get_expect(bencode_item_t *dict, const char *key, bencode_type_t expect) {
+	bencode_item_t *ret;
+	ret = bencode_dictionary_get(dict, key);
+	if (!ret || ret->type != expect)
+		return NULL;
+	return ret;
+}
+INLINE str *bencode_collapse_str(bencode_item_t *root, str *out) {
+	out->s = bencode_collapse(root, &out->len);
+	return out;
+}
+INLINE int bencode_strcmp(bencode_item_t *a, const char *b) {
+	int len;
+	if (a->type != BENCODE_STRING)
+		return 2;
+	len = strlen(b);
+	if (a->iov[1].iov_len < len)
+		return -1;
+	if (a->iov[1].iov_len > len)
+		return 1;
+	return memcmp(a->iov[1].iov_base, b, len);
+}
+INLINE int bencode_dictionary_get_strcmp(bencode_item_t *dict, const char *key, const char *str) {
+	bencode_item_t *i;
+	i = bencode_dictionary_get(dict, key);
+	if (!i)
+		return 2;
+	return bencode_strcmp(i, str);
+}
+
+INLINE str *bencode_get_str(bencode_item_t *in, str *out) {
+	if (!in || in->type != BENCODE_STRING)
+		return NULL;
+	out->s = in->iov[1].iov_base;
+	out->len = in->iov[1].iov_len;
+	return out;
+}
+
+INLINE bencode_item_t *bencode_dictionary_add_iovec(bencode_item_t *dict, const char *key,
+		const struct iovec *iov, int iov_cnt, int str_len)
+{
+	return bencode_dictionary_add(dict, key, bencode_string_iovec(bencode_item_buffer(dict), iov, iov_cnt, str_len));
+}
+
+#endif
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/doc/Makefile ui-siprouter/modules/rtpengine/doc/Makefile
--- ui-siprouter~/modules/rtpengine/doc/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/doc/Makefile	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,4 @@
+docs = rtpengine.xml
+
+docbook_dir = ../../../docbook
+include $(docbook_dir)/Makefile.module
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/doc/rtpengine.d ui-siprouter/modules/rtpengine/doc/rtpengine.d
--- ui-siprouter~/modules/rtpengine/doc/rtpengine.d	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/doc/rtpengine.d	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1 @@
+rtpengine.d:$(wildcard  rtpengine_admin.xml rtpengine_faq.xml )
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/doc/rtpengine.xml ui-siprouter/modules/rtpengine/doc/rtpengine.xml
--- ui-siprouter~/modules/rtpengine/doc/rtpengine.xml	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/doc/rtpengine.xml	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,103 @@
+<?xml version="1.0" encoding='ISO-8859-1'?>
+<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
+"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
+
+<!-- Include general documentation entities -->
+<!ENTITY % docentities SYSTEM "../../../docbook/entities.xml">
+%docentities;
+
+]>
+
+<book xmlns:xi="http://www.w3.org/2001/XInclude">
+	<bookinfo>
+	<title>rtpengine Module</title>
+	<productname class="trade">&kamailioname;</productname>
+	<authorgroup>
+		<author>
+		<firstname>Maxim</firstname>
+		<surname>Sobolev</surname>
+		<affiliation><orgname>Sippy Software, Inc.</orgname></affiliation>
+		<address>
+			<email>sobomax@sippysoft.com</email>
+		</address>
+		</author>
+		<author>
+		<firstname>Juha</firstname>
+		<surname>Heinanen</surname>
+		<affiliation><orgname>TuTPro, Inc.</orgname></affiliation>
+		<address>
+			<email>jh@tutpro.com</email>
+		</address>
+		</author>
+		<editor>
+		<firstname>Maxim</firstname>
+		<surname>Sobolev</surname>
+		<address>
+			<email>sobomax@sippysoft.com</email>
+		</address>
+		</editor>
+		<editor>
+		<firstname>Bogdan-Andrei</firstname>
+		<surname>Iancu</surname>
+		<address>
+			<email>bogdan@voice-system.ro</email>
+		</address>
+		</editor>
+		<editor>
+		<firstname>Juha</firstname>
+		<surname>Heinanen</surname>
+		<address>
+			<email>jh@tutpro.com</email>
+		</address>
+		</editor>
+		<editor>
+		<firstname>Sas</firstname>
+		<surname>Ovidiu</surname>
+		<address>
+			<email>osas@voipembedded.com</email>
+		</address>
+		</editor>
+		<editor>
+		<firstname>Carsten</firstname>
+		<surname>Bock</surname>
+		<affiliation><orgname>ng-voice GmbH</orgname></affiliation>
+		<address>
+			<email>carsten@ng-voice.com</email>
+		</address>
+		</editor>
+		<editor>
+		<firstname>Richard</firstname>
+		<surname>Fuchs</surname>
+		<affiliation><orgname>Sipwise GmbH</orgname></affiliation>
+		<address>
+			<email>rfuchs@sipwise.com</email>
+		</address>
+		</editor>
+	</authorgroup>
+	<copyright>
+		<year>2003-2008</year>
+		<holder>Sippy Software, Inc.</holder>
+	</copyright>
+	<copyright>
+		<year>2005</year>
+		<holder>Voice Sistem SRL</holder>
+	</copyright>
+	<copyright>
+		<year>2009-2014</year>
+		<holder>TuTPro Inc.</holder>
+	</copyright>
+	<copyright>
+		<year>2010</year>
+		<holder><ulink url='http://www.voipembedded.com'>VoIPEmbedded Inc.</ulink></holder>
+	</copyright>
+	<copyright>
+		<year>2013-2015</year>
+		<holder>Sipwise GmbH</holder>
+	</copyright>
+	</bookinfo>
+	<toc></toc>
+
+	<xi:include href="rtpengine_admin.xml"/>
+	<xi:include href="rtpengine_faq.xml"/>
+
+</book>
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/doc/rtpengine_admin.xml ui-siprouter/modules/rtpengine/doc/rtpengine_admin.xml
--- ui-siprouter~/modules/rtpengine/doc/rtpengine_admin.xml	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/doc/rtpengine_admin.xml	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,1304 @@
+<?xml version="1.0" encoding='ISO-8859-1'?>
+<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
+"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
+
+<!-- Include general documentation entities -->
+<!ENTITY % docentities SYSTEM "../../../docbook/entities.xml">
+%docentities;
+
+]>
+
+<!-- Module User's Guide -->
+
+<chapter>
+
+	<title>&adminguide;</title>
+
+	<section>
+	<title>Overview</title>
+	<para>
+		This is a module that enables media streams to be proxied
+		via an &rtp; proxy. The only &rtp; proxy currently known to work
+		with this module is the Sipwise rtpengine
+		<ulink url="https://github.com/sipwise/rtpengine"></ulink>.
+		The rtpengine module is a modified version of the original
+		rtpproxy module using a new control protocol. The module is
+		designed to be a drop-in replacement for the old module from
+		a configuration file point of view, however due to the
+		incompatible control protocol, it only works with &rtp; proxies
+		which specifically support it.
+	</para>
+	</section>
+
+	<section>
+	<title>Multiple &rtp; proxy usage</title>
+	<para>
+		The rtpengine module can support multiple &rtp; proxies for
+		balancing/distribution and control/selection purposes.
+	</para>
+	<para>
+		The module allows definition of several sets of rtpproxies.
+		Load-balancing will be performed over a set and the admin has the
+		ability to choose what set should be used. The set is selected via
+		its id - the id being defined with the set. Refer to the
+		<quote>rtpengine_sock</quote> module parameter definition for syntax
+		description.
+	</para>
+	<para>
+		The balancing inside a set is done automatically by the module based on
+		the weight of each &rtp; proxy from the set.
+	</para>
+	<para>
+		The selection of the set is done from script prior using
+		rtpengine_delete(), rtpengine_offer() or rtpengine_answer()
+		functions - see the set_rtpengine_set() function.
+	</para>
+	<para>
+	        Another way to select the set is to define setid_avp
+	        module parameter and assign setid to the defined avp
+	        before calling rtpengine_offer() or rtpengine_manage()
+	        function.  If forwarding of the requests fails and
+	        there is another branch to try, remember to unset the
+	        avp after calling rtpengine_delete() function.
+	</para>
+	<para>
+		For backward compatibility reasons, a set with no id take by default
+		the id 0. Also if no set is explicitly set before
+		rtpengine_delete(), rtpengine_offer() or rtpengine_answer()
+		the 0 id set will be used.
+	</para>
+	<para>
+		IMPORTANT: if you use multiple sets, take care and use the same set for
+		both rtpengine_offer()/rtpengine_answer() and rtpengine_delete()!!
+		If the set was selected using setid_avp, the avp needs to be
+		set only once before rtpengine_offer() or rtpengine_manage() call.
+	</para>
+	<para>
+		From the current implementation point of view, the sets of rtpproxy nodes
+		are shared memory(shm), so all processes can see a common list of nodes.
+		There is no locking when setting the nodes enabled/disabled (to keep the
+		memory access as fast as possible). Thus, problems related to node state
+		might appear for concurent processes that might set the nodes
+		enabled/disabled(e.g. by fifo command). This robustness problems are overcomed as follows.
+	</para>
+
+	<para>
+		If the current process sees the selected node as disabled, the node is
+		<emphasis>force tested</emphasis> before the current process actually
+		takes the disabled decision. If the test succeeds, the process will set
+		the node as enabled (but other concurrent process might still see it as disabled).
+.
+	</para>
+
+	<para>
+		If the current process sees the selected node as enabled, it does no additional checks
+		and sends the command which will fail in case the machine is actually broken.
+		The process will set the node as disabled (but other concurrent process might still see it as enabled).
+	</para>
+
+	<para>
+		The 'kamctl fifo' commands (including rtpengin ones) are executed by an exclusive
+		process which operate on the same shared memory node list.
+	</para>
+
+	<para>
+		All the nodes are pinged in the beginning by all the processes,
+		even if the node list is shared memory.
+	</para>
+	</section>
+
+	<section>
+	<title>Dependencies</title>
+	<section>
+		<title>&kamailio; Modules</title>
+		<para>
+		The following modules must be loaded before this module:
+			<itemizedlist>
+			<listitem>
+			<para>
+				<emphasis>tm module</emphasis> - (optional) if you want to
+				have rtpengine_manage() fully functional
+			</para>
+			</listitem>
+			</itemizedlist>
+		</para>
+	</section>
+	<section>
+		<title>External Libraries or Applications</title>
+		<para>
+		The following libraries or applications must be installed before
+		running &kamailio; with this module loaded:
+			<itemizedlist>
+			<listitem>
+			<para>
+				<emphasis>None</emphasis>.
+			</para>
+			</listitem>
+			</itemizedlist>
+		</para>
+	</section>
+	</section>
+
+	<section>
+	<title>Parameters</title>
+	<section id="rtpengine.p.rtpengine_sock">
+		<title><varname>rtpengine_sock</varname> (string)</title>
+		<para>
+		Definition of socket(s) used to connect to (a set) &rtp; proxy. It may
+		specify a UNIX socket or an IPv4/IPv6 UDP socket.
+		</para>
+		<para>
+		<emphasis>
+			Default value is <quote>NONE</quote> (disabled).
+		</emphasis>
+		</para>
+		<example>
+		<title>Set <varname>rtpengine_sock</varname> parameter</title>
+		<programlisting format="linespecific">
+...
+# single rtproxy
+modparam("rtpengine", "rtpengine_sock", "udp:localhost:12221")
+# multiple rtproxies for LB with weights (missing weight defaults to 1)
+modparam("rtpengine", "rtpengine_sock",
+	"udp:localhost:12221=2 udp:localhost:12222=1")
+# multiple sets of multiple rtproxies
+modparam("rtpengine", "rtpengine_sock",
+	"1 == udp:localhost:12221 udp:localhost:12222")
+modparam("rtpengine", "rtpengine_sock",
+	"2 == udp:localhost:12225")
+...
+</programlisting>
+		</example>
+	</section>
+	<section id="rtpengine.p.rtpengine_disable_tout">
+		<title><varname>rtpengine_disable_tout</varname> (integer)</title>
+		<para>
+		Once an &rtp; proxy was found unreachable and marked as disabled, the rtpengine
+		module will not attempt to establish communication to that &rtp; proxy for
+		rtpengine_disable_tout seconds.
+		</para>
+		<para>
+		<emphasis>
+			Default value is <quote>60</quote>.
+		</emphasis>
+		</para>
+		<example>
+		<title>Set <varname>rtpengine_disable_tout</varname> parameter</title>
+		<programlisting format="linespecific">
+...
+modparam("rtpengine", "rtpengine_disable_tout", 20)
+...
+</programlisting>
+		</example>
+	</section>
+	<section id="rtpengine.p.rtpengine_tout_ms">
+		<title><varname>rtpengine_tout_ms</varname> (integer)</title>
+		<para>
+		Timeout value expressed in milliseconds in waiting for reply from &rtp; proxy.
+		</para>
+		<para>
+		<emphasis>
+			Default value is <quote>1000</quote>.
+		</emphasis>
+		</para>
+		<example>
+		<title>Set <varname>rtpengine_tout_ms</varname> parameter</title>
+		<programlisting format="linespecific">
+...
+modparam("rtpengine", "rtpengine_tout_ms", 2000)
+...
+</programlisting>
+		</example>
+	</section>
+	<section id="rtpengine.p.rtpengine_allow_op">
+		<title><varname>rtpengine_allow_op</varname> (integer)</title>
+		<para>
+		Enable this to allow finishing the current sessions while denying new sessions for the
+		<emphasis>manually deactivated nodes </emphasis> via kamctl command i.e. "disabled(permanent)" nodes.
+		Probably the manually deactivated machine is still running(did not crash).
+		</para>
+		<para>
+		This is <emphasis>useful</emphasis> when deactivating a node for maintanance and reject new sessions but allow current ones to finish.
+		</para>
+		<para>
+		The behaviour is the same for a rtpengine deleted table node.
+		When the node is deleted from the table and the table reloaded (see nh_reload_rtpp) the node actually is disabled(permanent) and hidden for display.
+		Next time the same node will be added in the table, and the content reloaded, it will be updated and re-displayed.
+		</para>
+		<para>
+		<emphasis>
+		Default value is <quote>0</quote> to keep the current behaviour.
+		</emphasis>
+		</para>
+		<example>
+		<title>Set <varname>rtpengine_allow_op</varname> parameter</title>
+		<programlisting format="linespecific">
+...
+modparam("rtpengine", "rtpengine_allow_op", 1)
+...
+</programlisting>
+		</example>
+	</section>
+	<section id="rtpengine.p.queried_nodes_limit">
+		<title><varname>queried_nodes_limit</varname> (integer)</title>
+		<para>
+		The total number of nodes inside a set (sets are configurable via rtpengine_sock function) to be queried 
+		before giving up establishing a session. This brings more flexibility in case checking all rtpengines
+		would take too long. Max limit is 50.
+		</para>
+		<para>
+		<emphasis>
+			By default all nodes in a set are tried before giving up communicating with the rtpengines.
+		</emphasis>
+		</para>
+		<example>
+		<title>Set <varname>queried_nodes_limit</varname> parameter</title>
+		<programlisting format="linespecific">
+...
+modparam("rtpengine", "queried_nodes_limit", 5)
+...
+</programlisting>
+		</example>
+	</section>
+	<section id="rtpengine.p.rtpengine_retr">
+		<title><varname>rtpengine_retr</varname> (integer)</title>
+		<para>
+		How many times the module should retry to send and receive after
+		timeout was generated.
+		</para>
+		<para>
+		<emphasis>
+			Default value is <quote>5</quote>.
+		</emphasis>
+		</para>
+		<example>
+		<title>Set <varname>rtpengine_retr</varname> parameter</title>
+		<programlisting format="linespecific">
+...
+modparam("rtpengine", "rtpengine_retr", 2)
+...
+</programlisting>
+		</example>
+	</section>
+	<section id="rtpengine.p.extra_id_pv">
+		<title><varname>extra_id_pv</varname> (string)</title>
+		<para>
+			The parameter sets the PV defination to use when the <quote>b</quote>
+			parameter is used on rtpengine_delete(), rtpengine_offer(),
+			rtpengine_answer() or rtpengine_manage() command.
+		</para><para>
+			Default is empty, the <quote>b</quote> parameter may not be used then.
+		</para>
+		<example>
+		<title>Set <varname>extra_id_pv</varname> parameter</title>
+		<programlisting format="linespecific">
+...
+modparam("rtpengine", "extra_id_pv", "$avp(extra_id)")
+...
+</programlisting>
+		</example>
+	</section>
+
+	<section id="rtpengine.p.setid_avp">
+		<title><varname>setid_avp</varname> (string)</title>
+		<para>
+			The parameter defines an AVP that, if set,
+			determines which &rtp; proxy set
+			rtpengine_offer(), rtpengine_answer(),
+			rtpengine_delete(), and rtpengine_manage()
+			functions use.
+		</para>
+		<para>
+			There is no default value.
+		</para>
+		<example>
+		<title>Set <varname>setid_avp</varname> parameter</title>
+<programlisting format="linespecific">
+...
+modparam("rtpengine", "setid_avp", "$avp(setid)")
+...
+</programlisting>
+		</example>
+	</section>
+
+	<section id="rtpengine.p.force_send_interface">
+		<title><varname>force_send_interface</varname> (string)</title>
+		<para>
+			Forces all control messages between the &sip; proxy and
+			the &rtp; proxy to be sent from the specified local
+			interface. Both IPv4 and IPv6 addresses are supported. If
+			not specified, the default interface selected by the
+			operating system will be used.
+			Note: when rtpengine_sock is a IPv6 link-local address,
+			one _must_ set this parameter in order to successfully connect to RTP engine.
+			This is necessarely because OS needs additional scope_id hint to communicate
+			over IPv6 link locals. The scope_id is resolved based on the given IPv6.
+		</para>
+		<para>
+			There is no default value.
+		</para>
+		<example>
+		<title>Set <varname>force_send_interface</varname> parameter</title>
+<programlisting format="linespecific">
+...
+modparam("rtpengine", "force_send_interface", "10.3.7.123")
+modparam("rtpengine", "force_send_interface", "2001:8d8:1ff:10c0:9a90:96ff:fea8:fd99")
+...
+</programlisting>
+		</example>
+	</section>
+
+	<section id="rtpengine.p.read_sdp_pv">
+		<title><varname>read_sdp_pv</varname> (string)</title>
+		<para>
+			If this parameter is set to a valid AVP or script var specifier, rtpengine
+			will take the input SDP from this pv instead of the message body.
+		</para>
+		<para>
+			There is no default value.
+		</para>
+		<example>
+		<title>Set <varname>read_sdp_pv</varname> parameter</title>
+<programlisting format="linespecific">
+...
+modparam("rtpengine", "read_sdp_pv", "$var(sdp)")
+...
+route {
+	...
+	$var(sdp) = $rb + "a=foo:bar\r\n";
+	rtpengine_manage();
+}
+</programlisting>
+		</example>
+	</section>
+
+	<section id="rtpengine.p.write_sdp_pv">
+		<title><varname>write_sdp_pv</varname> (string)</title>
+		<para>
+			If this parameter is set to a valid AVP or script var specifier, the
+            SDP returned by rtpengine in the offer/answer operations
+            is returned in the specified variable instead of the
+            message body.
+		</para>
+		<para>
+			There is no default value.
+		</para>
+		<example>
+		<title>Set <varname>write_sdp_pv</varname> parameter</title>
+<programlisting format="linespecific">
+...
+modparam("rtpengine", "write_sdp_pv", "$avp(sdp)")
+...
+route {
+	...
+	rtpengine_manage();
+	set_body("$avp(sdp)a=baz123\r\n", "application/sdp");
+}
+</programlisting>
+		</example>
+	</section>
+
+	<section id="rtpengine.p.rtp_inst_pvar">
+		<title><varname>rtp_inst_pvar</varname> (string)</title>
+		<para>
+			A pseudo variable to store the chosen RTP Engine IP address.
+			If this parameter is set, the IP address and port of the instance chosen will be stored in the given variable.
+		</para>
+		<para>
+			By default, this parameter is not set.
+		</para>
+		<example>
+		<title>Set <varname>rtp_inst_pvar</varname> parameter</title>
+<programlisting format="linespecific">
+...
+modparam("rtpengine", "rtp_inst_pvar", "$avp(RTP_INSTANCE)")
+...
+</programlisting>
+		</example>
+	</section>
+
+	<section id="rtpengine.p.hash_table_size">
+		<title><varname>hash_table_size</varname> (integer)</title>
+		<para>
+			Size of the hash table. Default value is 256.
+		</para>
+		<para>
+			NOTE: If configured size is <emphasis>less than</emphasis> 1, the size will be defaulted to 1.
+		</para>
+		<example>
+		<title>Set <varname>hash_table_size</varname> parameter</title>
+<programlisting format="linespecific">
+...
+modparam("rtpengine", "hash_table_size", "123")
+...
+</programlisting>
+		</example>
+	</section>
+
+	<section id="rtpengine.p.hash_table_tout">
+		<title><varname>hash_table_tout</varname> (integer)</title>
+		<para>
+			Number of seconds after an rtpengine hash table entry is marked for deletion.
+			By default, this parameter is set to 3600 (seconds).
+		</para>
+		<para>
+			To maintain information about a selected rtp machine node, for a given call, entries are added in a hashtable of (callid, node) pairs.
+			When command comes, lookup callid. If found, return chosen node. If not found, choose a new node, insert it in the hastable and return the chosen node.
+		</para>
+		<para>
+			NOTE: In the current implementation, the actual deletion happens <emphasis>on the fly</emphasis>,
+			while insert/remove/lookup the hastable, <emphasis>only</emphasis> for the entries in the insert/remove/lookup path.
+		</para>
+		<para>
+			NOTE: When configuring this parameter, one should consider maximum call time VS share memory for unfinished calls.
+		</para>
+		<example>
+		<title>Set <varname>hash_table_tout</varname> parameter</title>
+<programlisting format="linespecific">
+...
+modparam("rtpengine", "hash_table_tout", "300")
+...
+</programlisting>
+                </example>
+        </section>
+
+
+
+
+	<section id="rtpengine.p.db_url">
+		<title><varname>db_url</varname> (string)</title>
+		<para>
+			The rtpengine datablase url. If present and valid, it activates database mode.
+			Node information is read from database, not from config.
+		</para>
+		<para>
+			By default, the datablase url is NULL (not set).
+		</para>
+		<example>
+		<title>Set <varname>db_url</varname> parameter</title>
+<programlisting format="linespecific">
+...
+modparam("rtpengine", "db_url", "mysql://pass@localhost/db")
+...
+</programlisting>
+		</example>
+	</section>
+
+
+	<section id="rtpengine.p.table_name">
+		<title><varname>table_name</varname> (string)</title>
+		<para>
+			The rtpengine table name. If database mode is activated (i.e. valid db_url),
+			set the name of rtpengine table, on startup.
+		</para>
+		<para>
+			By default, the rtpengine table name is "rtpengine".
+		</para>
+		<para>
+			NOTE: One needs to add the version of the rtpengine table in the version table.
+			The current version is version 1.
+		</para>
+		<example>
+		<title>Set <varname>table_name</varname> parameter</title>
+<programlisting format="linespecific">
+...
+modparam("rtpengine", "table_name", "rtpengine_table_name")
+...
+</programlisting>
+		</example>
+
+		<example>
+		<title>Setup <varname>rtpengine</varname> table</title>
+<programlisting format="linespecific">
+mysql> describe rtpengine;
++----------+------------------+------+-----+---------+-------+
+| Field    | Type             | Null | Key | Default | Extra |
++----------+------------------+------+-----+---------+-------+
+| setid    | int(10) unsigned | NO   |     | NULL    |       |
+| url      | varchar(256)     | NO   |     | NULL    |       |
+| weight   | int(10) unsigned | NO   |     | NULL    |       |
+| disabled | int(11)          | NO   |     | NULL    |       |
++----------+------------------+------+-----+---------+-------+
+
+mysql> select * from rtpengine;
++-------+---------------------------+--------+----------+
+| setid | url                       | weight | disabled |
++-------+---------------------------+--------+----------+
+|     0 | udp:rtpproxy1.domain:8800 |    100 |        0 |
+|     0 | udp:rtpproxy2.domain:8800 |    200 |        1 |
++-------+---------------------------+--------+----------+
+
+mysql> select * from version;
++---------------------------+---------------+
+| table_name                | table_version |
++---------------------------+---------------+
+| rtpengine                 |             1 |
++---------------------------+---------------+
+</programlisting>
+		</example>
+	</section>
+
+
+	<section id="rtpengine.p.setid_col">
+		<title><varname>setid_col</varname> (string)</title>
+		<para>
+			Column name in the rtpengine table. If database mode is activated (i.e. valid db_url),
+			set the setid of rtp nodes according to this column, on startup.
+			The MySQL value for this column should be INT UNSIGNED.
+		</para>
+		<para>
+			By default, the column name is "setid".
+		</para>
+		<example>
+		<title>Set <varname>setid_col</varname> parameter</title>
+<programlisting format="linespecific">
+...
+modparam("rtpengine", "setid_col", "setid_column_name")
+...
+</programlisting>
+		</example>
+	</section>
+
+
+	<section id="rtpengine.p.url_col">
+		<title><varname>url_col</varname> (string)</title>
+		<para>
+			Column name in the rtpengine table. If database mode is activated (i.e. valid db_url),
+			set the url of rtp nodes according to this column, on startup.
+			The MySQL value for this column should be VARCHAR.
+		</para>
+		<para>
+			By default, the column name is "url".
+		</para>
+		<example>
+		<title>Set <varname>url_col</varname> parameter</title>
+<programlisting format="linespecific">
+...
+modparam("rtpengine", "url_col", "url_column_name")
+...
+</programlisting>
+		</example>
+	</section>
+
+
+	<section id="rtpengine.p.weight_col">
+		<title><varname>weight_col</varname> (string)</title>
+		<para>
+			Column name in the rtpengine table. If database mode is activated (i.e. valid db_url),
+			set the weight of rtp nodes according to this column, on startup. The column value has
+			priority over the URL weight.
+			The MySQL value for this column should be INT UNSIGNED.
+		</para>
+		<para>
+			By default, the column name is "weight".
+		</para>
+		<example>
+		<title>Set <varname>weight_col</varname> parameter</title>
+<programlisting format="linespecific">
+...
+modparam("rtpengine", "weight_col", "weight_column_name")
+...
+</programlisting>
+		</example>
+	</section>
+
+
+	<section id="rtpengine.p.disabled_col">
+		<title><varname>disabled_col</varname> (string)</title>
+		<para>
+			Column name in the rtpengine table. If database mode is activated (i.e. valid db_url),
+			set the state of rtp nodes according to this column, on startup.
+			The MySQL value for this column should be INT.
+		</para>
+		<para>
+			By default, the column name is "disabled".
+		</para>
+		<example>
+		<title>Set <varname>disabled_col</varname> parameter</title>
+<programlisting format="linespecific">
+...
+modparam("rtpengine", "disabled_col", "disabled_column_name")
+...
+</programlisting>
+		</example>
+	</section>
+
+
+	<section id="rtpengine.p.setid_default">
+		<title><varname>setid_default</varname> (string)</title>
+		<para>
+			The default set of nodes to be used.
+		</para>
+		<para>
+			By default, the setid is 0.
+		</para>
+		<para>
+			NOTE that if setid_avp is configured, this value will be ignored and
+			the active set will be chosen according to the setid_avp.
+		</para>
+		<example>
+		<title>Set <varname>setid_default</varname> parameter</title>
+<programlisting format="linespecific">
+...
+modparam("rtpengine", "setid_default", 11)
+...
+</programlisting>
+		</example>
+	</section>
+
+	</section>
+
+
+
+
+	<section>
+	<title>Functions</title>
+	<section id="rtpengine.f.set_rtpengine_set">
+		<title>
+		<function moreinfo="none">set_rtpengine_set(setid[, setid])</function>
+		</title>
+		<para>
+		Sets the ID of the &rtp; proxy set to be used for the next
+		rtpengine_delete(), rtpengine_offer(), rtpengine_answer()
+		or rtpengine_manage() command. The parameter can be an integer or
+		a config variable holding an integer.
+		</para>
+		<para>
+		A second set ID can be specified to daisy-chain two &rtp; proxies.
+		The two set IDs must be distinct from each other and there must not
+		be any overlap in the proxies present in both sets. In this use case,
+		the request (offer, answer, etc) is first sent to an &rtp; proxy from
+		the first set, which rewrites the &sdp; body and sends it back to the
+		module. The rewritten &sdp; body is then used to make another request
+		to an &rtp; proxy from the second set, which rewrites the &sdp; body
+		another time and sends it back to the module to be placed back into the
+		&sip; message. This is useful if you have a set of &rtp; proxies that
+		the caller must use, and another distinct set of &rtp; proxies that the
+		callee must use. This is supported by all rtpengine commands except
+		rtpengine_manage().
+		</para>
+		<para>
+		This function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,
+		BRANCH_ROUTE.
+		</para>
+		<example>
+		<title><function>set_rtpengine_set</function> usage</title>
+		<programlisting format="linespecific">
+...
+set_rtpengine_set("2");
+rtpengine_offer();
+...
+</programlisting>
+		</example>
+	</section>
+        <section id="rtpengine.f.rtpengine_offer">
+                <title>
+                <function moreinfo="none">rtpengine_offer([flags])</function>
+                </title>
+                <para>
+                Rewrites &sdp; body to ensure that media is passed through
+                an &rtp; proxy. To be invoked
+		on INVITE for the cases the &sdp; bodies are in INVITE and 200 OK and on 200 OK
+		when &sdp; bodies are in 200 OK and ACK.
+                </para>
+		<para>Meaning of the parameters is as follows:</para>
+		<itemizedlist>
+		<listitem>
+			<para>
+			<emphasis>flags</emphasis> - flags to turn on some features.
+			</para>
+			<para>The <quote>flags</quote> string is a list of space-separated items. Each item
+			is either an individual token, or a token in <quote>key=value</quote> format. The
+			possible tokens are described below.</para>
+			<itemizedlist>
+				<listitem><para>
+				<emphasis>via-branch=...</emphasis> - Include the <quote>branch</quote>
+				value of one of the <quote>Via</quote> headers in the request to the
+				&rtp; proxy. Possible values are:
+				<quote>1</quote> - use the first <quote>Via</quote> header;
+				<quote>2</quote> - use the second <quote>Via</quote> header;
+				<quote>auto</quote> - use the first <quote>Via</quote> header if this is
+				a request, or the second one if this is a reply;
+				<quote>extra</quote> - don't take the value from a header, but instead use
+				the value of the <quote>extra_id_pv</quote> variable.
+				This can be used to create one media session per branch
+				on the &rtp; proxy. When sending a subsequent <quote>delete</quote> command to
+				the &rtp; proxy, you can then stop just the session for a specific branch when
+				passing the flag '1' or '2' in the <quote>rtpengine_delete</quote>, or stop
+				all sessions for a call when not passing one of those two flags there. This is
+				especially useful if you have serially forked call scenarios where the &rtp; proxy
+				gets an <quote>offer</quote> command for a new branch, and then a
+				<quote>delete</quote> command for the previous branch, which would otherwise
+				delete the full call, breaking the subsequent <quote>answer</quote> for the
+				new branch. <emphasis>This flag is only supported by the Sipwise rtpengine
+				&rtp; proxy at the moment!</emphasis>
+				</para></listitem>
+				<listitem><para>
+				<emphasis>asymmetric</emphasis> - flags that UA from which message is
+				received doesn't support symmetric &rtp;. Disables learning of endpoint addresses
+				in the Sipwise rtpengine proxy.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>force-answer</emphasis> - force <quote>answer</quote>, that is,
+				only rewrite &sdp; when corresponding session already exists
+				in the &rtp; proxy. By default is on when the session is to be
+				completed.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>direction=...</emphasis> - this option specifies a logical network
+				interface and should be given exactly twice. It enables &rtp; bridging between
+				different addresses or networks of the same family (e.g. IPv4 to IPv4). The
+				first instance of the option
+				specifies the interface that the originator of this message should be using,
+				while the second instance specifies the interface that the target should be
+				using. For example, if the &sip; message was sent by an endpoint on a private
+				network and will be sent to an endpoint on the public internet, you would use
+				<quote>direction=priv direction=pub</quote> if those two logical network
+				interfaces were called <quote>priv</quote> and <quote>pub</quote> in your
+				&rtp; proxy's configuration respectively. The direction must only be specified
+				in for initial &sdp; offer; answers or subsequent offers can omit this option.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>internal, external</emphasis> - shorthand for
+				<quote>direction=internal</quote> and <quote>direction=external</quote>
+				respectively. Useful for brevity or as legacy option if the &rtp; proxy only
+				supports two network interfaces instead of multiple, arbitrarily named ones.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>auto-bridge</emphasis> - this flag an alternative to the
+				<quote>internal</quote> and <quote>external</quote> flags
+				in order to do automatic bridging between IPv4 on the
+				"internal network" and IPv6 on the "external network". Instead of
+				explicitly instructing the &rtp; proxy to select a particular address
+				family, the distinction is done by the given IP in the &sdp; body by
+				the &rtp; proxy itself. Not supported by Sipwise rtpengine.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>address-family=...</emphasis> - instructs the &rtp; proxy that the
+				recipient of this &sdp; body expects to see addresses of a particular family.
+				Possible values are <quote>IP4</quote> and <quote>IP6</quote>. For example,
+				if the &sdp; body contains IPv4 addresses but the recipient only speaks IPv6,
+				you would use <quote>address-family=IP6</quote> to bridge between the two
+				address families.
+				</para><para>
+				Sipwise rtpengine remembers the address family preference of each party after
+				it has seen an &sdp; body from them. This means that normally it is only
+				necessary to explicitly specify the address family in the <quote>offer</quote>,
+				but not in the <quote>answer</quote>.
+				</para><para>
+				Note: Please note, that this will only work properly with non-dual-stack user-agents or with
+				dual-stack clients according to RFC6157 (which suggest ICE for Dual-Stack implementations).
+				This short-cut will not work properly with RFC4091 (ANAT) compatible clients, which suggests
+				having different m-lines with different IP-protocols grouped together.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>force</emphasis> - instructs the &rtp; proxy to ignore marks
+				inserted by another &rtp; proxy in transit to indicate that the
+				session is already goes through another proxy. Allows creating
+				a chain of proxies. Not supported and ignored by Sipwise rtpengine.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>trust-address</emphasis> - flags that IP address in &sdp; should
+				be trusted. Starting with rtpengine 3.8, this is the default behaviour.
+				In older versions, without this flag the &rtp; proxy ignores the address in
+				the &sdp; and uses source address of the &sip; message as media
+				address which is passed to the &rtp; proxy.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>SIP-source-address</emphasis> - the opposite of
+				<emphasis>trust-address</emphasis>. Restores the old default behaviour
+				of ignoring endpoint addresses in the &sdp; body.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>replace-origin</emphasis> - flags that IP from the origin
+				description (o=) should be also changed.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>replace-session-connection</emphasis> - flags to change the session-level
+				&sdp; connection (c=) IP if media description also includes
+				connection information.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>symmetric</emphasis> - flags that for the UA from which
+				message is received, support symmetric &rtp; must be forced. Does nothing with
+				the Sipwise rtpengine proxy as it is the default.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>repacketize=NN</emphasis> - requests the &rtp; proxy to perform
+				re-packetization of &rtp; traffic coming from the UA which
+				has sent the current message to increase or decrease payload
+				size per each &rtp; packet forwarded if possible.  The NN is the
+				target payload size in ms, for the most codecs its value should
+				be in 10ms increments, however for some codecs the increment
+				could differ (e.g. 30ms for GSM or 20ms for G.723).  The
+				&rtp; proxy would select the closest value supported by the codec.
+				This feature could be used for significantly reducing bandwith
+				overhead for low bitrate codecs, for example with G.729 going
+				from 10ms to 100ms saves two thirds of the network bandwith.
+				Not supported by Sipwise rtpengine.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>ICE=...</emphasis> - controls the &rtp; proxy's behaviour
+				regarding ICE attributes within the &sdp; body. Possible values
+				are: <quote>force</quote> -
+				discard any ICE attributes already present in the &sdp; body
+				and then generate and insert new ICE data, leaving itself
+				as the <emphasis>only</emphasis> ICE candidates;
+				<quote>force-relay</quote> -
+				discard any <quote>relay</quote> type ICE attributes already present
+				in the &sdp; body and then generate and insert itself
+				as the <emphasis>only</emphasis> ICE <quote>relay</quote> candidates;
+				<quote>remove</quote> instructs the &rtp; proxy to discard
+				any ICE attributes and not insert any new ones into the &sdp;.
+				The default (if no <quote>ICE=...</quote> is given at all),
+				new ICE data will only be generated
+				if no ICE was present in the &sdp; originally; otherwise
+				the &rtp; proxy will only insert itself as
+				<emphasis>additional</emphasis> ICE candidate. Other
+				&sdp; substitutions (c=, m=, etc) are unaffected by this flag.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>RTP, SRTP, AVP, AVPF</emphasis> - These flags control the &rtp;
+				transport protocol that should be used towards the recipient of
+				the &sdp;. If none of them are specified, the protocol given in
+				the &sdp; is left untouched. Otherwise, the <quote>SRTP</quote> flag indicates that
+				SRTP should be used, while <quote>RTP</quote> indicates that SRTP should not be used.
+				<quote>AVPF</quote> indicates that the advanced RTCP profile with feedback messages
+				should be used, and <quote>AVP</quote> indicates that the regular RTCP profile
+				should be used. See also the next set of flags below.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>RTP/AVP, RTP/SAVP, RTP/AVPF, RTP/SAVPF</emphasis> - these serve as
+				an alternative, more explicit way to select between the different &rtp; protocols
+				and profiles supported by the &rtp; proxy. For example, giving the flag
+				<quote>RTP/SAVPF</quote> has the same effect as giving the two flags
+				<quote>SRTP AVPF</quote>.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>to-tag</emphasis> - force inclusion of the <quote>To</quote> tag.
+				Normally, the <quote>To</quote> tag is always included when present, except
+				for <quote>delete</quote> messages. Including the <quote>To</quote> tag in
+				a <quote>delete</quote> messages allows you to be more selective about which
+				dialogues within a call are being torn down.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>rtcp-mux-demux</emphasis> - if rtcp-mux (RFC 5761) was
+				offered, make the &rtp; proxy accept the offer, but not offer it to the
+				recipient of this message.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>rtcp-mux-reject</emphasis> - if rtcp-mux was offered, make the
+				&rtp; proxy reject the offer, but still offer it to the recipient. Can be
+				combined with <quote>rtcp-mux-offer</quote> to always offer it.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>rtcp-mux-offer</emphasis> - make the &rtp; proxy offer rtcp-mux
+				to the recipient of this message, regardless of whether it was offered
+				originally or not.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>rtcp-mux-accept</emphasis> - if rtcp-mux was offered, make the
+				&rtp; proxy accept the offer and also offer it to the recipient of this
+				message. Can be combined with <quote>rtcp-mux-offer</quote> to always offer it.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>media-address=...</emphasis> - force a particular media address to
+				be used in the &sdp; body. Address family is detected automatically.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>TOS=...</emphasis> - change the IP TOS value for all outgoing &rtp;
+				packets within the entire call in both directions. Only honoured in an
+				<quote>offer</quote>, ignored for an <quote>answer</quote>. Valid values are
+				0 through 255, given in decimal. If this option is not specified, the TOS
+				value will revert to the default TOS (normally 184). A value of -1 may be used
+				to leave the currently used TOS unchanged.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>delete-delay=...</emphasis> - override the default delay (in seconds)
+				before a call is actually deleted from memory. Can be set to zero to effectuate
+				immediate deletion. This option only makes sense for <emphasis>delete</emphasis>
+				operations.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>strict-source</emphasis> - instructs the &rtp; proxy to check the
+				source addresses of all incoming &rtp; packets and drop the packets if the
+				address doesn't match.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>media-handover</emphasis> - the antithesis of
+				<emphasis>strict-source</emphasis>. Instructs the &rtp; proxy not only to accept
+				mismatching &rtp; source addresses (as it normally would), but also to accept
+				them as the new endpoint address of the opposite media flow. Not recommended
+				as it allows media streams to be hijacked by an attacker.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>DTLS=...</emphasis> - influence the behaviour of DTLS-SRTP. Possible
+				values are <quote>no</quote> or <quote>off</quote> to suppress offering or
+				accepting DTLS-SRTP, and <quote>passive</quote> to prefer participating in
+				DTLS-SRTP in a passive role.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>SDES-off</emphasis> - don't offer SDES when it normally would. In an SRTP
+				context, this leaves DTLS-SRTP as the only other option.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>SDES-unencrypted_srtp, SDES-unencrypted_srtcp,
+				SDES-unauthenticated_srtp</emphasis> - these directly reflect the SDES session
+				parameters from RFC 4568 and will make the &rtp; proxy offer these parameters
+				when offering SDES.
+				</para></listitem>
+				<listitem><para>
+				<emphasis>SDES-encrypted_srtp, SDES-encrypted_srtcp,
+				SDES-authenticated_srtp</emphasis> - the opposites of the flags above. Useful
+				if accepting these parameters is not desired and they should be rejected instead.
+				</para></listitem>
+			</itemizedlist>
+		</listitem>
+		</itemizedlist>
+		<para>
+		This function can be used from ANY_ROUTE.
+                </para>
+		<example>
+		<title><function>rtpengine_offer</function> usage</title>
+		<programlisting format="linespecific">
+route {
+...
+    if (is_method("INVITE")) {
+        if (has_body("application/sdp")) {
+            if (rtpengine_offer())
+                t_on_reply("1");
+        } else {
+            t_on_reply("2");
+        }
+    }
+    if (is_method("ACK") &amp;&amp; has_body("application/sdp"))
+        rtpengine_answer();
+...
+}
+
+onreply_route[1]
+{
+...
+    if (has_body("application/sdp"))
+        rtpengine_answer();
+...
+}
+
+onreply_route[2]
+{
+...
+    if (has_body("application/sdp"))
+        rtpengine_offer();
+...
+}
+</programlisting>
+                </example>
+	</section>
+        <section id="rtpengine.f.rtpengine_answer">
+                <title>
+                <function moreinfo="none">rtpengine_answer([flags])</function>
+                </title>
+		<para>
+		Rewrites &sdp; body to ensure that media is passed through
+		an &rtp; proxy. To be invoked
+		on 200 OK for the cases the &sdp; bodies are in INVITE and 200 OK and on ACK
+		when &sdp; bodies are in 200 OK and ACK.
+		</para>
+		<para>
+		See rtpengine_offer() function description above for the meaning of the
+		parameters.
+		</para>
+		<para>
+		This function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,
+		FAILURE_ROUTE, BRANCH_ROUTE.
+		</para>
+		<example>
+		 <title><function>rtpengine_answer</function> usage</title>
+		<para>
+		See rtpengine_offer() function example above for example.
+		</para>
+		</example>
+        </section>
+	<section id="rtpengine.f.rtpengine_delete">
+		<title>
+		<function moreinfo="none">rtpengine_delete([flags])</function>
+		</title>
+		<para>
+		Tears down the RTPProxy session for the current call.
+		</para>
+		<para>
+		See rtpengine_offer() function description above for the meaning of the
+		parameters. Note that not all flags make sense for a <quote>delete</quote>.
+		</para>
+		<para>
+		This function can be used from ANY_ROUTE.
+		</para>
+		<example>
+		<title><function>rtpengine_delete</function> usage</title>
+		<programlisting format="linespecific">
+...
+rtpengine_delete();
+...
+</programlisting>
+		</example>
+	</section>
+
+    <section id="rtpengine.f.rtpengine_manage">
+        <title>
+        <function moreinfo="none">rtpengine_manage([flags])</function>
+        </title>
+		<para>
+		Manage the RTPProxy session - it combines the functionality of
+		rtpengine_offer(), rtpengine_answer() and rtpengine_delete(), detecting
+		internally based on message type and method which one to execute.
+		</para>
+		<para>
+		It can take the same parameters as <function>rtpengine_offer().</function>
+		The flags parameter to rtpengine_manage() can be a configuration variable
+		containing the flags as a string.
+		</para>
+		<para>
+		Functionality:
+		</para>
+		<itemizedlist>
+		<listitem>
+			<para>
+			If INVITE with &sdp;, then do <function>rtpengine_offer()</function>
+			</para>
+		</listitem>
+		<listitem>
+			<para>
+			If INVITE with &sdp;, when the tm module is loaded, mark transaction with
+			internal flag FL_SDP_BODY to know that the 1xx and 2xx are for
+			<function>rtpengine_answer()</function>
+			</para>
+		</listitem>
+		<listitem>
+			<para>
+			If ACK with &sdp;, then do <function>rtpengine_answer()</function>
+			</para>
+		</listitem>
+		<listitem>
+			<para>
+			If BYE or CANCEL, or called within a FAILURE_ROUTE[], then do <function>rtpengine_delete()</function>
+			</para>
+		</listitem>
+		<listitem>
+			<para>
+			If reply to INVITE with code >= 300 do <function>rtpengine_delete()</function>
+			</para>
+		</listitem>
+		<listitem>
+			<para>
+			If reply with &sdp; to INVITE having code 1xx and 2xx, then
+			do <function>rtpengine_answer()</function> if the request had &sdp; or tm is not loaded,
+			otherwise do <function>rtpengine_offer()</function>
+			</para>
+		</listitem>
+	</itemizedlist>
+
+		<para>
+		This function can be used from ANY_ROUTE.
+		</para>
+		<example>
+		 <title><function>rtpengine_manage</function> usage</title>
+		<programlisting format="linespecific">
+...
+rtpengine_manage();
+...
+</programlisting>
+		</example>
+        </section>
+
+	<section id="rtpengine.f.start_recording">
+		<title>
+		<function moreinfo="none">start_recording()</function>
+		</title>
+		<para>
+		This function will send a signal to the &rtp; proxy to record
+		the &rtp; stream on the &rtp; proxy.
+		<emphasis>This function is not supported by Sipwise rtpengine at the moment!</emphasis>
+		</para>
+		<para>
+		This function can be used from REQUEST_ROUTE and ONREPLY_ROUTE.
+		</para>
+		<example>
+		<title><function>start_recording</function> usage</title>
+		<programlisting format="linespecific">
+...
+start_recording();
+...
+		</programlisting>
+		</example>
+	</section>
+
+
+	</section>
+
+	<section>
+		<title>Exported Pseudo Variables</title>
+		<section>
+			<title><function moreinfo="none">$rtpstat</function></title>
+			<para>
+			Returns the &rtp; statistics from the &rtp; proxy. The &rtp; statistics from the &rtp; proxy
+			are provided as a string and it does contain several packet counters. The statistics
+			must be retrieved before the session is deleted	(before <function>rtpengine_delete()</function>).
+			</para>
+
+		<example>
+		<title>$rtpstat Usage</title>
+		<programlisting format="linespecific">
+...
+    append_hf("X-RTP-Statistics: $rtpstat\r\n");
+...
+		</programlisting>
+		</example>
+	        </section>
+
+	</section>
+
+	<section>
+		<title><acronym>MI</acronym> Commands</title>
+		<section id="rtpengine.m.nh_enable_rtpp">
+			<title><function moreinfo="none">nh_enable_rtpp proxy_url/all 0/1</function></title>
+			<para>
+			Enables a &rtp; proxy if the second parameter value is greater than 0. Disables it if a zero value is given.
+			The first parameter is either a specific &rtp; proxy url (exactly as defined in
+			the config file) or the keyword <emphasis>all</emphasis>.
+			The second parameter value must be a number in decimal.
+			</para>
+			<para>
+            When try to enable the &rtp; proxy, an application ping command is sent to it.
+            If it fails, the proxy is not enabled.
+            Displays <emphasis>success</emphasis> or <emphasis>fail</emphasis> when try to enable/disable.
+			</para>
+			<para>
+			NOTE: If a &rtp; proxy is defined multiple times (in the same or diferent sets), all of its instances will be enabled/disabled.
+			</para>
+			<para>
+			NOTE: If a &rtp; proxy is in the disabled permanent state and one tries to enable it, even if the ping fails,
+            it is moved to a disabled temporary state and a recheck_ticks are given to it.
+            While the recheck_ticks are grater than 0, the proxy is considered disabled temporary, and it is not taken into consideration for sending data.
+            When the recheck_ticks are 0, the proxy is retested <emphasis>when trying to send data</emphasis>(not automatically retested), and data can be send to it on success.
+			</para>
+			<para>
+			NOTE: When specify the IPv6 &rtp; proxy url one must prefix it with <emphasis>::</emphasis>
+            to escape the :: from the IPv6 address. See the example below.
+			</para>
+			<example>
+			<title>
+			<function moreinfo="none">nh_enable_rtpp</function> usage</title>
+			<programlisting format="linespecific">
+...
+$ &ctltool; fifo nh_enable_rtpp udp:192.168.2.133:8081 0
+$ &ctltool; fifo nh_enable_rtpp ::udp6:fe80::9a90:96ff:fea8:fd99:9999 1
+$ &ctltool; fifo nh_enable_rtpp all 1
+...
+			</programlisting>
+			</example>
+		</section>
+
+	    <section id="rtpengine.m.nh_show_rtpp">
+			<title><function moreinfo="none">nh_show_rtpp proxy_url/all</function></title>
+			<para>
+			Displays all the &rtp; proxies and their information: set and
+			status (disabled or not, weight and recheck_ticks). If a &rtp; proxy has been disabled by
+            nh_enable_rtpp mi command a "(permanent)" quote will appear when printing the disabled status.
+            This is to differentiate from a temporary disable due to the proxy being not found responsive
+            by kamailio. In addition, when disabled permanent, recheck_ticks have no meaning and "N\A"
+            is printed instead of the value.
+			</para>
+			<para>
+            It takes either a specific &rtp; proxy url (exactly as defined in
+			the config file) or the keyword <emphasis>all</emphasis> as a parameter.
+			</para>
+			<para>
+			NOTE: When specify the IPv6 &rtp; proxy url one must prefix it with <emphasis>::</emphasis>
+            to escape the :: from the IPv6 address. See the example below.
+			</para>
+			<example>
+			<title>
+				<function moreinfo="none">nh_show_rtpp</function> usage</title>
+			<programlisting format="linespecific">
+...
+$ &ctltool; fifo nh_show_rtpp udp:192.168.2.133:8081
+$ &ctltool; fifo nh_show_rtpp ::udp6:fe80::9a90:96ff:fea8:fd99:9999
+$ &ctltool; fifo nh_show_rtpp all
+...
+			</programlisting>
+			</example>
+		</section>
+
+	    <section id="rtpengine.m.nh_ping_rtpp">
+			<title><function moreinfo="none">nh_ping_rtpp proxy_url/all</function></title>
+			<para>
+            Sends an application ping command to the &rtp; proxy. If the proxy does not respond,
+            it will be disabled, but not permanent. If the proxy responds, no action is taken.
+            Displays the ping result, i.e.
+            <emphasis>success</emphasis> or <emphasis>fail</emphasis> when try to ping.
+			</para>
+			<para>
+            It takes either a specific &rtp; proxy url (exactly as defined in
+			the config file) or the keyword <emphasis>all</emphasis> as a parameter.
+			</para>
+			<para>
+			NOTE: When specify the IPv6 &rtp; proxy url one must prefix it with <emphasis>::</emphasis>
+            to escape the :: from the IPv6 address. See the example below.
+			</para>
+			<example>
+			<title>
+				<function moreinfo="none">nh_ping_rtpp</function> usage</title>
+			<programlisting format="linespecific">
+...
+$ &ctltool; fifo nh_ping_rtpp udp:192.168.2.133:8081
+$ &ctltool; fifo nh_ping_rtpp ::udp6:fe80::9a90:96ff:fea8:fd99:9999
+$ &ctltool; fifo nh_ping_rtpp all
+...
+			</programlisting>
+			</example>
+		</section>
+
+
+	    <section id="rtpengine.m.nh_reload_rtpp">
+			<title><function moreinfo="none">nh_reload_rtpp</function></title>
+			<para>
+				Reloads the database node table content <emphasis>if configured</emphasis>.
+				Returns specific message related to success, failure and no db_url configured.
+			</para>
+			<para>
+				NOTE: The current behaviour updates the nodes state or creates new ones or
+				hides old ones, based on the database content. If allow_op modparam is enabled,
+				the sessions are still allowed to finish for the hidden old nodes.
+			</para>
+			<example>
+			<title>
+				<function moreinfo="none">nh_reload_rtpp</function> usage</title>
+			<programlisting format="linespecific">
+...
+$ &ctltool; fifo nh_reload_rtpp
+...
+			</programlisting>
+			</example>
+		</section>
+
+
+	    <section id="rtpengine.m.nh_show_hash_total">
+			<title><function moreinfo="none">nh_show_hash_total</function></title>
+			<para>
+				Print the total number of hash entries in the hash table at a given moment.
+			</para>
+			<example>
+			<title>
+				<function moreinfo="none">nh_show_hash_total</function> usage</title>
+			<programlisting format="linespecific">
+...
+$ &ctltool; fifo nh_show_hash_total
+...
+			</programlisting>
+			</example>
+		</section>
+
+	</section>
+
+</chapter>
+
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/doc/rtpengine_faq.xml ui-siprouter/modules/rtpengine/doc/rtpengine_faq.xml
--- ui-siprouter~/modules/rtpengine/doc/rtpengine_faq.xml	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/doc/rtpengine_faq.xml	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,103 @@
+<?xml version="1.0" encoding='ISO-8859-1'?>
+<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
+"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
+
+<!-- Include general documentation entities -->
+<!ENTITY % docentities SYSTEM "../../../docbook/entities.xml">
+%docentities;
+
+]>
+<!-- Module FAQ -->
+
+<chapter>
+
+    <title>&faqguide;</title>
+    <qandaset defaultlabel="number">
+	<qandaentry>
+	    <question>
+		    <para>How do I migrate from <quote>rtpproxy</quote> or <quote>rtpproxy-ng</quote> to
+		    <quote>rtpengine</quote>?</para>
+	    </question>
+	    <answer>
+		<para>
+			For the most part, only the names of the functions have changed, with
+			<quote>rtpproxy</quote> in each name replaced with <quote>rtpengine</quote>.
+			For example, <quote>rtpproxy_manage()</quote> has become
+			<quote>rtpengine_manage()</quote>. A few name duplications have also been resolved,
+			for example there is now a single <quote>rtpengine_delete()</quote> instead of
+			<quote>unforce_rtp_proxy()</quote> and the identical <quote>rtpproxy_destroy()</quote>.
+		</para>
+		<para>
+			The largest difference to the old module is how flags are passed to
+			<quote>rtpengine_offer()</quote>, <quote>rtpengine_answer()</quote>,
+			<quote>rtpengine_manage()</quote> and <quote>rtpengine_delete()</quote>. Instead of
+			having a string of single-letter flags, they now take a string of space-separated
+			items, with each item being either a single token (word) or a <quote>key=value</quote>
+			pair.
+		</para>
+		<para>
+			For example, if you had a call <quote>rtpproxy_offer("FRWOC+PS");</quote>, this would
+			then become:
+		</para>
+		<programlisting>
+rtpengine_offer("force trust-address symmetric replace-origin replace-session-connection ICE=force RTP/SAVPF");
+		</programlisting>
+		<para>
+			Finally, if you were using the second paramater (explicit media address) to any of
+			these functions, this has been replaced by the <quote>media-address=...</quote>
+			option within the first string of flags.
+		</para>
+	    </answer>
+	</qandaentry>
+	<qandaentry>
+	    <question>
+		<para>Where can I find more about &kamailio;?</para>
+	    </question>
+	    <answer>
+		<para>
+			Take a look at &kamailiohomelink;.
+		</para>
+	    </answer>
+	</qandaentry>
+	<qandaentry>
+	    <question>
+		<para>Where can I post a question about this module?</para>
+	    </question>
+	    <answer>
+		<para>
+			First at all check if your question was already answered on one of
+			our mailing lists:
+		</para>
+		<itemizedlist>
+		    <listitem>
+			<para>User Mailing List - &kamailiouserslink;</para>
+		    </listitem>
+		    <listitem>
+			<para>Developer Mailing List - &kamailiodevlink;</para>
+		    </listitem>
+		</itemizedlist>
+		<para>
+			E-mails regarding any stable &kamailio; release should be sent to
+			&kamailiousersmail; and e-mails regarding development versions
+			should be sent to &kamailiodevmail;.
+		</para>
+		<para>
+			If you want to keep the mail private, send it to
+			&kamailiohelpmail;.
+		</para>
+	    </answer>
+	</qandaentry>
+	<qandaentry>
+	    <question>
+		<para>How can I report a bug?</para>
+	    </question>
+	    <answer>
+		<para>
+			Please follow the guidelines provided at:
+			&kamailiobugslink;.
+		</para>
+	    </answer>
+	</qandaentry>
+    </qandaset>
+</chapter>
+
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/makecfg.lst ui-siprouter/modules/rtpengine/makecfg.lst
--- ui-siprouter~/modules/rtpengine/makecfg.lst	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/makecfg.lst	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,2 @@
+CFG_DEFS:=-DNAME='"kamailio"' -DVERSION='"4.1.9"' -DARCH='"x86_64"' -DOS='linux_' -DOS_QUOTED='"linux"' -DCOMPILER='"gcc 4.8.4"' -D__CPU_x86_64 -D__OS_linux -DSER_VER=4001009 -DCFG_DIR='"/usr/local/etc/kamailio/"' -DPKG_MALLOC -DSHM_MEM -DSHM_MMAP -DDNS_IP_HACK -DUSE_MCAST -DUSE_TCP -DDISABLE_NAGLE -DHAVE_RESOLV_RES -DUSE_DNS_CACHE -DUSE_DNS_FAILOVER -DUSE_DST_BLACKLIST -DUSE_NAPTR -DWITH_XAVP -DDBG_QM_MALLOC -DMEM_JOIN_FREE -DUSE_TLS -DTLS_HOOKS -DUSE_CORE_STATS -DSTATISTICS -DMALLOC_STATS -DWITH_AS_SUPPORT -DUSE_SCTP -DFAST_LOCK -DADAPTIVE_WAIT -DADAPTIVE_WAIT_LOOPS=1024 -DCC_GCC_LIKE_ASM -DHAVE_GETHOSTBYNAME2 -DHAVE_UNION_SEMUN -DHAVE_SCHED_YIELD -DHAVE_MSG_NOSIGNAL -DHAVE_MSGHDR_MSG_CONTROL -DHAVE_ALLOCA_H -DHAVE_TIMEGM -DHAVE_SCHED_SETSCHEDULER -DUSE_RAW_SOCKS -DHAVE_EPOLL -DHAVE_SIGIO_RT -DSIGINFO64_WORKARROUND -DUSE_FUTEX -DHAVE_SELECT -DKAMAILIO_MOD_INTERFACE -DMOD_NAME='"rtpengine"'
+CFG_INCLUDES:=
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/rtpengine.c ui-siprouter/modules/rtpengine/rtpengine.c
--- ui-siprouter~/modules/rtpengine/rtpengine.c	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/rtpengine.c	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,3297 @@
+/*
+ * Copyright (C) 2003-2008 Sippy Software, Inc., http://www.sippysoft.com
+ * Copyright (C) 2014-2015 Sipwise GmbH, http://www.sipwise.com
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * Kamailio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * Kamailio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+#ifndef __USE_BSD
+#define  __USE_BSD
+#endif
+#include <netinet/ip.h>
+#ifndef __FAVOR_BSD
+#define __FAVOR_BSD
+#endif
+#include <netinet/udp.h>
+#include <arpa/inet.h>
+#include <sys/uio.h>
+#include <sys/un.h>
+#include <ctype.h>
+#include <errno.h>
+#include <netdb.h>
+#include <poll.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <ifaddrs.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include "../../flags.h"
+#include "../../sr_module.h"
+#include "../../dprint.h"
+#include "../../data_lump.h"
+#include "../../data_lump_rpl.h"
+#include "../../error.h"
+#include "../../forward.h"
+#include "../../mem/mem.h"
+#include "../../parser/parse_from.h"
+#include "../../parser/parse_to.h"
+#include "../../parser/parse_uri.h"
+#include "../../parser/parser_f.h"
+#include "../../parser/sdp/sdp.h"
+#include "../../resolve.h"
+#include "../../timer.h"
+#include "../../trim.h"
+#include "../../ut.h"
+#include "../../pt.h"
+#include "../../timer_proc.h"
+#include "../../lib/kmi/mi.h"
+#include "../../pvar.h"
+#include "../../lvalue.h"
+#include "../../msg_translator.h"
+#include "../../usr_avp.h"
+#include "../../socket_info.h"
+#include "../../mod_fix.h"
+#include "../../dset.h"
+#include "../../route.h"
+#include "../../modules/tm/tm_load.h"
+#include "rtpengine.h"
+#include "rtpengine_funcs.h"
+#include "rtpengine_hash.h"
+#include "bencode.h"
+
+MODULE_VERSION
+
+#if !defined(AF_LOCAL)
+#define	AF_LOCAL AF_UNIX
+#endif
+#if !defined(PF_LOCAL)
+#define	PF_LOCAL PF_UNIX
+#endif
+
+/* NAT UAC test constants */
+#define	NAT_UAC_TEST_C_1918			0x01
+#define	NAT_UAC_TEST_RCVD			0x02
+#define	NAT_UAC_TEST_V_1918			0x04
+#define	NAT_UAC_TEST_S_1918			0x08
+#define	NAT_UAC_TEST_RPORT			0x10
+
+
+#define DEFAULT_RTPP_SET_ID			0
+#define MAX_RTPP_TRIED_NODES			50
+#define MI_SET_NATPING_STATE			"nh_enable_ping"
+#define MI_DEFAULT_NATPING_STATE		1
+
+#define MI_ENABLE_RTP_PROXY			"nh_enable_rtpp"
+#define MI_SHOW_RTP_PROXIES			"nh_show_rtpp"
+#define MI_PING_RTP_PROXY			"nh_ping_rtpp"
+#define MI_SHOW_HASH_TOTAL			"nh_show_hash_total"
+#define MI_RELOAD_RTP_PROXY			"nh_reload_rtpp"
+
+#define MI_DB_NOT_FOUND				"RTP database not found"
+#define MI_DB_NOT_FOUND_LEN			(sizeof(MI_DB_NOT_FOUND)-1)
+#define MI_DB_ERR				"Error reloading from RTP database"
+#define MI_DB_ERR_LEN				(sizeof(MI_DB_ERR)-1)
+#define MI_DB_OK				"Success reloading from RTP database"
+#define MI_DB_OK_LEN				(sizeof(MI_DB_OK)-1)
+#define MI_RTP_PROXY_NOT_FOUND			"RTP proxy not found"
+#define MI_RTP_PROXY_NOT_FOUND_LEN		(sizeof(MI_RTP_PROXY_NOT_FOUND)-1)
+#define MI_PING_DISABLED			"NAT ping disabled from script"
+#define MI_PING_DISABLED_LEN			(sizeof(MI_PING_DISABLED)-1)
+#define MI_DISABLED_PERMANENT			"1(permanent)"
+#define MI_DISABLED_PERMANENT_LEN		(sizeof(MI_DISABLED_PERMANENT)-1)
+#define MI_SET					"set"
+#define MI_SET_LEN				(sizeof(MI_SET)-1)
+#define MI_INDEX				"index"
+#define MI_INDEX_LEN				(sizeof(MI_INDEX)-1)
+#define MI_ENABLED				"enabled"
+#define MI_ENABLED_LEN				(sizeof(MI_ENABLED)-1)
+#define MI_DISABLED				"disabled"
+#define MI_DISABLED_LEN				(sizeof(MI_DISABLED)-1)
+#define MI_WEIGHT				"weight"
+#define MI_WEIGHT_LEN				(sizeof(MI_WEIGHT)-1)
+#define MI_RECHECK_TICKS			"recheck_ticks"
+#define MI_RECHECK_T_LEN			(sizeof(MI_RECHECK_TICKS)-1)
+
+#define MI_ERROR				"Error when adding rtpp node details"
+#define MI_ERROR_LEN				(sizeof(MI_ERROR)-1)
+#define MI_ALL					"all"
+#define MI_ALL_LEN				(sizeof(MI_ALL)-1)
+#define MI_ENABLE				"enable"
+#define MI_ENABLE_LEN				(sizeof(MI_ENABLE)-1)
+#define MI_DISABLE				"disable"
+#define MI_DISABLE_LEN				(sizeof(MI_DISABLE)-1)
+#define MI_PING					"ping"
+#define MI_PING_LEN				(sizeof(MI_PING)-1)
+#define MI_SUCCESS				"success"
+#define MI_SUCCESS_LEN				(sizeof(MI_SUCCESS)-1)
+#define MI_FAIL					"fail"
+#define MI_FAIL_LEN				(sizeof(MI_FAIL)-1)
+#define MI_HASH_ENTRIES				"entries"
+#define MI_HASH_ENTRIES_LEN			(sizeof(MI_HASH_ENTRIES)-1)
+#define MI_HASH_ENTRIES_FAIL			"Fail to get entry details"
+#define MI_HASH_ENTRIES_FAIL_LEN		(sizeof(MI_HASH_ENTRIES_FAIL)-1)
+
+#define MI_FOUND_ALL				2
+#define MI_FOUND_ONE				1
+#define MI_FOUND_NONE				0
+
+
+#define	CPORT					"22222"
+
+enum rtpe_operation {
+	OP_OFFER = 1,
+	OP_ANSWER,
+	OP_DELETE,
+	OP_START_RECORDING,
+	OP_QUERY,
+	OP_PING,
+};
+
+struct ng_flags_parse {
+	int via, to, packetize, transport;
+	bencode_item_t *dict, *flags, *direction, *replace, *rtcp_mux;
+};
+
+static const char *command_strings[] = {
+	[OP_OFFER]		= "offer",
+	[OP_ANSWER]		= "answer",
+	[OP_DELETE]		= "delete",
+	[OP_START_RECORDING]	= "start recording",
+	[OP_QUERY]		= "query",
+	[OP_PING]		= "ping",
+};
+
+static char *gencookie();
+static int rtpp_test(struct rtpp_node*, int, int);
+static int start_recording_f(struct sip_msg *, char *, char *);
+static int rtpengine_answer1_f(struct sip_msg *, char *, char *);
+static int rtpengine_offer1_f(struct sip_msg *, char *, char *);
+static int rtpengine_delete1_f(struct sip_msg *, char *, char *);
+static int rtpengine_manage1_f(struct sip_msg *, char *, char *);
+
+static int parse_flags(struct ng_flags_parse *, struct sip_msg *, enum rtpe_operation *, const char *);
+
+static int rtpengine_offer_answer(struct sip_msg *msg, const char *flags, int op, int more);
+static int fixup_set_id(void ** param, int param_no);
+static int set_rtpengine_set_f(struct sip_msg * msg, char * str1, char * str2);
+static struct rtpp_set * select_rtpp_set(int id_set);
+static struct rtpp_node *select_rtpp_node_new(str, str, int);
+static struct rtpp_node *select_rtpp_node_old(str, str, int);
+static struct rtpp_node *select_rtpp_node(str, str, int);
+static int build_rtpp_socks(unsigned int current_rtpp_no);
+static char *send_rtpp_command(struct rtpp_node *, bencode_item_t *, int *);
+static int get_extra_id(struct sip_msg* msg, str *id_str);
+
+static int rtpengine_set_store(modparam_t type, void * val);
+static int rtpengine_add_rtpengine_set(char * rtp_proxies, unsigned int weight, int disabled, unsigned int ticks);
+
+static int mod_init(void);
+static int child_init(int);
+static void mod_destroy(void);
+
+static int get_ip_type(char *str_addr);
+static int get_ip_scope(char *str_addr); // useful for link-local ipv6
+static int bind_force_send_ip(int sock_idx);
+
+static int add_rtpp_node_info(struct mi_node *node, struct rtpp_node *crt_rtpp, struct rtpp_set *rtpp_list);
+static int rtpp_test_ping(struct rtpp_node *node);
+
+/* Pseudo-Variables */
+static int pv_get_rtpstat_f(struct sip_msg *, pv_param_t *, pv_value_t *);
+static int set_rtp_inst_pvar(struct sip_msg *msg, const str * const uri);
+
+/*mi commands*/
+static struct mi_root* mi_enable_rtp_proxy(struct mi_root* cmd_tree, void* param);
+static struct mi_root* mi_show_rtp_proxy(struct mi_root* cmd_tree, void* param);
+static struct mi_root* mi_ping_rtp_proxy(struct mi_root* cmd_tree, void* param);
+static struct mi_root* mi_show_hash_total(struct mi_root* cmd_tree, void* param);
+static struct mi_root* mi_reload_rtp_proxy(struct mi_root* cmd_tree, void* param);
+
+
+static int rtpengine_disable_tout = 60;
+static int rtpengine_allow_op = 0;
+static int rtpengine_retr = 5;
+static int rtpengine_tout_ms = 1000;
+static int queried_nodes_limit = MAX_RTPP_TRIED_NODES;
+static pid_t mypid;
+static unsigned int myseqn = 0;
+static str extra_id_pv_param = {NULL, 0};
+static char *setid_avp_param = NULL;
+static int hash_table_tout = 3600;
+static int hash_table_size = 256;
+static int setid_default = DEFAULT_RTPP_SET_ID;
+
+static char ** rtpp_strings=0;
+static int rtpp_sets=0; /*used in rtpengine_set_store()*/
+static int rtpp_set_count = 0;
+static unsigned int current_msg_id = (unsigned int)-1;
+/* RTP proxy balancing list */
+static struct rtpp_set_head * rtpp_set_list =0;
+static struct rtpp_set * active_rtpp_set =0;
+static struct rtpp_set * selected_rtpp_set_1 =0;
+static struct rtpp_set * selected_rtpp_set_2 =0;
+static struct rtpp_set * default_rtpp_set=0;
+
+static str body_intermediate;
+
+static str rtp_inst_pv_param = {NULL, 0};
+static pv_spec_t *rtp_inst_pvar = NULL;
+
+/* array with the sockets used by rtpporxy (per process)*/
+static unsigned int *rtpp_no = 0;
+static gen_lock_t *rtpp_no_lock = 0;
+static int *rtpp_socks = 0;
+static unsigned int rtpp_socks_size = 0;
+
+static int setid_avp_type;
+static int_str setid_avp;
+
+static str write_sdp_pvar_str = {NULL, 0};
+static pv_spec_t *write_sdp_pvar = NULL;
+
+static str read_sdp_pvar_str = {NULL, 0};
+static pv_spec_t *read_sdp_pvar = NULL;
+
+#define RTPENGINE_SESS_LIMIT_MSG "Parallel session limit reached"
+#define RTPENGINE_SESS_LIMIT_MSG_LEN (sizeof(RTPENGINE_SESS_LIMIT_MSG)-1)
+
+char* force_send_ip_str="";
+int force_send_ip_af = AF_UNSPEC;
+
+typedef struct rtpp_set_link {
+	struct rtpp_set *rset;
+	pv_spec_t *rpv;
+} rtpp_set_link_t;
+
+/* tm */
+static struct tm_binds tmb;
+
+/*0-> disabled, 1 ->enabled*/
+unsigned int *natping_state=0;
+
+static pv_elem_t *extra_id_pv = NULL;
+
+static cmd_export_t cmds[] = {
+	{"set_rtpengine_set",	(cmd_function)set_rtpengine_set_f,	1,
+		fixup_set_id, 0,
+		ANY_ROUTE},
+	{"set_rtpengine_set",	(cmd_function)set_rtpengine_set_f,	2,
+		fixup_set_id, 0,
+		ANY_ROUTE},
+	{"start_recording",	(cmd_function)start_recording_f,	0,
+		0, 0,
+		ANY_ROUTE },
+	{"rtpengine_offer",	(cmd_function)rtpengine_offer1_f,	0,
+		0, 0,
+		ANY_ROUTE},
+	{"rtpengine_offer",	(cmd_function)rtpengine_offer1_f,	1,
+		fixup_spve_null, 0,
+		ANY_ROUTE},
+	{"rtpengine_answer",	(cmd_function)rtpengine_answer1_f,	0,
+		0, 0,
+		ANY_ROUTE},
+	{"rtpengine_answer",	(cmd_function)rtpengine_answer1_f,	1,
+		fixup_spve_null, 0,
+		ANY_ROUTE},
+	{"rtpengine_manage",	(cmd_function)rtpengine_manage1_f,	0,
+		0, 0,
+		ANY_ROUTE},
+	{"rtpengine_manage",	(cmd_function)rtpengine_manage1_f,	1,
+		fixup_spve_null, 0,
+		ANY_ROUTE},
+	{"rtpengine_delete",	(cmd_function)rtpengine_delete1_f,	0,
+		0, 0,
+		ANY_ROUTE},
+	{"rtpengine_delete",	(cmd_function)rtpengine_delete1_f,	1,
+		fixup_spve_null, 0,
+		ANY_ROUTE},
+	{0, 0, 0, 0, 0, 0}
+};
+
+static pv_export_t mod_pvs[] = {
+	{{"rtpstat", (sizeof("rtpstat")-1)}, /* RTP-Statistics */
+	PVT_OTHER, pv_get_rtpstat_f, 0, 0, 0, 0, 0},
+	{{0, 0}, 0, 0, 0, 0, 0, 0, 0}
+};
+
+static param_export_t params[] = {
+	{"rtpengine_sock",        PARAM_STRING|USE_FUNC_PARAM,
+	                         (void*)rtpengine_set_store          },
+	{"rtpengine_disable_tout",INT_PARAM, &rtpengine_disable_tout },
+	{"rtpengine_retr",        INT_PARAM, &rtpengine_retr         },
+	{"rtpengine_tout_ms",     INT_PARAM, &rtpengine_tout_ms      },
+	{"rtpengine_allow_op",    INT_PARAM, &rtpengine_allow_op     },
+	{"queried_nodes_limit",   INT_PARAM, &queried_nodes_limit    },
+	{"db_url",                PARAM_STR, &rtpp_db_url            },
+	{"table_name",            PARAM_STR, &rtpp_table_name        },
+	{"setid_col",             PARAM_STR, &rtpp_setid_col         },
+	{"url_col",               PARAM_STR, &rtpp_url_col           },
+	{"weight_col",            PARAM_STR, &rtpp_weight_col        },
+	{"disabled_col",          PARAM_STR, &rtpp_disabled_col      },
+	{"extra_id_pv",           PARAM_STR, &extra_id_pv_param      },
+	{"setid_avp",             PARAM_STRING, &setid_avp_param     },
+	{"force_send_interface",  PARAM_STRING, &force_send_ip_str   },
+	{"rtp_inst_pvar",         PARAM_STR, &rtp_inst_pv_param      },
+	{"write_sdp_pv",          PARAM_STR, &write_sdp_pvar_str     },
+	{"read_sdp_pv",           PARAM_STR, &read_sdp_pvar_str      },
+	{"hash_table_tout",       INT_PARAM, &hash_table_tout        },
+	{"hash_table_size",       INT_PARAM, &hash_table_size        },
+	{"setid_default",         INT_PARAM, &setid_default          },
+	{0, 0, 0}
+};
+
+static mi_export_t mi_cmds[] = {
+	{MI_ENABLE_RTP_PROXY,     mi_enable_rtp_proxy,  0,  0,  0},
+	{MI_SHOW_RTP_PROXIES,     mi_show_rtp_proxy,    0,  0,  0},
+	{MI_PING_RTP_PROXY,       mi_ping_rtp_proxy,    0,  0,  0},
+	{MI_SHOW_HASH_TOTAL,      mi_show_hash_total,   0,  0,  0},
+	{MI_RELOAD_RTP_PROXY,     mi_reload_rtp_proxy,  0,  0,  0},
+	{ 0, 0, 0, 0, 0}
+};
+
+
+struct module_exports exports = {
+	"rtpengine",
+	DEFAULT_DLFLAGS, /* dlopen flags */
+	cmds,
+	params,
+	0,           /* exported statistics */
+	mi_cmds,     /* exported MI functions */
+	mod_pvs,     /* exported pseudo-variables */
+	0,           /* extra processes */
+	mod_init,
+	0,           /* reply processing */
+	mod_destroy, /* destroy function */
+	child_init
+};
+
+/* hide the node from display and disable it permanent */
+int rtpengine_delete_node(struct rtpp_node *rtpp_node)
+{
+	rtpp_node->rn_displayed = 0;
+	rtpp_node->rn_disabled = MI_MAX_RECHECK_TICKS;
+
+	return 1;
+}
+
+
+int rtpengine_delete_node_set(struct rtpp_set *rtpp_list)
+{
+	struct rtpp_node *rtpp_node;
+
+	lock_get(rtpp_list->rset_lock);
+	for(rtpp_node = rtpp_list->rn_first; rtpp_node != NULL;
+			rtpp_node = rtpp_node->rn_next) {
+		rtpengine_delete_node(rtpp_node);
+	}
+	lock_release(rtpp_list->rset_lock);
+
+	return 1;
+}
+
+
+int rtpengine_delete_node_all()
+{
+	struct rtpp_set *rtpp_list;
+
+	if (!rtpp_set_list) {
+		return 1;
+	}
+
+	lock_get(rtpp_set_list->rset_head_lock);
+	for(rtpp_list = rtpp_set_list->rset_first; rtpp_list != NULL;
+			rtpp_list = rtpp_list->rset_next) {
+		rtpengine_delete_node_set(rtpp_list);
+	}
+	lock_release(rtpp_set_list->rset_head_lock);
+
+	return 1;
+}
+
+
+static int get_ip_type(char *str_addr)
+{
+	struct addrinfo hint, *info = NULL;
+	int ret;
+
+	memset(&hint, '\0', sizeof hint);
+	hint.ai_family = PF_UNSPEC;
+	hint.ai_flags = AI_NUMERICHOST;
+
+	ret = getaddrinfo(str_addr, NULL, &hint, &info);
+	if (ret) {
+		/* Invalid ip addinfos */
+		return -1;
+	}
+
+	if(info->ai_family == AF_INET) {
+		LM_DBG("%s is an ipv4 addinfos\n", str_addr);
+	} else if (info->ai_family == AF_INET6) {
+		LM_DBG("%s is an ipv6 addinfos\n", str_addr);
+	} else {
+		LM_DBG("%s is an unknown addinfos format AF=%d\n",str_addr, info->ai_family);
+		return -1;
+	}
+
+	ret = info->ai_family;
+
+	freeaddrinfo(info);
+
+	return ret;
+}
+
+
+static int get_ip_scope(char *str_addr)
+{
+	struct ifaddrs *ifaddr, *ifa;
+	struct sockaddr_in6 *in6;
+	char str_if_ip[NI_MAXHOST];
+	int ret = -1;
+
+	if (getifaddrs(&ifaddr) == -1) {
+		LM_ERR("getifaddrs() failed: %s\n", gai_strerror(ret));
+		return -1;
+	}
+
+	for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
+		in6 = (struct sockaddr_in6 *)ifa->ifa_addr;
+
+		if (ifa->ifa_addr == NULL)
+			continue;
+
+		if (ifa->ifa_addr->sa_family != AF_INET6)
+			continue;
+
+		ret = getnameinfo(ifa->ifa_addr, sizeof(struct sockaddr_in6),
+		str_if_ip, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);
+		if (ret != 0) {
+			LM_ERR("getnameinfo() failed: %s\n", gai_strerror(ret));
+			return -1;
+		}
+
+		if (strstr(str_if_ip, str_addr)) {
+			LM_INFO("dev: %-8s address: <%s> scope %d\n",
+			ifa->ifa_name, str_if_ip, in6->sin6_scope_id);
+			ret = in6->sin6_scope_id;
+			break;
+		}
+	}
+
+	freeifaddrs(ifaddr);
+
+	return ret;
+}
+
+
+static int bind_force_send_ip(int sock_idx)
+{
+	struct sockaddr_in tmp, ip4addr;
+	struct sockaddr_in6 tmp6, ip6addr;
+	char str_addr[INET_ADDRSTRLEN];
+	char str_addr6[INET6_ADDRSTRLEN];
+	socklen_t sock_len = sizeof(struct sockaddr);
+	int ret, scope;
+
+	switch (force_send_ip_af) {
+		case AF_INET:
+			memset(&ip4addr, 0, sizeof(ip4addr));
+			ip4addr.sin_family = AF_INET;
+			ip4addr.sin_port = htons(0);
+			inet_pton(AF_INET, force_send_ip_str, &ip4addr.sin_addr);
+
+			if (bind(rtpp_socks[sock_idx], (struct sockaddr*)&ip4addr, sizeof(ip4addr)) < 0) {
+				LM_ERR("can't bind socket to required ipv4 interface\n");
+				return -1;
+			}
+
+			memset(&tmp, 0, sizeof(tmp));
+			getsockname(rtpp_socks[sock_idx], (struct sockaddr *) &tmp, &sock_len);
+			inet_ntop(AF_INET, &tmp.sin_addr, str_addr, INET_ADDRSTRLEN);
+			LM_DBG("Binding on %s:%d\n", str_addr, ntohs(tmp.sin_port));
+
+			break;
+
+		case AF_INET6:
+			if ((scope = get_ip_scope(force_send_ip_str)) < 0) {
+				LM_ERR("can't get the ipv6 interface scope\n");
+				return -1;
+			}
+			memset(&ip6addr, 0, sizeof(ip6addr));
+			ip6addr.sin6_family = AF_INET6;
+			ip6addr.sin6_port = htons(0);
+			ip6addr.sin6_scope_id = scope;
+			inet_pton(AF_INET6, force_send_ip_str, &ip6addr.sin6_addr);
+
+			if ((ret = bind(rtpp_socks[sock_idx], (struct sockaddr*)&ip6addr, sizeof(ip6addr))) < 0) {
+				LM_ERR("can't bind socket to required ipv6 interface\n");
+				LM_ERR("ret=%d errno=%d\n", ret, errno);
+				return -1;
+			}
+
+			memset(&tmp6, 0, sizeof(tmp6));
+			getsockname(rtpp_socks[sock_idx], (struct sockaddr *) &tmp6, &sock_len);
+			inet_ntop(AF_INET6, &tmp6.sin6_addr, str_addr6, INET6_ADDRSTRLEN);
+			LM_DBG("Binding on ipv6 %s:%d\n", str_addr6, ntohs(tmp6.sin6_port));
+
+			break;
+
+		default:
+			LM_DBG("force_send_ip_str not specified in .cfg file!\n");
+			break;
+	}
+
+	return 0;
+}
+
+static inline int str_cmp(const str *a , const str *b) {
+	return ! (a->len == b->len && ! strncmp(a->s, b->s, a->len));
+}
+
+static inline int str_eq(const str *p, const char *q) {
+	int l = strlen(q);
+	if (p->len != l)
+		return 0;
+	if (memcmp(p->s, q, l))
+		return 0;
+	return 1;
+}
+
+static inline str str_prefix(const str *p, const char *q) {
+	str ret;
+	ret.s = NULL;
+	int l = strlen(q);
+	if (p->len < l)
+		return ret;
+	if (memcmp(p->s, q, l))
+		return ret;
+	ret = *p;
+	ret.s += l;
+	ret.len -= l;
+	return ret;
+}
+
+
+static int rtpengine_set_store(modparam_t type, void * val){
+
+	char * p;
+	int len;
+
+	p = (char* )val;
+
+	if(p==0 || *p=='\0'){
+		return 0;
+	}
+
+	if(rtpp_sets==0){
+		rtpp_strings = (char**)pkg_malloc(sizeof(char*));
+		if(!rtpp_strings){
+			LM_ERR("no pkg memory left\n");
+			return -1;
+		}
+	} else {/*realloc to make room for the current set*/
+		rtpp_strings = (char**)pkg_realloc(rtpp_strings, (rtpp_sets+1)* sizeof(char*));
+		if(!rtpp_strings){
+			LM_ERR("no pkg memory left\n");
+			return -1;
+		}
+	}
+
+	/*allocate for the current set of urls*/
+	len = strlen(p);
+	rtpp_strings[rtpp_sets] = (char*)pkg_malloc((len+1)*sizeof(char));
+
+	if(!rtpp_strings[rtpp_sets]){
+		LM_ERR("no pkg memory left\n");
+		return -1;
+	}
+
+	memcpy(rtpp_strings[rtpp_sets], p, len);
+	rtpp_strings[rtpp_sets][len] = '\0';
+	rtpp_sets++;
+
+	return 0;
+}
+
+struct rtpp_node *get_rtpp_node(struct rtpp_set *rtpp_list, str *url)
+{
+	struct rtpp_node *rtpp_node;
+
+	if (rtpp_list == NULL) {
+		return NULL;
+	}
+
+	lock_get(rtpp_list->rset_lock);
+	rtpp_node = rtpp_list->rn_first;
+	while (rtpp_node) {
+		if (str_cmp(&rtpp_node->rn_url, url) == 0) {
+			lock_release(rtpp_list->rset_lock);
+			return rtpp_node;
+		}
+		rtpp_node = rtpp_node->rn_next;
+	}
+	lock_release(rtpp_list->rset_lock);
+
+	return NULL;
+}
+
+struct rtpp_set *get_rtpp_set(int set_id)
+{
+	struct rtpp_set * rtpp_list;
+	unsigned int my_current_id = 0;
+	int new_list;
+
+	if (set_id < DEFAULT_RTPP_SET_ID )
+	{
+		LM_ERR(" invalid rtpproxy set value [%d]\n", set_id);
+		return NULL;
+	}
+
+	my_current_id = set_id;
+	/*search for the current_id*/
+	lock_get(rtpp_set_list->rset_head_lock);
+	rtpp_list = rtpp_set_list ? rtpp_set_list->rset_first : 0;
+	while (rtpp_list != 0 && rtpp_list->id_set!=my_current_id)
+		rtpp_list = rtpp_list->rset_next;
+
+	if (rtpp_list==NULL)
+	{	/*if a new id_set : add a new set of rtpp*/
+		rtpp_list = shm_malloc(sizeof(struct rtpp_set));
+		if(!rtpp_list)
+		{
+			lock_release(rtpp_set_list->rset_head_lock);
+			LM_ERR("no shm memory left to create new rtpproxy set %d\n", my_current_id);
+			return NULL;
+		}
+		memset(rtpp_list, 0, sizeof(struct rtpp_set));
+		rtpp_list->id_set = my_current_id;
+		rtpp_list->rset_lock = lock_alloc();
+		if (!rtpp_list->rset_lock) {
+			lock_release(rtpp_set_list->rset_head_lock);
+			LM_ERR("no shm memory left to create rtpproxy set lock\n");
+			shm_free(rtpp_list);
+			rtpp_list = NULL;
+			return NULL;
+		}
+		if (lock_init(rtpp_list->rset_lock) == 0) {
+			lock_release(rtpp_set_list->rset_head_lock);
+			LM_ERR("could not init rtpproxy set lock\n");
+			lock_dealloc((void*)rtpp_list->rset_lock);
+			rtpp_list->rset_lock = NULL;
+			shm_free(rtpp_list);
+			rtpp_list = NULL;
+			return NULL;
+		}
+		new_list = 1;
+	}
+	else {
+		new_list = 0;
+	}
+
+	if (new_list)
+	{
+		/*update the list of set info*/
+		if (!rtpp_set_list->rset_first)
+		{
+			rtpp_set_list->rset_first = rtpp_list;
+		}
+		else
+		{
+			rtpp_set_list->rset_last->rset_next = rtpp_list;
+		}
+
+		rtpp_set_list->rset_last = rtpp_list;
+		rtpp_set_count++;
+
+		if(my_current_id == DEFAULT_RTPP_SET_ID){
+			default_rtpp_set = rtpp_list;
+		}
+	}
+	lock_release(rtpp_set_list->rset_head_lock);
+
+	return rtpp_list;
+}
+
+
+int add_rtpengine_socks(struct rtpp_set * rtpp_list, char * rtpproxy,
+			unsigned int weight, int disabled, unsigned int ticks, int isDB)
+{
+	/* Make rtp proxies list. */
+	char *p, *p1, *p2, *plim;
+	struct rtpp_node *pnode;
+	struct rtpp_node *rtpp_node;
+	unsigned int local_weight, port;
+	str s1;
+
+	p = rtpproxy;
+	plim = p + strlen(p);
+
+	for(;;) {
+		local_weight = weight;
+		while (*p && isspace((int)*p))
+			++p;
+		if (p >= plim)
+			break;
+		p1 = p;
+		while (*p && !isspace((int)*p))
+			++p;
+		if (p <= p1)
+			break; /* may happen??? */
+		p2 = p;
+
+		/* if called for database, consider simple, single char *URL */
+		/* if called for config, consider weight URL */
+		if (!isDB) {
+			/* Have weight specified? If yes, scan it */
+			p2 = memchr(p1, '=', p - p1);
+			if (p2 != NULL) {
+				local_weight = strtoul(p2 + 1, NULL, 10);
+			} else {
+				p2 = p;
+			}
+		}
+
+		pnode = shm_malloc(sizeof(struct rtpp_node));
+		if (pnode == NULL) {
+			LM_ERR("no shm memory left\n");
+			return -1;
+		}
+		memset(pnode, 0, sizeof(*pnode));
+
+		lock_get(rtpp_no_lock);
+		pnode->idx = *rtpp_no;
+
+		if (ticks == MI_MAX_RECHECK_TICKS) {
+			pnode->rn_recheck_ticks = ticks;
+		} else {
+			pnode->rn_recheck_ticks = ticks + get_ticks();
+		}
+		pnode->rn_weight = local_weight;
+		pnode->rn_umode = 0;
+		pnode->rn_disabled = disabled;
+		pnode->rn_displayed = 1;
+		pnode->rn_url.s = shm_malloc(p2 - p1 + 1);
+		if (pnode->rn_url.s == NULL) {
+			lock_release(rtpp_no_lock);
+			shm_free(pnode);
+			LM_ERR("no shm memory left\n");
+			return -1;
+		}
+		memmove(pnode->rn_url.s, p1, p2 - p1);
+		pnode->rn_url.s[p2 - p1] = 0;
+		pnode->rn_url.len = p2-p1;
+
+		/* Leave only address in rn_address */
+		pnode->rn_address = pnode->rn_url.s;
+		if (strncasecmp(pnode->rn_address, "udp:", 4) == 0) {
+			pnode->rn_umode = 1;
+			pnode->rn_address += 4;
+		} else if (strncasecmp(pnode->rn_address, "udp6:", 5) == 0) {
+			pnode->rn_umode = 6;
+			pnode->rn_address += 5;
+		} else if (strncasecmp(pnode->rn_address, "unix:", 5) == 0) {
+			pnode->rn_umode = 0;
+			pnode->rn_address += 5;
+		} else {
+			lock_release(rtpp_no_lock);
+			LM_WARN("Node address must start with 'udp:' or 'udp6:' or 'unix:'. Ignore '%s'.\n", pnode->rn_address);
+			shm_free(pnode->rn_url.s);
+			shm_free(pnode);
+
+			if (!isDB) {
+				continue;
+			} else {
+				return 0;
+			}
+		}
+
+		/* Check the rn_address is 'hostname:port' */
+		/* Check the rn_address port is valid */
+		p1 = strchr(pnode->rn_address, ':');
+		if (p1 != NULL) {
+			p1++;
+		}
+
+		if (p1 != NULL && p1 != '\0') {
+			s1.s = p1;
+			s1.len = strlen(p1);
+			if (str2int(&s1, &port) < 0 || port > 0xFFFF) {
+				lock_release(rtpp_no_lock);
+				LM_WARN("Node address must end with a valid port number. Ignore '%s'.\n", pnode->rn_address);
+				shm_free(pnode->rn_url.s);
+				shm_free(pnode);
+
+				if (!isDB) {
+					continue;
+				} else {
+					return 0;
+				}
+			}
+		}
+
+		/* If node found in set, update it */
+		rtpp_node = get_rtpp_node(rtpp_list, &pnode->rn_url);
+
+		lock_get(rtpp_list->rset_lock);
+		if (rtpp_node) {
+			rtpp_node->rn_disabled = pnode->rn_disabled;
+			rtpp_node->rn_displayed = pnode->rn_displayed;
+			rtpp_node->rn_recheck_ticks = pnode->rn_recheck_ticks;
+			rtpp_node->rn_weight = pnode->rn_weight;
+			lock_release(rtpp_list->rset_lock);
+			lock_release(rtpp_no_lock);
+
+			shm_free(pnode->rn_url.s);
+			shm_free(pnode);
+
+			if (!isDB) {
+				continue;
+			} else {
+				return 0;
+			}
+		}
+
+		if (rtpp_list->rn_first == NULL) {
+			rtpp_list->rn_first = pnode;
+		} else {
+			rtpp_list->rn_last->rn_next = pnode;
+		}
+
+		rtpp_list->rn_last = pnode;
+		rtpp_list->rtpp_node_count++;
+		lock_release(rtpp_list->rset_lock);
+
+		*rtpp_no = *rtpp_no + 1;
+		lock_release(rtpp_no_lock);
+
+		if (!isDB) {
+			continue;
+		} else {
+			return 0;
+		}
+	}
+	return 0;
+}
+
+
+/* 0 - succes
+ * -1 - erorr
+ * */
+static int rtpengine_add_rtpengine_set(char * rtp_proxies, unsigned int weight, int disabled, unsigned int ticks)
+{
+	char *p,*p2;
+	struct rtpp_set * rtpp_list;
+	unsigned int my_current_id;
+	str id_set;
+
+	/* empty definition? */
+	p= rtp_proxies;
+	if(!p || *p=='\0'){
+		return 0;
+	}
+
+	for(;*p && isspace(*p);p++);
+	if(*p=='\0'){
+		return 0;
+	}
+
+	rtp_proxies = strstr(p, "==");
+	if(rtp_proxies){
+		if(*(rtp_proxies +2)=='\0'){
+			LM_ERR("script error -invalid rtp proxy list!\n");
+			return -1;
+		}
+
+		*rtp_proxies = '\0';
+		p2 = rtp_proxies-1;
+		for(;isspace(*p2); *p2 = '\0',p2--);
+		id_set.s = p;	id_set.len = p2 - p+1;
+
+		if(id_set.len <= 0 ||str2int(&id_set, &my_current_id)<0 ){
+		LM_ERR("script error -invalid set_id value!\n");
+			return -1;
+		}
+
+		rtp_proxies+=2;
+	}else{
+		rtp_proxies = p;
+		my_current_id = DEFAULT_RTPP_SET_ID;
+	}
+
+	for(;*rtp_proxies && isspace(*rtp_proxies);rtp_proxies++);
+
+	if(!(*rtp_proxies)){
+		LM_ERR("script error -empty rtp_proxy list\n");
+		return -1;;
+	}
+
+	/*search for the current_id*/
+	rtpp_list = get_rtpp_set(my_current_id);
+
+	if (rtpp_list != NULL)
+	{
+
+		if (add_rtpengine_socks(rtpp_list, rtp_proxies, weight, disabled, ticks, 0) != 0)
+			goto error;
+		else
+			return 0;
+	}
+
+error:
+	return -1;
+}
+
+
+static int fixup_set_id(void ** param, int param_no)
+{
+	int int_val, err;
+	struct rtpp_set* rtpp_list;
+	rtpp_set_link_t *rtpl = NULL;
+	str s;
+
+	rtpl = (rtpp_set_link_t*)pkg_malloc(sizeof(rtpp_set_link_t));
+	if(rtpl==NULL) {
+		LM_ERR("no more pkg memory\n");
+		return -1;
+	}
+	memset(rtpl, 0, sizeof(rtpp_set_link_t));
+	s.s = (char*)*param;
+	s.len = strlen(s.s);
+
+	if(s.s[0] == PV_MARKER) {
+		int_val = pv_locate_name(&s);
+		if(int_val<0 || int_val!=s.len) {
+			LM_ERR("invalid parameter %s\n", s.s);
+			return -1;
+		}
+		rtpl->rpv = pv_cache_get(&s);
+		if(rtpl->rpv == NULL) {
+			LM_ERR("invalid pv parameter %s\n", s.s);
+			return -1;
+		}
+	} else {
+		int_val = str2s(*param, strlen(*param), &err);
+		if (err == 0) {
+			pkg_free(*param);
+			if((rtpp_list = select_rtpp_set(int_val)) ==0){
+				LM_ERR("rtpp_proxy set %i not configured\n", int_val);
+				return E_CFG;
+			}
+			rtpl->rset = rtpp_list;
+		} else {
+			LM_ERR("bad number <%s>\n",	(char *)(*param));
+			return E_CFG;
+		}
+	}
+	*param = (void*)rtpl;
+	return 0;
+}
+
+static int rtpp_test_ping(struct rtpp_node *node)
+{
+	bencode_buffer_t bencbuf;
+	bencode_item_t *dict;
+	char *cp;
+	int ret;
+
+	if (bencode_buffer_init(&bencbuf)) {
+		return -1;
+	}
+	dict = bencode_dictionary(&bencbuf);
+	bencode_dictionary_add_string(dict, "command", command_strings[OP_PING]);
+
+	if (bencbuf.error) {
+		goto error;
+	}
+
+	cp = send_rtpp_command(node, dict, &ret);
+	if (!cp) {
+		goto error;
+	}
+
+	dict = bencode_decode_expect(&bencbuf, cp, ret, BENCODE_DICTIONARY);
+	if (!dict || bencode_dictionary_get_strcmp(dict, "result", "pong")) {
+		goto error;
+	}
+
+	bencode_buffer_free(&bencbuf);
+	return 0;
+
+error:
+	bencode_buffer_free(&bencbuf);
+	return -1;
+}
+
+static struct mi_root* mi_enable_rtp_proxy(struct mi_root *cmd_tree, void *param)
+{
+	struct mi_node *node, *crt_node;
+	struct rtpp_set *rtpp_list;
+	struct rtpp_node *crt_rtpp, *found_rtpp;
+	struct mi_root *root = NULL;
+	struct mi_attr *attr;
+	unsigned int enable;
+	int found, found_rtpp_disabled;
+	str rtpp_url;
+	str snode, sattr, svalue;
+
+	found = MI_FOUND_NONE;
+	found_rtpp_disabled = 0;
+	found_rtpp = NULL;
+	enable = 0;
+
+	if (rtpp_set_list == NULL) {
+		return init_mi_tree(404, MI_RTP_PROXY_NOT_FOUND, MI_RTP_PROXY_NOT_FOUND_LEN);
+	}
+
+	node = cmd_tree->node.kids;
+	if (node == NULL) {
+		return init_mi_tree(400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
+	}
+
+	if (node->value.s == NULL || node->value.len ==0) {
+		return init_mi_tree(400, MI_BAD_PARM_S, MI_BAD_PARM_LEN);
+	}
+
+	/* get proxy */
+	rtpp_url = node->value;
+
+	node = node->next;
+	if (node == NULL) {
+		return init_mi_tree(400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
+	}
+
+	if (node->value.s == NULL || node->value.len ==0) {
+		return init_mi_tree(400, MI_BAD_PARM_S, MI_BAD_PARM_LEN);
+	}
+
+	/* get value (enable/disable) */
+	if(strno2int(&node->value, &enable) < 0) {
+		goto error;
+	}
+
+	node = node->next;
+	if (node != NULL) {
+		return init_mi_tree(400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
+	}
+
+	/* found a matching all - show all rtpp */
+	if (strncmp(MI_ALL, rtpp_url.s, MI_ALL_LEN) == 0) {
+		found = MI_FOUND_ALL;
+	}
+
+	lock_get(rtpp_set_list->rset_head_lock);
+	for(rtpp_list = rtpp_set_list->rset_first; rtpp_list != NULL;
+			rtpp_list = rtpp_list->rset_next) {
+
+		lock_get(rtpp_list->rset_lock);
+		for(crt_rtpp = rtpp_list->rn_first; crt_rtpp != NULL;
+				crt_rtpp = crt_rtpp->rn_next) {
+
+			if (!crt_rtpp->rn_displayed) {
+				continue;
+			}
+
+			/* found a matching rtpp - show it */
+			if (found == MI_FOUND_ALL ||
+			   (crt_rtpp->rn_url.len == rtpp_url.len &&
+			   strncmp(crt_rtpp->rn_url.s, rtpp_url.s, rtpp_url.len) == 0)) {
+
+				/* do ping when try to enable the rtpp */
+				if (enable) {
+
+					/* if ping success, enable the rtpp and reset ticks */
+					if (rtpp_test_ping(crt_rtpp) == 0) {
+						crt_rtpp->rn_disabled = 0;
+						crt_rtpp->rn_recheck_ticks = MI_MIN_RECHECK_TICKS;
+
+					/* if ping fail, disable the rtpps but _not_ permanently*/
+					} else {
+						crt_rtpp->rn_recheck_ticks = get_ticks() + rtpengine_disable_tout;
+						crt_rtpp->rn_disabled = 1;
+						found_rtpp_disabled = 1;
+					}
+
+				/* do not ping when disable the rtpp; disable it permanenty */
+				} else {
+					crt_rtpp->rn_disabled = 1;
+					crt_rtpp->rn_recheck_ticks = MI_MAX_RECHECK_TICKS;
+				}
+
+				if (found == MI_FOUND_NONE) {
+					found = MI_FOUND_ONE;
+					found_rtpp = crt_rtpp;
+				}
+			}
+		}
+		lock_release(rtpp_list->rset_lock);
+	}
+	lock_release(rtpp_set_list->rset_head_lock);
+
+	root = init_mi_tree(200, MI_OK_S, MI_OK_LEN);
+	if (!root) {
+		LM_ERR("the MI tree cannot be initialized!\n");
+		return 0;
+	}
+	node = &root->node;
+
+	switch (found) {
+		case MI_FOUND_ALL:
+			snode.s = MI_ALL;
+			snode.len = MI_ALL_LEN;
+			break;
+		case MI_FOUND_ONE:
+			snode.s = found_rtpp->rn_url.s;
+			snode.len = found_rtpp->rn_url.len;
+			break;
+		default:
+			if (root) {
+				free_mi_tree(root);
+			}
+			return init_mi_tree(404, MI_RTP_PROXY_NOT_FOUND, MI_RTP_PROXY_NOT_FOUND_LEN);
+	}
+
+	svalue.s = MI_SUCCESS;
+	svalue.len = MI_SUCCESS_LEN;
+
+	if (enable) {
+		sattr.s = MI_ENABLE;
+		sattr.len = MI_ENABLE_LEN;
+
+		if (found_rtpp_disabled) {
+			svalue.s = MI_FAIL;
+			svalue.len = MI_FAIL_LEN;
+		}
+	} else {
+		sattr.s = MI_DISABLE;
+		sattr.len = MI_DISABLE_LEN;
+	}
+
+	if (!(crt_node = add_mi_node_child(node, 0, snode.s, snode.len, 0, 0))) {
+		LM_ERR("cannot add the child node to the tree\n");
+		goto error;
+	}
+
+	if ((attr = add_mi_attr(crt_node, MI_DUP_VALUE, sattr.s, sattr.len, svalue.s, svalue.len)) == 0) {
+		LM_ERR("cannot add attributes to the node\n");
+		goto error;
+	}
+
+
+	return root;
+
+error:
+	if (root) {
+		free_mi_tree(root);
+	}
+	return init_mi_tree(404, MI_ERROR, MI_ERROR_LEN);
+}
+
+
+
+
+#define add_rtpp_node_int_info(_parent, _name, _name_len, _value, _child,\
+								_len, _string, _error)\
+	do {\
+		(_string) = int2str((_value), &(_len));\
+		if((_string) == 0){\
+			LM_ERR("cannot convert int value\n");\
+				goto _error;\
+		}\
+		if(((_child) = add_mi_node_child((_parent), MI_DUP_VALUE, (_name), \
+				(_name_len), (_string), (_len))) == 0)\
+			goto _error;\
+	}while(0);
+
+
+static int add_rtpp_node_info (struct mi_node *node, struct rtpp_node *crt_rtpp, struct rtpp_set *rtpp_list)
+{
+	int id_len, len;
+	int rtpp_ticks;
+	struct mi_node *crt_node, *child;
+	struct mi_attr *attr;
+	char *string, *id;
+
+	string = id = 0;
+
+	id = int2str(rtpp_list->id_set, &id_len);
+	if (!id) {
+		LM_ERR("cannot convert set id\n");
+		goto error;
+	}
+
+	if (!(crt_node = add_mi_node_child(node, 0, crt_rtpp->rn_url.s, crt_rtpp->rn_url.len, 0,0))) {
+		LM_ERR("cannot add the child node to the tree\n");
+		goto error;
+	}
+
+	LM_DBG("adding node name %s \n",crt_rtpp->rn_url.s );
+
+	if ((attr = add_mi_attr(crt_node, MI_DUP_VALUE, MI_SET, MI_SET_LEN, id, id_len)) == 0) {
+		LM_ERR("cannot add attributes to the node\n");
+		goto error;
+	}
+
+	add_rtpp_node_int_info(crt_node, MI_INDEX, MI_INDEX_LEN,
+		crt_rtpp->idx, child, len, string, error);
+
+	if ((1 == crt_rtpp->rn_disabled ) && (crt_rtpp->rn_recheck_ticks == MI_MAX_RECHECK_TICKS)) {
+		if (!(child = add_mi_node_child(crt_node, MI_DUP_VALUE, MI_DISABLED, MI_DISABLED_LEN,
+		   MI_DISABLED_PERMANENT, MI_DISABLED_PERMANENT_LEN))) {
+			LM_ERR("cannot add disabled (permanent) message\n");
+			goto error;
+		}
+	} else {
+		add_rtpp_node_int_info(crt_node, MI_DISABLED, MI_DISABLED_LEN,
+			crt_rtpp->rn_disabled, child, len, string, error);
+	}
+
+	add_rtpp_node_int_info(crt_node, MI_WEIGHT, MI_WEIGHT_LEN,
+		crt_rtpp->rn_weight, child, len, string, error);
+
+	if (crt_rtpp->rn_recheck_ticks == MI_MAX_RECHECK_TICKS) {
+		if (!(child = add_mi_node_child(crt_node, MI_DUP_VALUE,
+		   MI_RECHECK_TICKS, MI_RECHECK_T_LEN,
+		   "N/A", sizeof("N/A") - 1))) {
+			LM_ERR("cannot add MAX recheck_ticks value\n");
+			goto error;
+		}
+	} else {
+		rtpp_ticks = crt_rtpp->rn_recheck_ticks - get_ticks();
+		rtpp_ticks = rtpp_ticks < 0 ? 0 : rtpp_ticks;
+		add_rtpp_node_int_info(crt_node, MI_RECHECK_TICKS, MI_RECHECK_T_LEN,
+			rtpp_ticks, child, len, string, error);
+	}
+
+	return 0;
+
+error:
+	return -1;
+}
+
+static struct mi_root* mi_show_rtp_proxy(struct mi_root* cmd_tree, void* param)
+{
+	struct mi_node *node;
+	struct mi_root *root = NULL;
+	struct rtpp_set *rtpp_list;
+	struct rtpp_node *crt_rtpp;
+	int found;
+	str rtpp_url;
+
+	found = MI_FOUND_NONE;
+
+	if (rtpp_set_list == NULL) {
+		return init_mi_tree(404, MI_RTP_PROXY_NOT_FOUND, MI_RTP_PROXY_NOT_FOUND_LEN);
+	}
+
+	node = cmd_tree->node.kids;
+	if (node == NULL) {
+		return init_mi_tree( 400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
+	}
+
+	if (node->value.s == NULL || node->value.len ==0) {
+		return init_mi_tree( 400, MI_BAD_PARM_S, MI_BAD_PARM_LEN);
+	}
+
+	rtpp_url = node->value;
+	if (strncmp(MI_ALL, rtpp_url.s, MI_ALL_LEN) != 0 && rtpp_set_list == NULL) {
+		return init_mi_tree(404, MI_RTP_PROXY_NOT_FOUND, MI_RTP_PROXY_NOT_FOUND_LEN);
+	}
+
+	node = node->next;
+	if (node != NULL) {
+		return init_mi_tree( 400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
+	}
+
+	root = init_mi_tree(200, MI_OK_S, MI_OK_LEN);
+	if (!root) {
+		LM_ERR("the MI tree cannot be initialized!\n");
+		return 0;
+	}
+
+	node = &root->node;
+
+	/* found a matching all - show all rtpp */
+	if (strncmp(MI_ALL, rtpp_url.s, MI_ALL_LEN) == 0) {
+		found = MI_FOUND_ALL;
+	}
+
+	lock_get(rtpp_set_list->rset_head_lock);
+	for(rtpp_list = rtpp_set_list->rset_first; rtpp_list != NULL;
+			rtpp_list = rtpp_list->rset_next) {
+
+		lock_get(rtpp_list->rset_lock);
+		for(crt_rtpp = rtpp_list->rn_first; crt_rtpp != NULL;
+				crt_rtpp = crt_rtpp->rn_next) {
+
+			if (!crt_rtpp->rn_displayed) {
+				continue;
+			}
+
+			/* found a matching rtpp - show it */
+			if (found == MI_FOUND_ALL ||
+			   (crt_rtpp->rn_url.len == rtpp_url.len &&
+			   strncmp(crt_rtpp->rn_url.s, rtpp_url.s, rtpp_url.len) == 0)) {
+
+				if (add_rtpp_node_info(node, crt_rtpp, rtpp_list) < 0) {
+					lock_release(rtpp_list->rset_lock);
+					lock_release(rtpp_set_list->rset_head_lock);
+					goto error;
+				}
+
+				if (found == MI_FOUND_NONE) {
+					found = MI_FOUND_ONE;
+				}
+			}
+		}
+		lock_release(rtpp_list->rset_lock);
+	}
+	lock_release(rtpp_set_list->rset_head_lock);
+
+	switch (found) {
+		case MI_FOUND_ALL:
+		case MI_FOUND_ONE:
+			break;
+		default:
+			if (root) {
+				free_mi_tree(root);
+			}
+			return init_mi_tree(404, MI_RTP_PROXY_NOT_FOUND, MI_RTP_PROXY_NOT_FOUND_LEN);
+	}
+
+	return root;
+
+error:
+	if (root) {
+		free_mi_tree(root);
+	}
+	return init_mi_tree(404, MI_ERROR, MI_ERROR_LEN);
+}
+
+static struct mi_root* mi_ping_rtp_proxy(struct mi_root* cmd_tree, void* param)
+{
+	struct mi_node *node, *crt_node;
+	struct mi_attr *attr;
+	struct mi_root *root = NULL;
+	struct rtpp_set *rtpp_list;
+	struct rtpp_node *crt_rtpp, *found_rtpp;
+	int found, found_rtpp_disabled;
+	str rtpp_url;
+	str snode, sattr, svalue;
+
+	found = 0;
+	found_rtpp_disabled = 0;
+	found_rtpp = NULL;
+
+	if (rtpp_set_list == NULL) {
+		return init_mi_tree(404, MI_RTP_PROXY_NOT_FOUND, MI_RTP_PROXY_NOT_FOUND_LEN);
+	}
+
+	node = cmd_tree->node.kids;
+	if (node == NULL) {
+		return init_mi_tree( 400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
+	}
+
+	if (node->value.s == NULL || node->value.len ==0) {
+		return init_mi_tree( 400, MI_BAD_PARM_S, MI_BAD_PARM_LEN);
+	}
+
+	rtpp_url = node->value;
+
+	node = node->next;
+	if (node != NULL) {
+		return init_mi_tree( 400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
+	}
+
+	/* found a matching all - ping all rtpp */
+	if (strncmp(MI_ALL, rtpp_url.s, MI_ALL_LEN) == 0) {
+		found = MI_FOUND_ALL;
+	}
+
+	lock_get(rtpp_set_list->rset_head_lock);
+	for (rtpp_list = rtpp_set_list->rset_first; rtpp_list != NULL;
+			rtpp_list = rtpp_list->rset_next) {
+
+		lock_get(rtpp_list->rset_lock);
+		for (crt_rtpp = rtpp_list->rn_first; crt_rtpp != NULL;
+				crt_rtpp = crt_rtpp->rn_next) {
+
+			if (!crt_rtpp->rn_displayed) {
+				continue;
+			}
+
+			/* found a matching rtpp - ping it */
+			if (found == MI_FOUND_ALL ||
+			   (crt_rtpp->rn_url.len == rtpp_url.len &&
+			   strncmp(crt_rtpp->rn_url.s, rtpp_url.s, rtpp_url.len) == 0)) {
+
+				/* if ping fail */
+				if (rtpp_test_ping(crt_rtpp) < 0) {
+					crt_rtpp->rn_recheck_ticks = get_ticks() + rtpengine_disable_tout;
+					found_rtpp_disabled = 1;
+					crt_rtpp->rn_disabled = 1;
+				}
+
+				if (found == MI_FOUND_NONE) {
+					found = MI_FOUND_ONE;
+					found_rtpp = crt_rtpp;
+				}
+			}
+		}
+		lock_release(rtpp_list->rset_lock);
+	}
+	lock_release(rtpp_set_list->rset_head_lock);
+
+	root = init_mi_tree(200, MI_OK_S, MI_OK_LEN);
+	if (!root) {
+		LM_ERR("the MI tree cannot be initialized!\n");
+		return 0;
+	}
+
+	node = &root->node;
+
+	switch (found) {
+		case MI_FOUND_ALL:
+			snode.s = MI_ALL;
+			snode.len = MI_ALL_LEN;
+			break;
+		case MI_FOUND_ONE:
+			snode.s = found_rtpp->rn_url.s;
+			snode.len = found_rtpp->rn_url.len;
+			break;
+		default:
+			if (root) {
+				free_mi_tree(root);
+			}
+			return init_mi_tree(404, MI_RTP_PROXY_NOT_FOUND, MI_RTP_PROXY_NOT_FOUND_LEN);
+	}
+
+	sattr.s = MI_PING;
+	sattr.len = MI_PING_LEN;
+
+	if (found_rtpp_disabled) {
+		svalue.s = MI_FAIL;
+		svalue.len = MI_FAIL_LEN;
+	} else {
+		svalue.s = MI_SUCCESS;
+		svalue.len = MI_SUCCESS_LEN;
+	}
+
+	if (!(crt_node = add_mi_node_child(node, 0, snode.s, snode.len, 0, 0))) {
+		LM_ERR("cannot add the child node to the tree\n");
+		goto error;
+	}
+
+	if ((attr = add_mi_attr(crt_node, MI_DUP_VALUE, sattr.s, sattr.len, svalue.s, svalue.len)) == 0) {
+		LM_ERR("cannot add attributes to the node\n");
+		goto error;
+	}
+
+	return root;
+
+error:
+	if (root) {
+		free_mi_tree(root);
+	}
+	return init_mi_tree(404, MI_ERROR, MI_ERROR_LEN);
+}
+
+
+static struct mi_root* mi_show_hash_total(struct mi_root* cmd_tree, void* param)
+{
+	struct mi_node *node, *crt_node;
+	struct mi_attr *attr;
+	struct mi_root *root = NULL;
+	unsigned int total;
+	str total_str;
+
+	// Init print tree
+	root = init_mi_tree(200, MI_OK_S, MI_OK_LEN);
+	if (!root) {
+		LM_ERR("the MI tree cannot be initialized!\n");
+		return 0;
+	}
+	node = &root->node;
+
+	// Create new node and add it to the roots's kids
+	if (!(crt_node = add_mi_node_child(node, MI_DUP_NAME, "total", strlen("total"), 0, 0))) {
+		LM_ERR("cannot add the child node to the tree\n");
+		goto error;
+	}
+
+	// Get total number of entries
+	total = rtpengine_hash_table_total();
+	total_str.s = int2str(total, &total_str.len);
+
+	// Add node attributes
+	if ((attr = add_mi_attr(crt_node, MI_DUP_VALUE, MI_HASH_ENTRIES, MI_HASH_ENTRIES_LEN, total_str.s, total_str.len)) == 0) {
+		LM_ERR("cannot add attributes to the node\n");
+		goto error;
+	}
+
+	return root;
+
+error:
+	if (root) {
+		free_mi_tree(root);
+	}
+
+	return init_mi_tree(404, MI_HASH_ENTRIES_FAIL, MI_HASH_ENTRIES_FAIL_LEN);
+}
+
+static struct mi_root*
+mi_reload_rtp_proxy(struct mi_root* cmd_tree, void* param)
+{
+	struct mi_root *root = NULL;
+	unsigned int current_rtpp_no;
+
+	if (rtpp_db_url.s == NULL) {
+		// no database
+		root = init_mi_tree(404, MI_DB_NOT_FOUND, MI_DB_NOT_FOUND_LEN);
+		if (!root) {
+			LM_ERR("the MI tree cannot be initialized!\n");
+			return 0;
+		}
+	} else {
+		if (init_rtpproxy_db() < 0) {
+			// fail reloading from database
+			root = init_mi_tree(404, MI_DB_ERR, MI_DB_ERR_LEN);
+			if (!root) {
+				LM_ERR("the MI tree cannot be initialized!\n");
+				return 0;
+			}
+		} else {
+			lock_get(rtpp_no_lock);
+			current_rtpp_no = *rtpp_no;
+			lock_release(rtpp_no_lock);
+
+			if (rtpp_socks_size != current_rtpp_no) {
+				build_rtpp_socks(current_rtpp_no);
+			}
+
+			// success reloading from database
+			root = init_mi_tree(200, MI_DB_OK, MI_DB_OK_LEN);
+			if (!root) {
+				LM_ERR("the MI tree cannot be initialized!\n");
+				return 0;
+			}
+		}
+	}
+
+	return root;
+}
+
+
+static int
+mod_init(void)
+{
+	int i;
+	pv_spec_t *avp_spec;
+	unsigned short avp_flags;
+	str s;
+
+	if(register_mi_mod(exports.name, mi_cmds)!=0)
+	{
+		LM_ERR("failed to register MI commands\n");
+		return -1;
+	}
+
+	rtpp_no = (unsigned int*)shm_malloc(sizeof(unsigned int));
+	if (!rtpp_no) {
+		LM_ERR("no more shm memory for rtpp_no\n");
+		return -1;
+	}
+	*rtpp_no = 0;
+
+	rtpp_no_lock = lock_alloc();
+	if (!rtpp_no_lock) {
+		LM_ERR("no more shm memory for rtpp_no_lock\n");
+		return -1;
+	}
+
+	if (lock_init(rtpp_no_lock) == 0) {
+		LM_ERR("could not init rtpp_no_lock\n");
+		return -1;
+	}
+
+	/* initialize the list of set; mod_destroy does shm_free() if fail */
+	if (!rtpp_set_list) {
+		rtpp_set_list = shm_malloc(sizeof(struct rtpp_set_head));
+		if(!rtpp_set_list){
+			LM_ERR("no shm memory left to create list of proxysets\n");
+			return -1;
+		}
+		memset(rtpp_set_list, 0, sizeof(struct rtpp_set_head));
+
+		rtpp_set_list->rset_head_lock = lock_alloc();
+		if (!rtpp_set_list->rset_head_lock) {
+			LM_ERR("no shm memory left to create list of proxysets lock\n");
+			return -1;
+		}
+
+		if (lock_init(rtpp_set_list->rset_head_lock) == 0) {
+			LM_ERR("could not init rtpproxy list of proxysets lock\n");
+			return -1;
+		}
+	}
+
+	if (rtpp_db_url.s == NULL)
+	{
+		/* storing the list of rtp proxy sets in shared memory*/
+		for(i=0;i<rtpp_sets;i++){
+			if(rtpengine_add_rtpengine_set(rtpp_strings[i], 1, 0, 0) !=0){
+				for(;i<rtpp_sets;i++)
+					if(rtpp_strings[i])
+						pkg_free(rtpp_strings[i]);
+				pkg_free(rtpp_strings);
+				return -1;
+			}
+			if(rtpp_strings[i])
+				pkg_free(rtpp_strings[i]);
+		}
+	}
+	else
+	{
+		LM_INFO("Loading rtp proxy definitions from DB\n");
+		if ( init_rtpproxy_db() < 0)
+		{
+			LM_ERR("error while loading rtp proxies from database\n");
+			return -1;
+		}
+	}
+
+	/* any rtpproxy configured? */
+	if (rtpp_set_list)
+		default_rtpp_set = select_rtpp_set(DEFAULT_RTPP_SET_ID);
+
+	if (rtp_inst_pv_param.s) {
+		rtp_inst_pv_param.len = strlen(rtp_inst_pv_param.s);
+		rtp_inst_pvar = pv_cache_get(&rtp_inst_pv_param);
+		if ((rtp_inst_pvar == NULL) ||
+		   ((rtp_inst_pvar->type != PVT_AVP) &&
+		   (rtp_inst_pvar->type != PVT_XAVP) &&
+		   (rtp_inst_pvar->type != PVT_SCRIPTVAR))) {
+			LM_ERR("Invalid pvar name <%.*s>\n", rtp_inst_pv_param.len, rtp_inst_pv_param.s);
+			return -1;
+		}
+	}
+
+	if (extra_id_pv_param.s && *extra_id_pv_param.s) {
+		extra_id_pv_param.len = strlen(extra_id_pv_param.s);
+		if(pv_parse_format(&extra_id_pv_param, &extra_id_pv) < 0) {
+			LM_ERR("malformed PV string: %s\n", extra_id_pv_param.s);
+			return -1;
+		}
+	} else {
+		extra_id_pv = NULL;
+	}
+
+	if (setid_avp_param) {
+		s.s = setid_avp_param; s.len = strlen(s.s);
+		avp_spec = pv_cache_get(&s);
+		if (avp_spec==NULL || (avp_spec->type != PVT_AVP)) {
+			LM_ERR("malformed or non AVP definition <%s>\n", setid_avp_param);
+			return -1;
+		}
+		if (pv_get_avp_name(0, &(avp_spec->pvp), &setid_avp, &avp_flags) != 0) {
+			LM_ERR("invalid AVP definition <%s>\n", setid_avp_param);
+			return -1;
+		}
+		setid_avp_type = avp_flags;
+	}
+
+	if (write_sdp_pvar_str.len > 0) {
+		write_sdp_pvar = pv_cache_get(&write_sdp_pvar_str);
+		if (write_sdp_pvar == NULL
+			|| (write_sdp_pvar->type != PVT_AVP &&  write_sdp_pvar->type != PVT_SCRIPTVAR) ) {
+			LM_ERR("write_sdp_pv: not a valid AVP or VAR definition <%.*s>\n",
+				write_sdp_pvar_str.len, write_sdp_pvar_str.s);
+			return -1;
+		}
+	}
+
+	if (read_sdp_pvar_str.len > 0) {
+		read_sdp_pvar = pv_cache_get(&read_sdp_pvar_str);
+		if (read_sdp_pvar == NULL
+			|| (read_sdp_pvar->type != PVT_AVP &&  read_sdp_pvar->type != PVT_SCRIPTVAR) ) {
+			LM_ERR("read_sdp_pv: not a valid AVP or VAR definition <%.*s>\n",
+				read_sdp_pvar_str.len, read_sdp_pvar_str.s);
+			return -1;
+		}
+	}
+
+	if (rtpp_strings)
+		pkg_free(rtpp_strings);
+
+	if ((queried_nodes_limit < 1) || (queried_nodes_limit > MAX_RTPP_TRIED_NODES)) {
+		LM_ERR("queried_nodes_limit must be a number in the range 1..50 \n");
+		return -1;
+	}
+
+	if (load_tm_api( &tmb ) < 0)
+	{
+		LM_DBG("could not load the TM-functions - answer-offer model"
+			" auto-detection is disabled\n");
+		memset(&tmb, 0, sizeof(struct tm_binds));
+	}
+
+	/* Determine IP addr type (IPv4 or IPv6 allowed) */
+	force_send_ip_af = get_ip_type(force_send_ip_str);
+	if (force_send_ip_af != AF_INET && force_send_ip_af != AF_INET6 &&
+	   strlen(force_send_ip_str) > 0) {
+		LM_ERR("%s is an unknown address\n", force_send_ip_str);
+		return -1;
+	}
+
+	/* init the hastable which keeps the call-id <-> selected_node relation */
+	if (!rtpengine_hash_table_init(hash_table_size)) {
+		LM_ERR("rtpengine_hash_table_init(%d) failed!\n", hash_table_size);
+		return -1;
+	} else {
+		LM_DBG("rtpengine_hash_table_init(%d) success!\n", hash_table_size);
+	}
+
+	/* select the default set */
+	default_rtpp_set = select_rtpp_set(setid_default);
+	if (!default_rtpp_set) {
+		LM_NOTICE("Default rtpp set %d NOT found\n", setid_default);
+	} else {
+		LM_DBG("Default rtpp set %d found\n", setid_default);
+	}
+
+	return 0;
+}
+
+static int build_rtpp_socks(unsigned int current_rtpp_no) {
+	int n, i;
+	char *cp;
+	struct addrinfo hints, *res;
+	struct rtpp_set  *rtpp_list;
+	struct rtpp_node *pnode;
+#ifdef IP_MTU_DISCOVER
+	int ip_mtu_discover = IP_PMTUDISC_DONT;
+#endif
+
+	// close current sockets
+	for (i = 0; i < rtpp_socks_size; i++) {
+		if (rtpp_socks[i] >= 0) {
+			close(rtpp_socks[i]);
+		}
+	}
+
+	rtpp_socks_size = current_rtpp_no;
+	rtpp_socks = (int*)pkg_realloc(rtpp_socks, sizeof(int)*(rtpp_socks_size));
+	if (!rtpp_socks) {
+		LM_ERR("no more pkg memory for rtpp_socks\n");
+		return -1;
+	}
+
+	lock_get(rtpp_set_list->rset_head_lock);
+	for (rtpp_list = rtpp_set_list->rset_first; rtpp_list != 0;
+		rtpp_list = rtpp_list->rset_next) {
+
+		lock_get(rtpp_list->rset_lock);
+		for (pnode=rtpp_list->rn_first; pnode!=0; pnode = pnode->rn_next) {
+			char *hostname;
+
+			if (pnode->rn_umode == 0) {
+				rtpp_socks[pnode->idx] = -1;
+				goto rptest;
+			}
+
+			/*
+			 * This is UDP or UDP6. Detect host and port; lookup host;
+			 * do connect() in order to specify peer address
+			 */
+			hostname = (char*)pkg_malloc(sizeof(char) * (strlen(pnode->rn_address) + 1));
+			if (hostname==NULL) {
+				LM_ERR("no more pkg memory\n");
+				rtpp_socks[pnode->idx] = -1;
+				continue;
+			}
+			strcpy(hostname, pnode->rn_address);
+
+			cp = strrchr(hostname, ':');
+			if (cp != NULL) {
+				*cp = '\0';
+				cp++;
+			}
+			if (cp == NULL || *cp == '\0')
+				cp = CPORT;
+
+			memset(&hints, 0, sizeof(hints));
+			hints.ai_flags = 0;
+			hints.ai_family = (pnode->rn_umode == 6) ? AF_INET6 : AF_INET;
+			hints.ai_socktype = SOCK_DGRAM;
+			if ((n = getaddrinfo(hostname, cp, &hints, &res)) != 0) {
+				LM_ERR("%s\n", gai_strerror(n));
+				pkg_free(hostname);
+				rtpp_socks[pnode->idx] = -1;
+				continue;
+			}
+			pkg_free(hostname);
+
+			rtpp_socks[pnode->idx] = socket((pnode->rn_umode == 6)
+				? AF_INET6 : AF_INET, SOCK_DGRAM, 0);
+			if (rtpp_socks[pnode->idx] == -1) {
+				LM_ERR("can't create socket\n");
+				freeaddrinfo(res);
+				continue;
+			}
+
+#ifdef IP_MTU_DISCOVER
+			setsockopt(rtpp_socks[pnode->idx], IPPROTO_IP,
+				IP_MTU_DISCOVER, &ip_mtu_discover,
+				sizeof(ip_mtu_discover));
+#endif
+
+			if (bind_force_send_ip(pnode->idx) == -1) {
+				LM_ERR("can't bind socket\n");
+				close(rtpp_socks[pnode->idx]);
+				rtpp_socks[pnode->idx] = -1;
+				freeaddrinfo(res);
+				continue;
+			}
+
+			if (connect(rtpp_socks[pnode->idx], res->ai_addr, res->ai_addrlen) == -1) {
+				LM_ERR("can't connect to a RTP proxy\n");
+				close(rtpp_socks[pnode->idx]);
+				rtpp_socks[pnode->idx] = -1;
+				freeaddrinfo(res);
+				continue;
+			}
+
+			freeaddrinfo(res);
+rptest:
+			pnode->rn_disabled = rtpp_test(pnode, 0, 1);
+		}
+		lock_release(rtpp_list->rset_lock);
+	}
+	lock_release(rtpp_set_list->rset_head_lock);
+
+	return 0;
+}
+
+static int
+child_init(int rank)
+{
+	if(!rtpp_set_list)
+		return 0;
+
+	mypid = getpid();
+
+	lock_get(rtpp_no_lock);
+	rtpp_socks_size = *rtpp_no;
+	lock_release(rtpp_no_lock);
+
+	rtpp_socks = (int*)pkg_malloc(sizeof(int)*(rtpp_socks_size));
+	if (!rtpp_socks) {
+		LM_ERR("no more pkg memory for rtpp_socks\n");
+		return -1;
+	}
+
+	/* Iterate known RTP proxies - create sockets */
+	if (rtpp_socks_size) {
+		build_rtpp_socks(rtpp_socks_size);
+	}
+
+	return 0;
+}
+
+
+static void mod_destroy(void)
+{
+	struct rtpp_set * crt_list, * last_list;
+	struct rtpp_node * crt_rtpp, *last_rtpp;
+
+	/*free the shared memory*/
+	if (natping_state)
+		shm_free(natping_state);
+
+	if (rtpp_no) {
+		shm_free(rtpp_no);
+		rtpp_no = NULL;
+	}
+
+	if (rtpp_no_lock) {
+		lock_destroy(rtpp_no_lock);
+		lock_dealloc(rtpp_no_lock);
+		rtpp_no_lock = NULL;
+	}
+
+	if (!rtpp_set_list) {
+		return;
+	}
+
+	if (!rtpp_set_list->rset_head_lock) {
+		shm_free(rtpp_set_list);
+		rtpp_set_list = NULL;
+		return;
+	}
+
+	lock_get(rtpp_set_list->rset_head_lock);
+	for(crt_list = rtpp_set_list->rset_first; crt_list != NULL; ){
+		last_list = crt_list;
+
+		if (!crt_list->rset_lock) {
+			crt_list = last_list->rset_next;
+			shm_free(last_list);
+			last_list = NULL;
+			continue;
+		}
+
+		lock_get(last_list->rset_lock);
+		for(crt_rtpp = crt_list->rn_first; crt_rtpp != NULL;  ){
+
+			if(crt_rtpp->rn_url.s)
+				shm_free(crt_rtpp->rn_url.s);
+
+			last_rtpp = crt_rtpp;
+			crt_rtpp = last_rtpp->rn_next;
+			shm_free(last_rtpp);
+		}
+		crt_list = last_list->rset_next;
+		lock_release(last_list->rset_lock);
+
+		lock_destroy(last_list->rset_lock);
+		lock_dealloc((void*)last_list->rset_lock);
+		last_list->rset_lock = NULL;
+
+		shm_free(last_list);
+		last_list = NULL;
+	}
+	lock_release(rtpp_set_list->rset_head_lock);
+
+	lock_destroy(rtpp_set_list->rset_head_lock);
+	lock_dealloc((void*)rtpp_set_list->rset_head_lock);
+	rtpp_set_list->rset_head_lock = NULL;
+
+	shm_free(rtpp_set_list);
+	rtpp_set_list = NULL;
+
+	/* destroy the hastable which keeps the call-id <-> selected_node relation */
+	if (!rtpengine_hash_table_destroy()) {
+		LM_ERR("rtpengine_hash_table_destroy() failed!\n");
+	} else {
+		LM_DBG("rtpengine_hash_table_destroy() success!\n");
+	}
+}
+
+
+
+static char * gencookie(void)
+{
+	static char cook[34];
+
+	sprintf(cook, "%d_%u ", (int)mypid, myseqn);
+	myseqn++;
+	return cook;
+}
+
+
+
+static const char *transports[] = {
+	[0x00]	= "RTP/AVP",
+	[0x01]	= "RTP/SAVP",
+	[0x02]	= "RTP/AVPF",
+	[0x03]	= "RTP/SAVPF",
+};
+
+static int parse_flags(struct ng_flags_parse *ng_flags, struct sip_msg *msg, enum rtpe_operation *op,
+		const char *flags_str)
+{
+	char *e;
+	const char *err;
+	str key, val, s;
+
+	if (!flags_str)
+		return 0;
+
+	while (1) {
+		while (*flags_str == ' ')
+			flags_str++;
+
+		key.s = (void *) flags_str;
+		val.len = key.len = -1;
+		val.s = NULL;
+
+		e = strpbrk(key.s, " =");
+		if (!e)
+			e = key.s + strlen(key.s);
+		else if (*e == '=') {
+			key.len = e - key.s;
+			val.s = e + 1;
+			e = strchr(val.s, ' ');
+			if (!e)
+				e = val.s + strlen(val.s);
+			val.len = e - val.s;
+		}
+
+		if (key.len == -1)
+			key.len = e - key.s;
+		if (!key.len)
+			break;
+
+		/* check for items which have their own sub-list */
+		s = str_prefix(&key, "replace-");
+		if (s.s) {
+			bencode_list_add_str(ng_flags->replace, &s);
+			goto next;
+		}
+
+		s = str_prefix(&key, "rtcp-mux-");
+		if (s.s) {
+			bencode_list_add_str(ng_flags->rtcp_mux, &s);
+			goto next;
+		}
+
+		/* check for specially handled items */
+		switch (key.len) {
+			case 3:
+				if (str_eq(&key, "RTP")) {
+					ng_flags->transport |= 0x100;
+					ng_flags->transport &= ~0x001;
+				}
+				else if (str_eq(&key, "AVP")) {
+					ng_flags->transport |= 0x100;
+					ng_flags->transport &= ~0x002;
+				}
+				else if (str_eq(&key, "TOS") && val.s)
+					bencode_dictionary_add_integer(ng_flags->dict, "TOS", atoi(val.s));
+				else if (str_eq(&key, "delete-delay") && val.s)
+					bencode_dictionary_add_integer(ng_flags->dict, "delete delay", atoi(val.s));
+				else
+					goto generic;
+				goto next;
+				break;
+
+			case 4:
+				if (str_eq(&key, "SRTP"))
+					ng_flags->transport |= 0x101;
+				else if (str_eq(&key, "AVPF"))
+					ng_flags->transport |= 0x102;
+				else
+					goto generic;
+				goto next;
+				break;
+
+			case 6:
+				if (str_eq(&key, "to-tag")) {
+					ng_flags->to = 1;
+					goto next;
+				}
+				break;
+
+			case 7:
+				if (str_eq(&key, "RTP/AVP")) {
+					ng_flags->transport = 0x100;
+					goto next;
+				}
+				break;
+
+			case 8:
+				if (str_eq(&key, "internal") || str_eq(&key, "external"))
+					bencode_list_add_str(ng_flags->direction, &key);
+				else if (str_eq(&key, "RTP/AVPF"))
+					ng_flags->transport = 0x102;
+				else if (str_eq(&key, "RTP/SAVP"))
+					ng_flags->transport = 0x101;
+				else
+					goto generic;
+				goto next;
+				break;
+
+			case 9:
+				if (str_eq(&key, "RTP/SAVPF"))
+					ng_flags->transport = 0x103;
+				else if (str_eq(&key, "direction"))
+					bencode_list_add_str(ng_flags->direction, &val);
+				else
+					goto generic;
+				goto next;
+				break;
+
+			case 10:
+				if (str_eq(&key, "via-branch")) {
+					err = "missing value";
+					if (!val.s)
+						goto error;
+					err = "invalid value";
+					if (*val.s == '1' || *val.s == '2')
+						ng_flags->via = *val.s - '0';
+					else if (str_eq(&val, "auto"))
+						ng_flags->via = 3;
+					else if (str_eq(&val, "extra"))
+						ng_flags->via = -1;
+					else
+						goto error;
+					goto next;
+				}
+				break;
+
+			case 11:
+				if (str_eq(&key, "repacketize")) {
+					err = "missing value";
+					if (!val.s)
+						goto error;
+					ng_flags->packetize = 0;
+					while (isdigit(*val.s)) {
+						ng_flags->packetize *= 10;
+						ng_flags->packetize += *val.s - '0';
+						val.s++;
+					}
+					err = "invalid value";
+					if (!ng_flags->packetize)
+						goto error;
+					bencode_dictionary_add_integer(ng_flags->dict, "repacketize", ng_flags->packetize);
+					goto next;
+				}
+				break;
+
+			case 12:
+				if (str_eq(&key, "force-answer")) {
+					err = "cannot force answer in non-offer command";
+					if (*op != OP_OFFER)
+						goto error;
+					*op = OP_ANSWER;
+					goto next;
+				}
+				break;
+		}
+
+generic:
+		if (!val.s)
+			bencode_list_add_str(ng_flags->flags, &key);
+		else
+			bencode_dictionary_str_add_str(ng_flags->dict, &key, &val);
+		goto next;
+
+next:
+		flags_str = e;
+	}
+
+	return 0;
+
+error:
+	if (val.s)
+		LM_ERR("error processing flag `%.*s' (value '%.*s'): %s\n", key.len, key.s,
+				val.len, val.s, err);
+	else
+		LM_ERR("error processing flag `%.*s': %s\n", key.len, key.s, err);
+	return -1;
+}
+
+static bencode_item_t *rtpp_function_call(bencode_buffer_t *bencbuf, struct sip_msg *msg,
+	enum rtpe_operation op, const char *flags_str, str *body_out)
+{
+	struct ng_flags_parse ng_flags;
+	bencode_item_t *item, *resp;
+	str callid = STR_NULL, from_tag = STR_NULL, to_tag = STR_NULL, viabranch = STR_NULL;
+	str body = STR_NULL, error = STR_NULL;
+	int ret, queried_nodes;
+	struct rtpp_node *node;
+	char *cp;
+	pv_value_t pv_val;
+
+	/*** get & init basic stuff needed ***/
+
+	memset(&ng_flags, 0, sizeof(ng_flags));
+
+	if (get_callid(msg, &callid) == -1 || callid.len == 0) {
+		LM_ERR("can't get Call-Id field\n");
+		return NULL;
+	}
+	if (get_to_tag(msg, &to_tag) == -1) {
+		LM_ERR("can't get To tag\n");
+		return NULL;
+	}
+	if (get_from_tag(msg, &from_tag) == -1 || from_tag.len == 0) {
+		LM_ERR("can't get From tag\n");
+		return NULL;
+	}
+	if (bencode_buffer_init(bencbuf)) {
+		LM_ERR("could not initialize bencode_buffer_t\n");
+		return NULL;
+	}
+	ng_flags.dict = bencode_dictionary(bencbuf);
+
+	body.s = NULL;
+	if (op == OP_OFFER || op == OP_ANSWER) {
+		ng_flags.flags = bencode_list(bencbuf);
+		ng_flags.direction = bencode_list(bencbuf);
+		ng_flags.replace = bencode_list(bencbuf);
+		ng_flags.rtcp_mux = bencode_list(bencbuf);
+
+		if (read_sdp_pvar!= NULL) {
+			if (read_sdp_pvar->getf(msg,&read_sdp_pvar->pvp, &pv_val) < 0)
+			{
+				LM_ERR("error getting pvar value <%.*s>\n", read_sdp_pvar_str.len, read_sdp_pvar_str.s);
+				goto error;
+			} else {
+				body = pv_val.rs;
+			}
+
+		} else if (extract_body(msg, &body) == -1) {
+			LM_ERR("can't extract body from the message\n");
+			goto error;
+		}
+		if (body_intermediate.s)
+			bencode_dictionary_add_str(ng_flags.dict, "sdp", &body_intermediate);
+		else
+			bencode_dictionary_add_str(ng_flags.dict, "sdp", &body);
+	}
+
+	/*** parse flags & build dictionary ***/
+
+	ng_flags.to = (op == OP_DELETE) ? 0 : 1;
+
+	if (parse_flags(&ng_flags, msg, &op, flags_str))
+		goto error;
+
+	/* only add those if any flags were given at all */
+	if (ng_flags.direction && ng_flags.direction->child)
+		bencode_dictionary_add(ng_flags.dict, "direction", ng_flags.direction);
+	if (ng_flags.flags && ng_flags.flags->child)
+		bencode_dictionary_add(ng_flags.dict, "flags", ng_flags.flags);
+	if (ng_flags.replace && ng_flags.replace->child)
+		bencode_dictionary_add(ng_flags.dict, "replace", ng_flags.replace);
+	if ((ng_flags.transport & 0x100))
+		bencode_dictionary_add_string(ng_flags.dict, "transport-protocol",
+				transports[ng_flags.transport & 0x003]);
+	if (ng_flags.rtcp_mux && ng_flags.rtcp_mux->child)
+		bencode_dictionary_add(ng_flags.dict, "rtcp-mux", ng_flags.rtcp_mux);
+
+	bencode_dictionary_add_str(ng_flags.dict, "call-id", &callid);
+
+	if (ng_flags.via) {
+		if (ng_flags.via == 1 || ng_flags.via == 2)
+			ret = get_via_branch(msg, ng_flags.via, &viabranch);
+		else if (ng_flags.via == -1 && extra_id_pv)
+			ret = get_extra_id(msg, &viabranch);
+		else
+			ret = -1;
+		if (ret == -1 || viabranch.len == 0) {
+			LM_ERR("can't get Via branch/extra ID\n");
+			goto error;
+		}
+		bencode_dictionary_add_str(ng_flags.dict, "via-branch", &viabranch);
+	}
+
+	item = bencode_list(bencbuf);
+	bencode_dictionary_add(ng_flags.dict, "received-from", item);
+	bencode_list_add_string(item, (msg->rcv.src_ip.af == AF_INET) ? "IP4" : (
+		(msg->rcv.src_ip.af == AF_INET6) ? "IP6" :
+		"?"
+	) );
+	bencode_list_add_string(item, ip_addr2a(&msg->rcv.src_ip));
+
+	if ((msg->first_line.type == SIP_REQUEST && op != OP_ANSWER)
+		|| (msg->first_line.type == SIP_REPLY && op == OP_ANSWER))
+	{
+		bencode_dictionary_add_str(ng_flags.dict, "from-tag", &from_tag);
+		if (ng_flags.to && to_tag.s && to_tag.len)
+			bencode_dictionary_add_str(ng_flags.dict, "to-tag", &to_tag);
+	}
+	else {
+		if (!to_tag.s || !to_tag.len) {
+			LM_ERR("No to-tag present\n");
+			goto error;
+		}
+		bencode_dictionary_add_str(ng_flags.dict, "from-tag", &to_tag);
+		bencode_dictionary_add_str(ng_flags.dict, "to-tag", &from_tag);
+	}
+
+	bencode_dictionary_add_string(ng_flags.dict, "command", command_strings[op]);
+
+	/*** send it out ***/
+
+	if (bencbuf->error) {
+		LM_ERR("out of memory - bencode failed\n");
+		goto error;
+	}
+
+	if(msg->id != current_msg_id)
+		active_rtpp_set = default_rtpp_set;
+
+	queried_nodes = 0;
+select_node:
+	do {
+		if (++queried_nodes > queried_nodes_limit) {
+			LM_ERR("queried nodes limit reached\n");
+			goto error;
+		}
+		node = select_rtpp_node(callid, viabranch, 1);
+		if (!node) {
+			LM_ERR("no available proxies\n");
+			goto error;
+		}
+
+		cp = send_rtpp_command(node, ng_flags.dict, &ret);
+		if (cp == NULL) {
+			node->rn_disabled = 1;
+			node->rn_recheck_ticks = get_ticks() + rtpengine_disable_tout;
+		}
+	} while (cp == NULL);
+	LM_DBG("proxy reply: %.*s\n", ret, cp);
+
+	set_rtp_inst_pvar(msg, &node->rn_url);
+	/*** process reply ***/
+
+	resp = bencode_decode_expect(bencbuf, cp, ret, BENCODE_DICTIONARY);
+	if (!resp) {
+		LM_ERR("failed to decode bencoded reply from proxy: %.*s\n", ret, cp);
+		goto error;
+	}
+
+	if (!bencode_dictionary_get_strcmp(resp, "result", "error")) {
+		if (!bencode_dictionary_get_str(resp, "error-reason", &error)) {
+			LM_ERR("proxy return error but didn't give an error reason: %.*s\n", ret, cp);
+		}
+		else {
+			if ((RTPENGINE_SESS_LIMIT_MSG_LEN == error.len) &&
+				(strncmp(error.s, RTPENGINE_SESS_LIMIT_MSG, RTPENGINE_SESS_LIMIT_MSG_LEN) == 0))
+			{
+				LM_WARN("proxy %.*s: %.*s", node->rn_url.len, node->rn_url.s , error.len, error.s);
+				goto select_node;
+			}
+			LM_ERR("proxy replied with error: %.*s\n", error.len, error.s);
+		}
+		goto error;
+	}
+
+	if (body_out)
+		*body_out = body;
+
+	if (op == OP_DELETE) {
+		/* Delete the key<->value from the hashtable */
+		if (!rtpengine_hash_table_remove(callid, viabranch)) {
+			LM_ERR("rtpengine hash table failed to remove entry for callen=%d callid=%.*s viabranch=%.*s\n",
+				callid.len, callid.len, callid.s, viabranch.len, viabranch.s);
+		} else {
+			LM_DBG("rtpengine hash table remove entry for callen=%d callid=%.*s viabranch=%.*s\n",
+				callid.len, callid.len, callid.s, viabranch.len, viabranch.s);
+		}
+	}
+
+	return resp;
+
+error:
+	bencode_buffer_free(bencbuf);
+	return NULL;
+}
+
+static int rtpp_function_call_simple(struct sip_msg *msg, enum rtpe_operation op, const char *flags_str)
+{
+	bencode_buffer_t bencbuf;
+
+	if (!rtpp_function_call(&bencbuf, msg, op, flags_str, NULL))
+		return -1;
+
+	bencode_buffer_free(&bencbuf);
+	return 1;
+}
+
+static bencode_item_t *rtpp_function_call_ok(bencode_buffer_t *bencbuf, struct sip_msg *msg,
+		enum rtpe_operation op, const char *flags_str, str *body)
+{
+	bencode_item_t *ret;
+
+	ret = rtpp_function_call(bencbuf, msg, op, flags_str, body);
+	if (!ret)
+		return NULL;
+
+	if (bencode_dictionary_get_strcmp(ret, "result", "ok")) {
+		LM_ERR("proxy didn't return \"ok\" result\n");
+		bencode_buffer_free(bencbuf);
+		return NULL;
+	}
+
+	return ret;
+}
+
+
+
+static int
+rtpp_test(struct rtpp_node *node, int isdisabled, int force)
+{
+	bencode_buffer_t bencbuf;
+	bencode_item_t *dict;
+	char *cp;
+	int ret;
+
+	if(node->rn_recheck_ticks == MI_MAX_RECHECK_TICKS){
+		LM_DBG("rtpp %s disabled for ever\n", node->rn_url.s);
+		return 1;
+	}
+	if (force == 0) {
+		if (isdisabled == 0)
+			return 0;
+		if (node->rn_recheck_ticks > get_ticks())
+			return 1;
+	}
+
+	if (bencode_buffer_init(&bencbuf)) {
+		LM_ERR("could not initialized bencode_buffer_t\n");
+		return 1;
+	}
+	dict = bencode_dictionary(&bencbuf);
+	bencode_dictionary_add_string(dict, "command", "ping");
+	if (bencbuf.error)
+		goto benc_error;
+
+	cp = send_rtpp_command(node, dict, &ret);
+	if (!cp) {
+		node->rn_disabled = 1;
+		node->rn_recheck_ticks = get_ticks() + rtpengine_disable_tout;
+		LM_ERR("proxy did not respond to ping\n");
+		goto error;
+	}
+
+	dict = bencode_decode_expect(&bencbuf, cp, ret, BENCODE_DICTIONARY);
+	if (!dict || bencode_dictionary_get_strcmp(dict, "result", "pong")) {
+		LM_ERR("proxy responded with invalid response\n");
+		goto error;
+	}
+
+	LM_INFO("rtp proxy <%s> found, support for it %senabled\n",
+		node->rn_url.s, force == 0 ? "re-" : "");
+
+	bencode_buffer_free(&bencbuf);
+	return 0;
+
+benc_error:
+	LM_ERR("out of memory - bencode failed\n");
+error:
+	bencode_buffer_free(&bencbuf);
+	return 1;
+}
+
+static char *
+send_rtpp_command(struct rtpp_node *node, bencode_item_t *dict, int *outlen)
+{
+	struct sockaddr_un addr;
+	int fd, len, i, vcnt;
+	char *cp;
+	static char buf[0x10000];
+	struct pollfd fds[1];
+	struct iovec *v;
+	str out = STR_NULL;
+
+	v = bencode_iovec(dict, &vcnt, 1, 0);
+	if (!v) {
+		LM_ERR("error converting bencode to iovec\n");
+		return NULL;
+	}
+
+	len = 0;
+	cp = buf;
+	if (node->rn_umode == 0) {
+		memset(&addr, 0, sizeof(addr));
+		addr.sun_family = AF_LOCAL;
+		strncpy(addr.sun_path, node->rn_address,
+			sizeof(addr.sun_path) - 1);
+#ifdef HAVE_SOCKADDR_SA_LEN
+		addr.sun_len = strlen(addr.sun_path);
+#endif
+
+		fd = socket(AF_LOCAL, SOCK_STREAM, 0);
+		if (fd < 0) {
+			LM_ERR("can't create socket\n");
+			goto badproxy;
+		}
+		if (connect(fd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
+			close(fd);
+			LM_ERR("can't connect to RTP proxy <%s>\n", node->rn_url.s);
+			goto badproxy;
+		}
+
+		do {
+			len = writev(fd, v + 1, vcnt);
+		} while (len == -1 && errno == EINTR);
+		if (len <= 0) {
+			close(fd);
+			LM_ERR("can't send command to RTP proxy <%s>\n", node->rn_url.s);
+			goto badproxy;
+		}
+		do {
+			len = read(fd, buf, sizeof(buf) - 1);
+		} while (len == -1 && errno == EINTR);
+		close(fd);
+		if (len <= 0) {
+			LM_ERR("can't read reply from RTP proxy <%s>\n", node->rn_url.s);
+			goto badproxy;
+		}
+	} else {
+		fds[0].fd = rtpp_socks[node->idx];
+		fds[0].events = POLLIN;
+		fds[0].revents = 0;
+		/* Drain input buffer */
+		while ((poll(fds, 1, 0) == 1) &&
+			((fds[0].revents & POLLIN) != 0)) {
+			recv(rtpp_socks[node->idx], buf, sizeof(buf) - 1, 0);
+			fds[0].revents = 0;
+		}
+		v[0].iov_base = gencookie();
+		v[0].iov_len = strlen(v[0].iov_base);
+		for (i = 0; i < rtpengine_retr; i++) {
+			do {
+				len = writev(rtpp_socks[node->idx], v, vcnt + 1);
+			} while (len == -1 && (errno == EINTR || errno == ENOBUFS));
+			if (len <= 0) {
+				bencode_get_str(bencode_dictionary_get(dict, "command"), &out);
+				LM_ERR("can't send command \"%.*s\" to RTP proxy <%s>\n", out.len, out.s, node->rn_url.s);
+				goto badproxy;
+			}
+			while ((poll(fds, 1, rtpengine_tout_ms) == 1) &&
+				(fds[0].revents & POLLIN) != 0) {
+				do {
+					len = recv(rtpp_socks[node->idx], buf, sizeof(buf)-1, 0);
+				} while (len == -1 && errno == EINTR);
+				if (len <= 0) {
+					LM_ERR("can't read reply from RTP proxy <%s>\n", node->rn_url.s);
+					goto badproxy;
+				}
+				if (len >= (v[0].iov_len - 1) &&
+					memcmp(buf, v[0].iov_base, (v[0].iov_len - 1)) == 0) {
+					len -= (v[0].iov_len - 1);
+					cp += (v[0].iov_len - 1);
+					if (len != 0) {
+						len--;
+						cp++;
+					}
+					goto out;
+				}
+				fds[0].revents = 0;
+			}
+		}
+		if (i == rtpengine_retr) {
+			LM_ERR("timeout waiting reply from RTP proxy <%s>\n", node->rn_url.s);
+			goto badproxy;
+		}
+	}
+
+out:
+	cp[len] = '\0';
+	*outlen = len;
+	return cp;
+
+badproxy:
+	return NULL;
+}
+
+/*
+ * select the set with the id_set id
+ */
+
+static struct rtpp_set * select_rtpp_set(int id_set ){
+
+	struct rtpp_set * rtpp_list;
+	/*is it a valid set_id?*/
+
+	if (!rtpp_set_list) {
+		LM_ERR("no rtpp_set_list\n");
+		return 0;
+	}
+
+	lock_get(rtpp_set_list->rset_head_lock);
+	if (!rtpp_set_list->rset_first) {
+		LM_ERR("no rtpp_set_list->rset_first\n");
+		lock_release(rtpp_set_list->rset_head_lock);
+		return 0;
+	}
+
+	for (rtpp_list=rtpp_set_list->rset_first; rtpp_list!=0 &&
+			rtpp_list->id_set!=id_set; rtpp_list=rtpp_list->rset_next);
+	if (!rtpp_list) {
+		LM_ERR(" script error-invalid id_set to be selected\n");
+	}
+	lock_release(rtpp_set_list->rset_head_lock);
+
+	return rtpp_list;
+}
+
+/*
+ * run the selection algorithm and return the new selected node
+ */
+static struct rtpp_node *
+select_rtpp_node_new(str callid, str viabranch, int do_test)
+{
+	struct rtpp_node* node;
+	unsigned i, sum, sumcut, weight_sum;
+	int was_forced = 0;
+
+	/* XXX Use quick-and-dirty hashing algo */
+	sum = 0;
+	for(i = 0; i < callid.len; i++)
+		sum += callid.s[i];
+	sum &= 0xff;
+
+retry:
+	weight_sum = 0;
+
+	lock_get(active_rtpp_set->rset_lock);
+	for (node=active_rtpp_set->rn_first; node!=NULL; node=node->rn_next) {
+		/* Select only between displayed machines */
+		if (!node->rn_displayed) {
+			continue;
+		}
+
+		/* Try to enable if it's time to try. */
+		if (node->rn_disabled && node->rn_recheck_ticks <= get_ticks()){
+			node->rn_disabled = rtpp_test(node, 1, 0);
+		}
+
+		/* Select only between enabled machines */
+		if (!node->rn_disabled) {
+			weight_sum += node->rn_weight;
+		}
+	}
+	lock_release(active_rtpp_set->rset_lock);
+
+	/* No proxies? Force all to be redetected, if not yet */
+	if (weight_sum == 0) {
+		if (was_forced) {
+			return NULL;
+		}
+
+		was_forced = 1;
+
+		lock_get(active_rtpp_set->rset_lock);
+		for(node=active_rtpp_set->rn_first; node!=NULL; node=node->rn_next) {
+			/* Select only between displayed machines */
+			if (!node->rn_displayed) {
+				continue;
+			}
+
+			node->rn_disabled = rtpp_test(node, 1, 1);
+		}
+		lock_release(active_rtpp_set->rset_lock);
+
+		goto retry;
+	}
+
+	/* sumcut here lays from 0 to weight_sum-1 */
+	sumcut = sum % weight_sum;
+
+	/*
+	 * Scan proxy list and decrease until appropriate proxy is found.
+	 */
+	lock_get(active_rtpp_set->rset_lock);
+	for (node=active_rtpp_set->rn_first; node!=NULL; node=node->rn_next) {
+		/* Select only between displayed machines */
+		if (!node->rn_displayed) {
+			continue;
+		}
+
+		/* Select only between enabled machines */
+		if (node->rn_disabled)
+			continue;
+
+		/* Found enabled machine */
+		if (sumcut < node->rn_weight) {
+			lock_release(active_rtpp_set->rset_lock);
+			goto found;
+		}
+
+		/* Update sumcut if enabled machine */
+		sumcut -= node->rn_weight;
+	}
+	lock_release(active_rtpp_set->rset_lock);
+
+	/* No node list */
+	return NULL;
+
+found:
+	if (do_test) {
+		lock_get(active_rtpp_set->rset_lock);
+		node->rn_disabled = rtpp_test(node, node->rn_disabled, 0);
+		if (node->rn_disabled) {
+			lock_release(active_rtpp_set->rset_lock);
+			goto retry;
+		}
+		lock_release(active_rtpp_set->rset_lock);
+	}
+
+	/* build the entry */
+	struct rtpengine_hash_entry *entry = shm_malloc(sizeof(struct rtpengine_hash_entry));
+	if (!entry) {
+		LM_ERR("rtpengine hash table fail to create entry for calllen=%d callid=%.*s viabranch=%.*s\n",
+			callid.len, callid.len, callid.s, viabranch.len, viabranch.s);
+		return node;
+	}
+	memset(entry, 0, sizeof(struct rtpengine_hash_entry));
+
+	/* fill the entry */
+	if (callid.s && callid.len > 0) {
+		if (shm_str_dup(&entry->callid, &callid) < 0) {
+			LM_ERR("rtpengine hash table fail to duplicate calllen=%d callid=%.*s\n",
+				callid.len, callid.len, callid.s);
+			rtpengine_hash_table_free_entry(entry);
+			return node;
+		}
+	}
+	if (viabranch.s && viabranch.len > 0) {
+		if (shm_str_dup(&entry->viabranch, &viabranch) < 0) {
+			LM_ERR("rtpengine hash table fail to duplicate calllen=%d viabranch=%.*s\n",
+				callid.len, viabranch.len, viabranch.s);
+			rtpengine_hash_table_free_entry(entry);
+			return node;
+		}
+	}
+	entry->node = node;
+	entry->next = NULL;
+	entry->tout = get_ticks() + hash_table_tout;
+
+	/* insert the key<->entry from the hashtable */
+	if (!rtpengine_hash_table_insert(callid, viabranch, entry)) {
+		LM_ERR("rtpengine hash table fail to insert node=%.*s for calllen=%d callid=%.*s viabranch=%.*s\n",
+			node->rn_url.len, node->rn_url.s, callid.len, callid.len, callid.s, viabranch.len, viabranch.s);
+		rtpengine_hash_table_free_entry(entry);
+		return node;
+	} else {
+		LM_DBG("rtpengine hash table insert node=%.*s for calllen=%d callid=%.*s viabranch=%.*s\n",
+			node->rn_url.len, node->rn_url.s, callid.len, callid.len, callid.s, viabranch.len, viabranch.s);
+	}
+
+	/* return selected node */
+	return node;
+}
+
+/*
+ * lookup the hastable (key=callid value=node) and get the old node (e.g. for answer/delete)
+ */
+static struct rtpp_node *
+select_rtpp_node_old(str callid, str viabranch, int do_test)
+{
+	struct rtpp_node *node = NULL;
+
+	node = rtpengine_hash_table_lookup(callid, viabranch);
+
+	if (!node) {
+		LM_NOTICE("rtpengine hash table lookup failed to find node for calllen=%d callid=%.*s viabranch=%.*s\n",
+			callid.len, callid.len, callid.s, viabranch.len, viabranch.s);
+		return NULL;
+	} else {
+		LM_DBG("rtpengine hash table lookup find node=%.*s for calllen=%d callid=%.*s viabranch=%.*s\n",
+			node->rn_url.len, node->rn_url.s, callid.len, callid.len, callid.s, viabranch.len, viabranch.s);
+	}
+
+	return node;
+}
+
+/*
+ * Main balancing routine. This DO try to keep the same proxy for
+ * the call if some proxies were disabled or enabled (e.g. kamctl command)
+ */
+static struct rtpp_node *
+select_rtpp_node(str callid, str viabranch, int do_test)
+{
+	struct rtpp_node *node = NULL;
+	unsigned int current_rtpp_no;
+
+	lock_get(rtpp_no_lock);
+	current_rtpp_no = *rtpp_no;
+	lock_release(rtpp_no_lock);
+
+	if (rtpp_socks_size != current_rtpp_no) {
+		build_rtpp_socks(current_rtpp_no);
+	}
+
+	if (!active_rtpp_set) {
+		default_rtpp_set = select_rtpp_set(setid_default);
+		active_rtpp_set = default_rtpp_set;
+	}
+
+	if (!active_rtpp_set) {
+		LM_ERR("script error - no valid set selected\n");
+		return NULL;
+	}
+
+	// lookup node
+	node = select_rtpp_node_old(callid, viabranch, do_test);
+
+	// check node
+	if (!node) {
+		// run the selection algorithm
+		node = select_rtpp_node_new(callid, viabranch, do_test);
+
+		// check node
+		if (!node) {
+			LM_ERR("rtpengine failed to select new for calllen=%d callid=%.*s\n",
+				callid.len, callid.len, callid.s);
+			return NULL;
+		}
+	}
+
+	// if node enabled, return it
+	if (!node->rn_disabled) {
+		return node;
+	}
+
+	// if proper configuration and node manually or timeout disabled, return it
+	if (rtpengine_allow_op) {
+		if (node->rn_recheck_ticks == MI_MAX_RECHECK_TICKS) {
+			LM_DBG("node=%.*s for calllen=%d callid=%.*s is disabled(permanent) (probably still UP)! Return it\n",
+				node->rn_url.len, node->rn_url.s, callid.len, callid.len, callid.s);
+		} else {
+			LM_DBG("node=%.*s for calllen=%d callid=%.*s is disabled, either broke or timeout disabled! Return it\n",
+				node->rn_url.len, node->rn_url.s, callid.len, callid.len, callid.s);
+		}
+		return node;
+	}
+
+	return NULL;
+}
+
+static int
+get_extra_id(struct sip_msg* msg, str *id_str) {
+	if (msg == NULL || extra_id_pv == NULL || id_str == NULL) {
+		LM_ERR("bad parameters\n");
+		return -1;
+	}
+	if (pv_printf_s(msg, extra_id_pv, id_str) < 0) {
+		LM_ERR("cannot print the additional id\n");
+		return -1;
+	}
+
+	return 1;
+
+}
+
+static int
+set_rtpengine_set_from_avp(struct sip_msg *msg, int direction)
+{
+	struct usr_avp *avp;
+	int_str setid_val;
+
+	if ((setid_avp_param == NULL) ||
+	   (avp = search_first_avp(setid_avp_type, setid_avp, &setid_val, 0)) == NULL) {
+		if (direction == 1 || !selected_rtpp_set_2)
+			active_rtpp_set = selected_rtpp_set_1;
+		else
+			active_rtpp_set = selected_rtpp_set_2;
+		return 1;
+	}
+
+	if (avp->flags&AVP_VAL_STR) {
+		LM_ERR("setid_avp must hold an integer value\n");
+		return -1;
+	}
+
+	active_rtpp_set = select_rtpp_set(setid_val.n);
+	if(active_rtpp_set == NULL) {
+		LM_ERR("could not locate rtpproxy set %d\n", setid_val.n);
+		return -1;
+	}
+
+	LM_DBG("using rtpengine set %d\n", setid_val.n);
+
+	current_msg_id = msg->id;
+
+	return 1;
+}
+
+static int rtpengine_delete(struct sip_msg *msg, const char *flags) {
+	return rtpp_function_call_simple(msg, OP_DELETE, flags);
+}
+
+static int rtpengine_rtpp_set_wrap(struct sip_msg *msg, int (*func)(struct sip_msg *msg, void *, int),
+		void *data, int direction)
+{
+	int ret, more;
+
+	body_intermediate.s = NULL;
+
+	if (set_rtpengine_set_from_avp(msg, direction) == -1)
+		return -1;
+
+	more = 1;
+	if (!selected_rtpp_set_2 || selected_rtpp_set_2 == selected_rtpp_set_1)
+		more = 0;
+
+	ret = func(msg, data, more);
+	if (ret < 0)
+		return ret;
+
+	if (!more)
+		return ret;
+
+	direction = (direction == 1) ? 2 : 1;
+	if (set_rtpengine_set_from_avp(msg, direction) == -1)
+		return -1;
+
+	ret = func(msg, data, 0);
+	body_intermediate.s = NULL;
+	return ret;
+}
+
+static int rtpengine_delete_wrap(struct sip_msg *msg, void *d, int more) {
+	return rtpengine_delete(msg, d);
+}
+
+static int
+rtpengine_delete1_f(struct sip_msg* msg, char* str1, char* str2)
+{
+	str flags;
+
+	flags.s = NULL;
+	if (str1)
+		get_str_fparam(&flags, msg, (fparam_t *) str1);
+
+	return rtpengine_rtpp_set_wrap(msg, rtpengine_delete_wrap, flags.s, 1);
+}
+
+/* This function assumes p points to a line of requested type. */
+
+static int
+set_rtpengine_set_n(struct sip_msg *msg, rtpp_set_link_t *rtpl, struct rtpp_set **out)
+{
+	pv_value_t val;
+	struct rtpp_node *node;
+	int nb_active_nodes = 0;
+
+	if(rtpl->rset != NULL) {
+		current_msg_id = msg->id;
+		*out = rtpl->rset;
+		return 1;
+	}
+
+	if(pv_get_spec_value(msg, rtpl->rpv, &val)<0) {
+		LM_ERR("cannot evaluate pv param\n");
+		return -1;
+	}
+	if(!(val.flags & PV_VAL_INT)) {
+		LM_ERR("pv param must hold an integer value\n");
+		return -1;
+	}
+	*out = select_rtpp_set(val.ri);
+	if(*out==NULL) {
+		LM_ERR("could not locate rtpengine set %d\n", val.ri);
+		return -1;
+	}
+	current_msg_id = msg->id;
+
+	lock_get((*out)->rset_lock);
+	node = (*out)->rn_first;
+	while (node != NULL)
+	{
+		if (node->rn_disabled == 0) nb_active_nodes++;
+		node = node->rn_next;
+	}
+	lock_release((*out)->rset_lock);
+
+	if ( nb_active_nodes > 0 )
+	{
+		LM_DBG("rtpp: selected proxy set ID %d with %d active nodes.\n",
+			current_msg_id, nb_active_nodes);
+		return nb_active_nodes;
+	}
+	else
+	{
+		LM_WARN("rtpp: selected proxy set ID %d but it has no active node.\n",
+			current_msg_id);
+		return -2;
+	}
+}
+
+static int
+set_rtpengine_set_f(struct sip_msg * msg, char * str1, char * str2)
+{
+	rtpp_set_link_t *rtpl1, *rtpl2;
+	int ret;
+
+	rtpl1 = (rtpp_set_link_t*)str1;
+	rtpl2 = (rtpp_set_link_t*)str2;
+
+	current_msg_id = 0;
+	active_rtpp_set = 0;
+	selected_rtpp_set_1 = 0;
+	selected_rtpp_set_2 = 0;
+
+	ret = set_rtpengine_set_n(msg, rtpl1, &selected_rtpp_set_1);
+	if (ret < 0)
+		return ret;
+
+	if (rtpl2) {
+		ret = set_rtpengine_set_n(msg, rtpl2, &selected_rtpp_set_2);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 1;
+}
+
+static int
+rtpengine_manage(struct sip_msg *msg, const char *flags)
+{
+	int method;
+	int nosdp;
+
+	if (msg->cseq==NULL && ((parse_headers(msg, HDR_CSEQ_F, 0)==-1) ||
+	   (msg->cseq==NULL)))
+	{
+		LM_ERR("no CSEQ header\n");
+		return -1;
+	}
+
+	method = get_cseq(msg)->method_id;
+
+	if (!(method==METHOD_INVITE || method==METHOD_ACK || method==METHOD_CANCEL
+	   || method==METHOD_BYE || method==METHOD_UPDATE))
+		return -1;
+
+	if (method==METHOD_CANCEL || method==METHOD_BYE)
+		return rtpengine_delete(msg, flags);
+
+	if (msg->msg_flags & FL_SDP_BODY)
+		nosdp = 0;
+	else
+		nosdp = parse_sdp(msg);
+
+	if (msg->first_line.type == SIP_REQUEST) {
+		if(method==METHOD_ACK && nosdp==0)
+			return rtpengine_offer_answer(msg, flags, OP_ANSWER, 0);
+		if(method==METHOD_UPDATE && nosdp==0)
+			return rtpengine_offer_answer(msg, flags, OP_OFFER, 0);
+		if(method==METHOD_INVITE && nosdp==0) {
+			msg->msg_flags |= FL_SDP_BODY;
+			if(tmb.t_gett!=NULL && tmb.t_gett()!=NULL
+					&& tmb.t_gett()!=T_UNDEFINED)
+				tmb.t_gett()->uas.request->msg_flags |= FL_SDP_BODY;
+			if(route_type==FAILURE_ROUTE)
+				return rtpengine_delete(msg, flags);
+			return rtpengine_offer_answer(msg, flags, OP_OFFER, 0);
+		}
+	} else if (msg->first_line.type == SIP_REPLY) {
+		if (msg->first_line.u.reply.statuscode>=300)
+			return rtpengine_delete(msg, flags);
+		if (nosdp==0) {
+			if (method==METHOD_UPDATE)
+				return rtpengine_offer_answer(msg, flags, OP_ANSWER, 0);
+			if (tmb.t_gett==NULL || tmb.t_gett()==NULL
+					|| tmb.t_gett()==T_UNDEFINED)
+				return rtpengine_offer_answer(msg, flags, OP_ANSWER, 0);
+			if (tmb.t_gett()->uas.request->msg_flags & FL_SDP_BODY)
+				return rtpengine_offer_answer(msg, flags, OP_ANSWER, 0);
+			return rtpengine_offer_answer(msg, flags, OP_OFFER, 0);
+		}
+	}
+	return -1;
+}
+
+static int rtpengine_manage_wrap(struct sip_msg *msg, void *d, int more) {
+	return rtpengine_manage(msg, d);
+}
+
+static int
+rtpengine_manage1_f(struct sip_msg *msg, char *str1, char *str2)
+{
+	str flags;
+
+	flags.s = NULL;
+	if (str1)
+		get_str_fparam(&flags, msg, (fparam_t *) str1);
+
+	return rtpengine_rtpp_set_wrap(msg, rtpengine_manage_wrap, flags.s, 1);
+}
+
+static int rtpengine_offer_wrap(struct sip_msg *msg, void *d, int more) {
+	return rtpengine_offer_answer(msg, d, OP_OFFER, more);
+}
+
+static int
+rtpengine_offer1_f(struct sip_msg *msg, char *str1, char *str2)
+{
+	str flags;
+
+	flags.s = NULL;
+	if (str1)
+		get_str_fparam(&flags, msg, (fparam_t *) str1);
+
+	return rtpengine_rtpp_set_wrap(msg, rtpengine_offer_wrap, flags.s, 1);
+}
+
+static int rtpengine_answer_wrap(struct sip_msg *msg, void *d, int more) {
+	return rtpengine_offer_answer(msg, d, OP_ANSWER, more);
+}
+
+static int
+rtpengine_answer1_f(struct sip_msg *msg, char *str1, char *str2)
+{
+	str flags;
+
+	if (msg->first_line.type == SIP_REQUEST)
+		if (msg->first_line.u.request.method_value != METHOD_ACK)
+			return -1;
+
+	flags.s = NULL;
+	if (str1)
+		get_str_fparam(&flags, msg, (fparam_t *) str1);
+
+	return rtpengine_rtpp_set_wrap(msg, rtpengine_answer_wrap, flags.s, 2);
+}
+
+static int
+rtpengine_offer_answer(struct sip_msg *msg, const char *flags, int op, int more)
+{
+	bencode_buffer_t bencbuf;
+	bencode_item_t *dict;
+	str body, newbody;
+	struct lump *anchor;
+	pv_value_t pv_val;
+
+	dict = rtpp_function_call_ok(&bencbuf, msg, op, flags, &body);
+	if (!dict)
+		return -1;
+
+	if (!bencode_dictionary_get_str_dup(dict, "sdp", &newbody)) {
+		LM_ERR("failed to extract sdp body from proxy reply\n");
+		goto error;
+	}
+
+	if (body_intermediate.s)
+		pkg_free(body_intermediate.s);
+
+	if (more)
+		body_intermediate = newbody;
+	else {
+		if (write_sdp_pvar!= NULL) {
+			pv_val.rs = newbody;
+			pv_val.flags = PV_VAL_STR;
+
+			if (write_sdp_pvar->setf(msg,&write_sdp_pvar->pvp, (int)EQ_T, &pv_val) < 0)
+			{
+				LM_ERR("error setting pvar <%.*s>\n", write_sdp_pvar_str.len, write_sdp_pvar_str.s);
+				goto error_free;
+			}
+
+			pkg_free(newbody.s);
+
+		} else {
+			anchor = del_lump(msg, body.s - msg->buf, body.len, 0);
+			if (!anchor) {
+				LM_ERR("del_lump failed\n");
+				goto error_free;
+			}
+			if (!insert_new_lump_after(anchor, newbody.s, newbody.len, 0)) {
+				LM_ERR("insert_new_lump_after failed\n");
+				goto error_free;
+			}
+		}
+	}
+
+	bencode_buffer_free(&bencbuf);
+	return 1;
+
+error_free:
+	pkg_free(newbody.s);
+error:
+	bencode_buffer_free(&bencbuf);
+	return -1;
+}
+
+
+static int rtpengine_start_recording_wrap(struct sip_msg *msg, void *d, int more) {
+	return rtpp_function_call_simple(msg, OP_START_RECORDING, NULL);
+}
+
+static int
+start_recording_f(struct sip_msg* msg, char *foo, char *bar)
+{
+	return rtpengine_rtpp_set_wrap(msg, rtpengine_start_recording_wrap, NULL, 1);
+}
+
+static int rtpengine_rtpstat_wrap(struct sip_msg *msg, void *d, int more) {
+	void **parms;
+	pv_param_t *param;
+	pv_value_t *res;
+	bencode_buffer_t bencbuf;
+	bencode_item_t *dict, *tot, *rtp, *rtcp;
+	static char buf[256];
+	str ret;
+
+	parms = d;
+	param = parms[0];
+	res = parms[1];
+
+	dict = rtpp_function_call_ok(&bencbuf, msg, OP_QUERY, NULL, NULL);
+	if (!dict)
+		return -1;
+
+	tot = bencode_dictionary_get_expect(dict, "totals", BENCODE_DICTIONARY);
+	rtp = bencode_dictionary_get_expect(tot, "RTP", BENCODE_DICTIONARY);
+	rtcp = bencode_dictionary_get_expect(tot, "RTCP", BENCODE_DICTIONARY);
+
+	if (!rtp || !rtcp)
+		goto error;
+
+	ret.s = buf;
+	ret.len = snprintf(buf, sizeof(buf),
+			"RTP: %lli bytes, %lli packets, %lli errors; "
+			"RTCP: %lli bytes, %lli packets, %lli errors",
+			bencode_dictionary_get_integer(rtp, "bytes", -1),
+			bencode_dictionary_get_integer(rtp, "packets", -1),
+			bencode_dictionary_get_integer(rtp, "errors", -1),
+			bencode_dictionary_get_integer(rtcp, "bytes", -1),
+			bencode_dictionary_get_integer(rtcp, "packets", -1),
+			bencode_dictionary_get_integer(rtcp, "errors", -1));
+
+	bencode_buffer_free(&bencbuf);
+	return pv_get_strval(msg, param, res, &ret);
+
+error:
+	bencode_buffer_free(&bencbuf);
+	return -1;
+}
+
+/*
+ * Returns the current RTP-Statistics from the RTP-Proxy
+ */
+static int
+pv_get_rtpstat_f(struct sip_msg *msg, pv_param_t *param, pv_value_t *res)
+{
+	void *parms[2];
+
+	parms[0] = param;
+	parms[1] = res;
+
+	return rtpengine_rtpp_set_wrap(msg, rtpengine_rtpstat_wrap, parms, 1);
+}
+
+static int
+set_rtp_inst_pvar(struct sip_msg *msg, const str * const uri) {
+	pv_value_t val;
+
+	if (rtp_inst_pvar == NULL)
+		return 0;
+
+	memset(&val, 0, sizeof(pv_value_t));
+	val.flags = PV_VAL_STR;
+	val.rs = *uri;
+
+	if (rtp_inst_pvar->setf(msg, &rtp_inst_pvar->pvp, (int)EQ_T, &val) < 0) {
+		LM_ERR("Failed to add RTP Engine URI to pvar\n");
+		return -1;
+	}
+	return 0;
+}
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/rtpengine.d ui-siprouter/modules/rtpengine/rtpengine.d
--- ui-siprouter~/modules/rtpengine/rtpengine.d	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/rtpengine.d	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,520 @@
+rtpengine.o: rtpengine.c ../../flags.h ../../sr_module.h \
+ ../../parser/msg_parser.h ../../parser/../comp_defs.h \
+ ../../parser/../str.h ../../parser/../lump_struct.h \
+ ../../parser/.././parser/hf.h ../../parser/.././parser/../str.h \
+ ../../parser/.././parser/../comp_defs.h ../../parser/../flags.h \
+ ../../parser/../ip_addr.h ../../parser/../str.h \
+ ../../parser/../compiler_opt.h ../../parser/../ut.h \
+ ../../parser/../comp_defs.h ../../parser/../config.h \
+ ../../parser/../types.h ../../parser/../dprint.h \
+ ../../parser/../cfg_core.h ../../parser/../cfg/cfg.h \
+ ../../parser/../cfg/../str.h ../../parser/../mem/mem.h \
+ ../../parser/../mem/../config.h ../../parser/../mem/../dprint.h \
+ ../../parser/../mem/q_malloc.h ../../parser/../mem/meminfo.h \
+ ../../parser/../mem/src_loc.h ../../parser/../mem/shm_mem.h \
+ ../../parser/../mem/../lock_ops.h ../../parser/../mem/../futexlock.h \
+ ../../parser/../mem/../atomic/atomic_common.h \
+ ../../parser/../mem/../atomic/atomic_native.h \
+ ../../parser/../mem/../atomic/atomic_x86.h \
+ ../../parser/../mem/../compiler_opt.h ../../parser/../md5utils.h \
+ ../../parser/../config.h ../../parser/parse_def.h \
+ ../../parser/parse_cseq.h ../../parser/parse_via.h \
+ ../../parser/parse_fline.h ../../parser/parse_retry_after.h \
+ ../../parser/hf.h ../../parser/../error.h ../../ver_defs.h ../../rpc.h \
+ ../../route_struct.h ../../select.h ../../str.h ../../usr_avp.h \
+ ../../route.h ../../config.h ../../error.h ../../action.h \
+ ../../str_hash.h ../../hashes.h ../../mem/mem.h ../../clist.h \
+ ../../kstats_types.h ../../counters.h ../../pt.h ../../globals.h \
+ ../../types.h ../../ip_addr.h ../../poll_types.h ../../timer.h \
+ ../../dprint.h ../../timer_ticks.h ../../socket_info.h ../../locking.h \
+ ../../lock_ops.h ../../lock_alloc.h ../../mem/shm_mem.h \
+ ../../mi/mi_types.h ../../mi/../str.h ../../pvar.h ../../dprint.h \
+ ../../data_lump.h ../../lump_struct.h ../../parser/hf.h \
+ ../../data_lump_rpl.h ../../error.h ../../forward.h ../../proxy.h \
+ ../../stats.h ../../udp_server.h ../../tcp_server.h ../../tcp_conn.h \
+ ../../tcp_init.h ../../tcp_options.h ../../atomic_ops.h \
+ ../../atomic/atomic_common.h ../../atomic/atomic_native.h \
+ ../../sctp_core.h ../../compiler_opt.h ../../events.h ../../mem/mem.h \
+ ../../parser/parse_from.h ../../parser/parse_to.h \
+ ../../parser/msg_parser.h ../../parser/parse_addr_spec.h \
+ ../../parser/parse_to.h ../../parser/parse_uri.h \
+ ../../parser/../parser/msg_parser.h ../../parser/parser_f.h \
+ ../../parser/sdp/sdp.h ../../parser/sdp/../msg_parser.h ../../resolve.h \
+ ../../dns_func.h ../../dns_wrappers.h ../../timer.h ../../trim.h \
+ ../../ut.h ../../pt.h ../../timer_proc.h ../../local_timer.h \
+ ../../timer_funcs.h ../../lib/kmi/mi.h ../../lib/kmi/../../str.h \
+ ../../lib/kmi/../../mi/mi_types.h ../../lib/kmi/tree.h \
+ ../../lib/kmi/attr.h ../../pvar.h ../../lvalue.h ../../rvalue.h \
+ ../../ut.h ../../msg_translator.h ../../usr_avp.h ../../socket_info.h \
+ ../../mod_fix.h ../../sr_module.h ../../dset.h ../../qvalue.h \
+ ../../flags.h ../../route.h ../../modules/tm/tm_load.h \
+ ../../modules/tm/defs.h ../../modules/tm/../../sr_module.h \
+ ../../modules/tm/t_hooks.h ../../modules/tm/../../ip_addr.h \
+ ../../modules/tm/uac.h ../../modules/tm/../../str.h \
+ ../../modules/tm/dlg.h ../../modules/tm/../../parser/parse_rr.h \
+ ../../modules/tm/../../parser/msg_parser.h \
+ ../../modules/tm/../../parser/parse_nameaddr.h \
+ ../../modules/tm/../../parser/../str.h \
+ ../../modules/tm/../../parser/parse_param.h \
+ ../../modules/tm/../../parser/hf.h \
+ ../../modules/tm/../../parser/msg_parser.h ../../modules/tm/h_table.h \
+ ../../modules/tm/t_stats.h ../../modules/tm/../../rpc.h \
+ ../../modules/tm/../../pt.h ../../modules/tm/../../clist.h \
+ ../../modules/tm/../../types.h ../../modules/tm/../../md5utils.h \
+ ../../modules/tm/../../usr_avp.h ../../modules/tm/../../xavp.h \
+ ../../modules/tm/../../str.h ../../modules/tm/../../str_list.h \
+ ../../modules/tm/../../timer.h ../../modules/tm/../../flags.h \
+ ../../modules/tm/../../atomic_ops.h ../../modules/tm/../../hash_func.h \
+ ../../modules/tm/../../hashes.h ../../modules/tm/config.h \
+ ../../modules/tm/../../cfg/cfg.h ../../modules/tm/../../mem/shm_mem.h \
+ ../../modules/tm/lock.h ../../modules/tm/../../dprint.h \
+ ../../modules/tm/../../locking.h ../../modules/tm/sip_msg.h \
+ ../../modules/tm/t_reply.h ../../modules/tm/../../tags.h \
+ ../../modules/tm/../../parser/msg_parser.h \
+ ../../modules/tm/../../globals.h ../../modules/tm/../../crc.h \
+ ../../modules/tm/../../socket_info.h ../../modules/tm/../../dns_cache.h \
+ ../../modules/tm/../../config.h ../../modules/tm/../../timer.h \
+ ../../modules/tm/../../ip_addr.h ../../modules/tm/../../atomic_ops.h \
+ ../../modules/tm/../../resolve.h ../../modules/tm/t_fwd.h \
+ ../../modules/tm/../../proxy.h ../../modules/tm/t_lookup.h \
+ ../../modules/tm/t_funcs.h ../../modules/tm/../../globals.h \
+ ../../modules/tm/../../udp_server.h \
+ ../../modules/tm/../../msg_translator.h ../../modules/tm/../../forward.h \
+ ../../modules/tm/../../mem/mem.h \
+ ../../modules/tm/../../parser/parse_uri.h ../../modules/tm/timer.h \
+ ../../modules/tm/../../compiler_opt.h ../../modules/tm/ut.h \
+ ../../modules/tm/../../ut.h ../../modules/tm/../../error.h \
+ ../../modules/tm/../../resolve.h ../../modules/tm/../../cfg_core.h \
+ ../../modules/tm/callid.h ../../modules/tm/t_cancel.h \
+ ../../modules/tm/t_suspend.h rtpengine.h bencode.h ../../str.h \
+ rtpengine_funcs.h ../../parser/msg_parser.h \
+ ../../parser/contact/contact.h ../../parser/contact/../../str.h \
+ ../../parser/contact/../parse_param.h rtpengine_hash.h ../../locking.h
+
+../../flags.h:
+
+../../sr_module.h:
+
+../../parser/msg_parser.h:
+
+../../parser/../comp_defs.h:
+
+../../parser/../str.h:
+
+../../parser/../lump_struct.h:
+
+../../parser/.././parser/hf.h:
+
+../../parser/.././parser/../str.h:
+
+../../parser/.././parser/../comp_defs.h:
+
+../../parser/../flags.h:
+
+../../parser/../ip_addr.h:
+
+../../parser/../str.h:
+
+../../parser/../compiler_opt.h:
+
+../../parser/../ut.h:
+
+../../parser/../comp_defs.h:
+
+../../parser/../config.h:
+
+../../parser/../types.h:
+
+../../parser/../dprint.h:
+
+../../parser/../cfg_core.h:
+
+../../parser/../cfg/cfg.h:
+
+../../parser/../cfg/../str.h:
+
+../../parser/../mem/mem.h:
+
+../../parser/../mem/../config.h:
+
+../../parser/../mem/../dprint.h:
+
+../../parser/../mem/q_malloc.h:
+
+../../parser/../mem/meminfo.h:
+
+../../parser/../mem/src_loc.h:
+
+../../parser/../mem/shm_mem.h:
+
+../../parser/../mem/../lock_ops.h:
+
+../../parser/../mem/../futexlock.h:
+
+../../parser/../mem/../atomic/atomic_common.h:
+
+../../parser/../mem/../atomic/atomic_native.h:
+
+../../parser/../mem/../atomic/atomic_x86.h:
+
+../../parser/../mem/../compiler_opt.h:
+
+../../parser/../md5utils.h:
+
+../../parser/../config.h:
+
+../../parser/parse_def.h:
+
+../../parser/parse_cseq.h:
+
+../../parser/parse_via.h:
+
+../../parser/parse_fline.h:
+
+../../parser/parse_retry_after.h:
+
+../../parser/hf.h:
+
+../../parser/../error.h:
+
+../../ver_defs.h:
+
+../../rpc.h:
+
+../../route_struct.h:
+
+../../select.h:
+
+../../str.h:
+
+../../usr_avp.h:
+
+../../route.h:
+
+../../config.h:
+
+../../error.h:
+
+../../action.h:
+
+../../str_hash.h:
+
+../../hashes.h:
+
+../../mem/mem.h:
+
+../../clist.h:
+
+../../kstats_types.h:
+
+../../counters.h:
+
+../../pt.h:
+
+../../globals.h:
+
+../../types.h:
+
+../../ip_addr.h:
+
+../../poll_types.h:
+
+../../timer.h:
+
+../../dprint.h:
+
+../../timer_ticks.h:
+
+../../socket_info.h:
+
+../../locking.h:
+
+../../lock_ops.h:
+
+../../lock_alloc.h:
+
+../../mem/shm_mem.h:
+
+../../mi/mi_types.h:
+
+../../mi/../str.h:
+
+../../pvar.h:
+
+../../dprint.h:
+
+../../data_lump.h:
+
+../../lump_struct.h:
+
+../../parser/hf.h:
+
+../../data_lump_rpl.h:
+
+../../error.h:
+
+../../forward.h:
+
+../../proxy.h:
+
+../../stats.h:
+
+../../udp_server.h:
+
+../../tcp_server.h:
+
+../../tcp_conn.h:
+
+../../tcp_init.h:
+
+../../tcp_options.h:
+
+../../atomic_ops.h:
+
+../../atomic/atomic_common.h:
+
+../../atomic/atomic_native.h:
+
+../../sctp_core.h:
+
+../../compiler_opt.h:
+
+../../events.h:
+
+../../mem/mem.h:
+
+../../parser/parse_from.h:
+
+../../parser/parse_to.h:
+
+../../parser/msg_parser.h:
+
+../../parser/parse_addr_spec.h:
+
+../../parser/parse_to.h:
+
+../../parser/parse_uri.h:
+
+../../parser/../parser/msg_parser.h:
+
+../../parser/parser_f.h:
+
+../../parser/sdp/sdp.h:
+
+../../parser/sdp/../msg_parser.h:
+
+../../resolve.h:
+
+../../dns_func.h:
+
+../../dns_wrappers.h:
+
+../../timer.h:
+
+../../trim.h:
+
+../../ut.h:
+
+../../pt.h:
+
+../../timer_proc.h:
+
+../../local_timer.h:
+
+../../timer_funcs.h:
+
+../../lib/kmi/mi.h:
+
+../../lib/kmi/../../str.h:
+
+../../lib/kmi/../../mi/mi_types.h:
+
+../../lib/kmi/tree.h:
+
+../../lib/kmi/attr.h:
+
+../../pvar.h:
+
+../../lvalue.h:
+
+../../rvalue.h:
+
+../../ut.h:
+
+../../msg_translator.h:
+
+../../usr_avp.h:
+
+../../socket_info.h:
+
+../../mod_fix.h:
+
+../../sr_module.h:
+
+../../dset.h:
+
+../../qvalue.h:
+
+../../flags.h:
+
+../../route.h:
+
+../../modules/tm/tm_load.h:
+
+../../modules/tm/defs.h:
+
+../../modules/tm/../../sr_module.h:
+
+../../modules/tm/t_hooks.h:
+
+../../modules/tm/../../ip_addr.h:
+
+../../modules/tm/uac.h:
+
+../../modules/tm/../../str.h:
+
+../../modules/tm/dlg.h:
+
+../../modules/tm/../../parser/parse_rr.h:
+
+../../modules/tm/../../parser/msg_parser.h:
+
+../../modules/tm/../../parser/parse_nameaddr.h:
+
+../../modules/tm/../../parser/../str.h:
+
+../../modules/tm/../../parser/parse_param.h:
+
+../../modules/tm/../../parser/hf.h:
+
+../../modules/tm/../../parser/msg_parser.h:
+
+../../modules/tm/h_table.h:
+
+../../modules/tm/t_stats.h:
+
+../../modules/tm/../../rpc.h:
+
+../../modules/tm/../../pt.h:
+
+../../modules/tm/../../clist.h:
+
+../../modules/tm/../../types.h:
+
+../../modules/tm/../../md5utils.h:
+
+../../modules/tm/../../usr_avp.h:
+
+../../modules/tm/../../xavp.h:
+
+../../modules/tm/../../str.h:
+
+../../modules/tm/../../str_list.h:
+
+../../modules/tm/../../timer.h:
+
+../../modules/tm/../../flags.h:
+
+../../modules/tm/../../atomic_ops.h:
+
+../../modules/tm/../../hash_func.h:
+
+../../modules/tm/../../hashes.h:
+
+../../modules/tm/config.h:
+
+../../modules/tm/../../cfg/cfg.h:
+
+../../modules/tm/../../mem/shm_mem.h:
+
+../../modules/tm/lock.h:
+
+../../modules/tm/../../dprint.h:
+
+../../modules/tm/../../locking.h:
+
+../../modules/tm/sip_msg.h:
+
+../../modules/tm/t_reply.h:
+
+../../modules/tm/../../tags.h:
+
+../../modules/tm/../../parser/msg_parser.h:
+
+../../modules/tm/../../globals.h:
+
+../../modules/tm/../../crc.h:
+
+../../modules/tm/../../socket_info.h:
+
+../../modules/tm/../../dns_cache.h:
+
+../../modules/tm/../../config.h:
+
+../../modules/tm/../../timer.h:
+
+../../modules/tm/../../ip_addr.h:
+
+../../modules/tm/../../atomic_ops.h:
+
+../../modules/tm/../../resolve.h:
+
+../../modules/tm/t_fwd.h:
+
+../../modules/tm/../../proxy.h:
+
+../../modules/tm/t_lookup.h:
+
+../../modules/tm/t_funcs.h:
+
+../../modules/tm/../../globals.h:
+
+../../modules/tm/../../udp_server.h:
+
+../../modules/tm/../../msg_translator.h:
+
+../../modules/tm/../../forward.h:
+
+../../modules/tm/../../mem/mem.h:
+
+../../modules/tm/../../parser/parse_uri.h:
+
+../../modules/tm/timer.h:
+
+../../modules/tm/../../compiler_opt.h:
+
+../../modules/tm/ut.h:
+
+../../modules/tm/../../ut.h:
+
+../../modules/tm/../../error.h:
+
+../../modules/tm/../../resolve.h:
+
+../../modules/tm/../../cfg_core.h:
+
+../../modules/tm/callid.h:
+
+../../modules/tm/t_cancel.h:
+
+../../modules/tm/t_suspend.h:
+
+rtpengine.h:
+
+bencode.h:
+
+../../str.h:
+
+rtpengine_funcs.h:
+
+../../parser/msg_parser.h:
+
+../../parser/contact/contact.h:
+
+../../parser/contact/../../str.h:
+
+../../parser/contact/../parse_param.h:
+
+rtpengine_hash.h:
+
+../../locking.h:
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/rtpengine.h ui-siprouter/modules/rtpengine/rtpengine.h
--- ui-siprouter~/modules/rtpengine/rtpengine.h	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/rtpengine.h	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2003 Porta Software Ltd
+ * Copyright (C) 2014-2015 Sipwise GmbH, http://www.sipwise.com
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * Kamailio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * Kamailio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+
+#ifndef _RTPENGINE_H
+#define _RTPENGINE_H
+
+#include "bencode.h"
+#include "../../str.h"
+
+#define MI_MIN_RECHECK_TICKS		0
+#define MI_MAX_RECHECK_TICKS		((unsigned int)-1)
+
+struct rtpp_node {
+	unsigned int		idx;			/* overall index */
+	str			rn_url;			/* unparsed, deletable */
+	int			rn_umode;
+	char			*rn_address;		/* substring of rn_url */
+	int			rn_disabled;		/* found unaccessible? */
+	unsigned int		rn_weight;		/* for load balancing */
+	unsigned int		rn_displayed;		/* for delete at db reload */
+	unsigned int		rn_recheck_ticks;
+	int			rn_rep_supported;
+	int			rn_ptl_supported;
+	struct rtpp_node	*rn_next;
+};
+
+
+struct rtpp_set {
+	unsigned int 		id_set;
+	unsigned int		weight_sum;
+	unsigned int		rtpp_node_count;
+	int 			set_disabled;
+	unsigned int		set_recheck_ticks;
+	struct rtpp_node	*rn_first;
+	struct rtpp_node	*rn_last;
+	struct rtpp_set	 	*rset_next;
+	gen_lock_t		*rset_lock;
+};
+
+
+struct rtpp_set_head {
+	struct rtpp_set		*rset_first;
+	struct rtpp_set		*rset_last;
+	gen_lock_t		*rset_head_lock;
+};
+
+
+struct rtpp_node *get_rtpp_node(struct rtpp_set *rtpp_list, str *url);
+struct rtpp_set *get_rtpp_set(int set_id);
+int add_rtpengine_socks(struct rtpp_set * rtpp_list, char * rtpproxy, unsigned int weight, int disabled, unsigned int ticks, int isDB);
+
+int rtpengine_delete_node(struct rtpp_node *rtpp_node);
+int rtpengine_delete_node_set(struct rtpp_set *rtpp_list);
+int rtpengine_delete_node_all();
+
+
+int init_rtpproxy_db(void);
+
+extern str rtpp_db_url;
+extern str rtpp_table_name;
+extern str rtpp_setid_col;
+extern str rtpp_url_col;
+extern str rtpp_weight_col;
+extern str rtpp_disabled_col;
+
+
+#endif
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/rtpengine_db.c ui-siprouter/modules/rtpengine/rtpengine_db.c
--- ui-siprouter~/modules/rtpengine/rtpengine_db.c	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/rtpengine_db.c	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,180 @@
+/*
+ * Copyright (c) 2013 Crocodile RCS Ltd
+ * Copyright (C) 2014-2015 Sipwise GmbH, http://www.sipwise.com
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * Kamailio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * Kamailio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "../../lib/srdb1/db.h"
+#include "../../lib/srdb1/db_res.h"
+
+#include "../../parser/msg_parser.h"
+#include "rtpengine.h"
+
+#define RTPP_TABLE_VERSION 1
+
+static db_func_t rtpp_dbf;
+static db1_con_t *rtpp_db_handle = NULL;
+
+str rtpp_db_url = {NULL, 0};
+str rtpp_table_name = str_init("rtpengine");
+str rtpp_setid_col = str_init("setid");
+str rtpp_url_col = str_init("url");
+str rtpp_weight_col = str_init("weight");
+str rtpp_disabled_col = str_init("disabled");
+
+static int rtpp_connect_db(void)
+{
+	if ((rtpp_db_url.s == NULL) || (rtpp_db_url.len == 0))
+		return -1;
+	if ((rtpp_db_handle = rtpp_dbf.init(&rtpp_db_url)) == NULL)
+	{
+		LM_ERR("Cannot initialize db connection\n");
+		return -1;
+	}
+	return 0;
+}
+
+static void rtpp_disconnect_db(void)
+{
+	if (rtpp_db_handle)
+	{
+		rtpp_dbf.close(rtpp_db_handle);
+		rtpp_db_handle = NULL;
+	}
+}
+
+static int rtpp_load_db(void)
+{
+	int i;
+	struct rtpp_set *rtpp_list = NULL;
+	db1_res_t *res = NULL;
+	db_val_t *values = NULL;
+	db_row_t *rows = NULL;
+	db_key_t query_cols[] = {&rtpp_setid_col, &rtpp_url_col, &rtpp_weight_col, &rtpp_disabled_col};
+
+	str url;
+	int setid, disabled;
+	unsigned int weight, ticks;
+
+	/* int weight, flags; */
+	int n_rows = 0;
+	int n_cols = 4;
+
+	if (rtpp_db_handle == NULL)
+	{
+		LM_ERR("invalid db handle\n");
+		return -1;
+	}
+	if (rtpp_dbf.use_table(rtpp_db_handle, &rtpp_table_name) < 0)
+	{
+		LM_ERR("unable to use table '%.*s'\n", rtpp_table_name.len, rtpp_table_name.s);
+		return -1;
+	}
+	if (rtpp_dbf.query(rtpp_db_handle, 0, 0, 0, query_cols, 0, n_cols, 0, &res) < 0)
+	{
+		LM_ERR("error while running db query\n");
+		return -1;
+	}
+
+	rtpengine_delete_node_all();
+
+	n_rows = RES_ROW_N(res);
+	rows = RES_ROWS(res);
+	if (n_rows == 0)
+	{
+		LM_WARN("No rtpproxy instances in database\n");
+		return 0;
+	}
+
+	for (i=0; i<n_rows; i++)
+	{
+		values = ROW_VALUES(rows + i);
+
+		setid = VAL_INT(values);
+		url.s = VAL_STR(values+1).s;
+		url.len = strlen(url.s);
+		weight = VAL_INT(values+2);
+		disabled = VAL_INT(values+3);
+		if (disabled) {
+			ticks = MI_MAX_RECHECK_TICKS;
+		} else {
+			ticks = 0;
+		}
+		/*
+		weight = VAL_INT(values+2);
+		flags = VAL_INT(values+3);
+		*/
+		if ((rtpp_list = get_rtpp_set(setid)) == NULL)
+		{
+			LM_ERR("error getting rtpp_list for set %d\n", setid);
+			continue;
+		}
+
+		if (add_rtpengine_socks(rtpp_list, url.s, weight, disabled, ticks, 1) !=  0)
+		{
+			LM_ERR("error inserting '%.*s' into set %d disabled=%d\n",
+				url.len, url.s, setid, disabled);
+		}
+	}
+
+	rtpp_dbf.free_result(rtpp_db_handle, res);
+	return 0;
+}
+
+int init_rtpproxy_db(void)
+{
+	int ret;
+	int rtpp_table_version;
+	if (rtpp_db_url.s == NULL)
+		/* Database not configured */
+		return 0;
+
+	if (db_bind_mod(&rtpp_db_url, &rtpp_dbf) < 0)
+	{
+		LM_ERR("Unable to bind to db driver - %.*s\n", rtpp_db_url.len, rtpp_db_url.s);
+		return -1;
+	}
+	if (rtpp_connect_db() != 0)
+	{
+		LM_ERR("Unable to connect to db\n");
+		return -1;
+	}
+
+	rtpp_table_version = db_table_version(&rtpp_dbf, rtpp_db_handle, &rtpp_table_name);
+	if (rtpp_table_version < 0)
+	{
+		LM_ERR("failed to get rtpp table version\n");
+		ret = -1;
+		goto done;
+	}
+	switch (rtpp_table_version) {
+		case RTPP_TABLE_VERSION:
+			break;
+		default:
+			LM_ERR("invalid table version (found %d, require %d)\n",
+			  rtpp_table_version, RTPP_TABLE_VERSION);
+			ret = -1;
+			goto done;
+	}
+	ret = rtpp_load_db();
+
+done:
+	rtpp_disconnect_db();
+
+	return ret;
+}
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/rtpengine_db.d ui-siprouter/modules/rtpengine/rtpengine_db.d
--- ui-siprouter~/modules/rtpengine/rtpengine_db.d	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/rtpengine_db.d	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,156 @@
+rtpengine_db.o: rtpengine_db.c ../../lib/srdb1/db.h \
+ ../../lib/srdb1/db_key.h ../../lib/srdb1/../../ut.h \
+ ../../lib/srdb1/../../comp_defs.h ../../lib/srdb1/../../compiler_opt.h \
+ ../../lib/srdb1/../../config.h ../../lib/srdb1/../../types.h \
+ ../../lib/srdb1/../../dprint.h ../../lib/srdb1/../../cfg_core.h \
+ ../../lib/srdb1/../../cfg/cfg.h ../../lib/srdb1/../../cfg/../str.h \
+ ../../lib/srdb1/../../str.h ../../lib/srdb1/../../mem/mem.h \
+ ../../lib/srdb1/../../mem/../config.h \
+ ../../lib/srdb1/../../mem/../dprint.h \
+ ../../lib/srdb1/../../mem/q_malloc.h ../../lib/srdb1/../../mem/meminfo.h \
+ ../../lib/srdb1/../../mem/src_loc.h ../../lib/srdb1/../../mem/shm_mem.h \
+ ../../lib/srdb1/../../mem/../lock_ops.h \
+ ../../lib/srdb1/../../mem/../futexlock.h \
+ ../../lib/srdb1/../../mem/../atomic/atomic_common.h \
+ ../../lib/srdb1/../../mem/../atomic/atomic_native.h \
+ ../../lib/srdb1/../../mem/../atomic/atomic_x86.h \
+ ../../lib/srdb1/../../mem/../compiler_opt.h ../../lib/srdb1/db_op.h \
+ ../../lib/srdb1/db_val.h ../../lib/srdb1/db_con.h \
+ ../../lib/srdb1/../../str.h ../../lib/srdb1/db_res.h \
+ ../../lib/srdb1/db_cap.h ../../lib/srdb1/db_row.h \
+ ../../lib/srdb1/db_pooling.h ../../lib/srdb1/db_locking.h \
+ ../../lib/srdb1/db_res.h ../../parser/msg_parser.h \
+ ../../parser/../comp_defs.h ../../parser/../str.h \
+ ../../parser/../lump_struct.h ../../parser/.././parser/hf.h \
+ ../../parser/.././parser/../str.h \
+ ../../parser/.././parser/../comp_defs.h ../../parser/../flags.h \
+ ../../parser/../ip_addr.h ../../parser/../str.h \
+ ../../parser/../compiler_opt.h ../../parser/../ut.h \
+ ../../parser/../dprint.h ../../parser/../md5utils.h \
+ ../../parser/../config.h ../../parser/parse_def.h \
+ ../../parser/parse_cseq.h ../../parser/parse_via.h \
+ ../../parser/parse_fline.h ../../parser/parse_retry_after.h \
+ ../../parser/hf.h ../../parser/../error.h rtpengine.h bencode.h \
+ ../../mem/mem.h ../../str.h
+
+../../lib/srdb1/db.h:
+
+../../lib/srdb1/db_key.h:
+
+../../lib/srdb1/../../ut.h:
+
+../../lib/srdb1/../../comp_defs.h:
+
+../../lib/srdb1/../../compiler_opt.h:
+
+../../lib/srdb1/../../config.h:
+
+../../lib/srdb1/../../types.h:
+
+../../lib/srdb1/../../dprint.h:
+
+../../lib/srdb1/../../cfg_core.h:
+
+../../lib/srdb1/../../cfg/cfg.h:
+
+../../lib/srdb1/../../cfg/../str.h:
+
+../../lib/srdb1/../../str.h:
+
+../../lib/srdb1/../../mem/mem.h:
+
+../../lib/srdb1/../../mem/../config.h:
+
+../../lib/srdb1/../../mem/../dprint.h:
+
+../../lib/srdb1/../../mem/q_malloc.h:
+
+../../lib/srdb1/../../mem/meminfo.h:
+
+../../lib/srdb1/../../mem/src_loc.h:
+
+../../lib/srdb1/../../mem/shm_mem.h:
+
+../../lib/srdb1/../../mem/../lock_ops.h:
+
+../../lib/srdb1/../../mem/../futexlock.h:
+
+../../lib/srdb1/../../mem/../atomic/atomic_common.h:
+
+../../lib/srdb1/../../mem/../atomic/atomic_native.h:
+
+../../lib/srdb1/../../mem/../atomic/atomic_x86.h:
+
+../../lib/srdb1/../../mem/../compiler_opt.h:
+
+../../lib/srdb1/db_op.h:
+
+../../lib/srdb1/db_val.h:
+
+../../lib/srdb1/db_con.h:
+
+../../lib/srdb1/../../str.h:
+
+../../lib/srdb1/db_res.h:
+
+../../lib/srdb1/db_cap.h:
+
+../../lib/srdb1/db_row.h:
+
+../../lib/srdb1/db_pooling.h:
+
+../../lib/srdb1/db_locking.h:
+
+../../lib/srdb1/db_res.h:
+
+../../parser/msg_parser.h:
+
+../../parser/../comp_defs.h:
+
+../../parser/../str.h:
+
+../../parser/../lump_struct.h:
+
+../../parser/.././parser/hf.h:
+
+../../parser/.././parser/../str.h:
+
+../../parser/.././parser/../comp_defs.h:
+
+../../parser/../flags.h:
+
+../../parser/../ip_addr.h:
+
+../../parser/../str.h:
+
+../../parser/../compiler_opt.h:
+
+../../parser/../ut.h:
+
+../../parser/../dprint.h:
+
+../../parser/../md5utils.h:
+
+../../parser/../config.h:
+
+../../parser/parse_def.h:
+
+../../parser/parse_cseq.h:
+
+../../parser/parse_via.h:
+
+../../parser/parse_fline.h:
+
+../../parser/parse_retry_after.h:
+
+../../parser/hf.h:
+
+../../parser/../error.h:
+
+rtpengine.h:
+
+bencode.h:
+
+../../mem/mem.h:
+
+../../str.h:
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/rtpengine_funcs.c ui-siprouter/modules/rtpengine/rtpengine_funcs.c
--- ui-siprouter~/modules/rtpengine/rtpengine_funcs.c	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/rtpengine_funcs.c	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,394 @@
+/*
+ * Copyright (C) 2001-2003 FhG Fokus
+ * Copyright (C) 2014-2015 Sipwise GmbH, http://www.sipwise.com
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * Kamailio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * Kamailio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include "rtpengine_funcs.h"
+#include "../../dprint.h"
+#include "../../config.h"
+#include "../../ut.h"
+#include "../../forward.h"
+#include "../../resolve.h"
+#include "../../globals.h"
+#include "../../udp_server.h"
+#include "../../pt.h"
+#include "../../parser/msg_parser.h"
+#include "../../trim.h"
+#include "../../parser/parse_from.h"
+#include "../../parser/contact/parse_contact.h"
+#include "../../parser/parse_uri.h"
+#include "../../parser/parse_content.h"
+#include "../../parser/parser_f.h"
+#include "../../parser/sdp/sdp_helpr_funcs.h"
+
+#define READ(val) \
+	(*(val + 0) + (*(val + 1) << 8) + (*(val + 2) << 16) + (*(val + 3) << 24))
+#define advance(_ptr,_n,_str,_error) \
+	do{\
+		if ((_ptr)+(_n)>(_str).s+(_str).len)\
+			goto _error;\
+		(_ptr) = (_ptr) + (_n);\
+	}while(0);
+#define one_of_16( _x , _t ) \
+	(_x==_t[0]||_x==_t[15]||_x==_t[8]||_x==_t[2]||_x==_t[3]||_x==_t[4]\
+	||_x==_t[5]||_x==_t[6]||_x==_t[7]||_x==_t[1]||_x==_t[9]||_x==_t[10]\
+	||_x==_t[11]||_x==_t[12]||_x==_t[13]||_x==_t[14])
+#define one_of_8( _x , _t ) \
+	(_x==_t[0]||_x==_t[7]||_x==_t[1]||_x==_t[2]||_x==_t[3]||_x==_t[4]\
+	||_x==_t[5]||_x==_t[6])
+
+
+
+/**
+ * return:
+ * -1: error
+ *  1: text or sdp
+ *  2: multipart
+ */
+int check_content_type(struct sip_msg *msg)
+{
+	static unsigned int appl[16] = {
+		0x6c707061/*appl*/,0x6c707041/*Appl*/,0x6c705061/*aPpl*/,
+		0x6c705041/*APpl*/,0x6c507061/*apPl*/,0x6c507041/*ApPl*/,
+		0x6c505061/*aPPl*/,0x6c505041/*APPl*/,0x4c707061/*appL*/,
+		0x4c707041/*AppL*/,0x4c705061/*aPpL*/,0x4c705041/*APpL*/,
+		0x4c507061/*apPL*/,0x4c507041/*ApPL*/,0x4c505061/*aPPL*/,
+		0x4c505041/*APPL*/};
+	static unsigned int icat[16] = {
+		0x74616369/*icat*/,0x74616349/*Icat*/,0x74614369/*iCat*/,
+		0x74614349/*ICat*/,0x74416369/*icAt*/,0x74416349/*IcAt*/,
+		0x74414369/*iCAt*/,0x74414349/*ICAt*/,0x54616369/*icaT*/,
+		0x54616349/*IcaT*/,0x54614369/*iCaT*/,0x54614349/*ICaT*/,
+		0x54416369/*icAT*/,0x54416349/*IcAT*/,0x54414369/*iCAT*/,
+		0x54414349/*ICAT*/};
+	static unsigned int ion_[8] = {
+		0x006e6f69/*ion_*/,0x006e6f49/*Ion_*/,0x006e4f69/*iOn_*/,
+		0x006e4f49/*IOn_*/,0x004e6f69/*ioN_*/,0x004e6f49/*IoN_*/,
+		0x004e4f69/*iON_*/,0x004e4f49/*ION_*/};
+	static unsigned int sdp_[8] = {
+		0x00706473/*sdp_*/,0x00706453/*Sdp_*/,0x00704473/*sDp_*/,
+		0x00704453/*SDp_*/,0x00506473/*sdP_*/,0x00506453/*SdP_*/,
+		0x00504473/*sDP_*/,0x00504453/*SDP_*/};
+	str           str_type;
+	unsigned int  x;
+	char          *p;
+
+	if (!msg->content_type)
+	{
+		LM_WARN("the header Content-TYPE is absent!"
+			"let's assume the content is text/plain ;-)\n");
+		return 1;
+	}
+
+	trim_len(str_type.len,str_type.s,msg->content_type->body);
+	if (str_type.len>=15 && (*str_type.s=='m' || *str_type.s=='M')
+			&& strncasecmp(str_type.s, "multipart/mixed", 15) == 0) {
+		return 2;
+    }
+	p = str_type.s;
+	advance(p,4,str_type,error_1);
+	x = READ(p-4);
+	if (!one_of_16(x,appl))
+		goto other;
+	advance(p,4,str_type,error_1);
+	x = READ(p-4);
+	if (!one_of_16(x,icat))
+		goto other;
+	advance(p,3,str_type,error_1);
+	x = READ(p-3) & 0x00ffffff;
+	if (!one_of_8(x,ion_))
+		goto other;
+
+	/* skip spaces and tabs if any */
+	while (*p==' ' || *p=='\t')
+		advance(p,1,str_type,error_1);
+	if (*p!='/')
+	{
+		LM_ERR("no / found after primary type\n");
+		goto error;
+	}
+	advance(p,1,str_type,error_1);
+	while ((*p==' ' || *p=='\t') && p+1<str_type.s+str_type.len)
+		advance(p,1,str_type,error_1);
+
+	advance(p,3,str_type,error_1);
+	x = READ(p-3) & 0x00ffffff;
+	if (!one_of_8(x,sdp_))
+		goto other;
+
+	if (*p==';'||*p==' '||*p=='\t'||*p=='\n'||*p=='\r'||*p==0) {
+		LM_DBG("type <%.*s> found valid\n", (int)(p-str_type.s), str_type.s);
+		return 1;
+	} else {
+		LM_ERR("bad end for type!\n");
+		return -1;
+	}
+
+error_1:
+	LM_ERR("body ended :-(!\n");
+error:
+	return -1;
+other:
+	LM_ERR("invalid type for a message\n");
+	return -1;
+}
+
+
+/*
+ * Get message body and check Content-Type header field
+ */
+int extract_body(struct sip_msg *msg, str *body )
+{
+	char c;
+	int ret;
+	str mpdel;
+	char *rest, *p1, *p2;
+	struct hdr_field hf;
+	unsigned int mime;
+
+	body->s = get_body(msg);
+	if (body->s==0) {
+		LM_ERR("failed to get the message body\n");
+		goto error;
+	}
+
+	/*
+	 * Better use the content-len value - no need of any explicit
+	 * parcing as get_body() parsed all headers and Conten-Length
+	 * body header is automaticaly parsed when found.
+	 */
+	if (msg->content_length==0) {
+		LM_ERR("failed to get the content length in message\n");
+		goto error;
+	}
+
+	body->len = get_content_length(msg);
+	if (body->len==0) {
+		LM_ERR("message body has length zero\n");
+		goto error;
+	}
+
+	if (body->len + body->s > msg->buf + msg->len) {
+		LM_ERR("content-length exceeds packet-length by %d\n",
+				(int)((body->len + body->s) - (msg->buf + msg->len)));
+		goto error;
+	}
+
+	/* no need for parse_headers(msg, EOH), get_body will
+	 * parse everything */
+	/*is the content type correct?*/
+	if((ret = check_content_type(msg))==-1)
+	{
+		LM_ERR("content type mismatching\n");
+		goto error;
+	}
+
+	if(ret!=2)
+		goto done;
+
+	/* multipart body */
+	if(get_mixed_part_delimiter(&msg->content_type->body,&mpdel) < 0) {
+		goto error;
+	}
+	p1 = find_sdp_line_delimiter(body->s, body->s+body->len, mpdel);
+	if (p1 == NULL) {
+		LM_ERR("empty multipart content\n");
+		return -1;
+	}
+	p2=p1;
+	c = 0;
+	for(;;)
+	{
+		p1 = p2;
+		if (p1 == NULL || p1 >= body->s+body->len)
+			break; /* No parts left */
+		p2 = find_next_sdp_line_delimiter(p1, body->s+body->len,
+				mpdel, body->s+body->len);
+		/* p2 is text limit for application parsing */
+		rest = eat_line(p1 + mpdel.len + 2, p2 - p1 - mpdel.len - 2);
+		if ( rest > p2 ) {
+			LM_ERR("Unparsable <%.*s>\n", (int)(p1-p1), p1);
+			return -1;
+		}
+		while( rest<p2 ) {
+			memset(&hf,0, sizeof(struct hdr_field));
+			rest = get_sdp_hdr_field(rest, p2, &hf);
+			if(hf.type==HDR_EOH_T)
+				break;
+			if(hf.type==HDR_ERROR_T)
+				return -1;
+			if(hf.type==HDR_CONTENTTYPE_T) {
+				if(decode_mime_type(hf.body.s, hf.body.s + hf.body.len,
+						&mime)==NULL)
+					return -1;
+				if (((((unsigned int)mime)>>16) == TYPE_APPLICATION)
+						&& ((mime&0x00ff) == SUBTYPE_SDP)) {
+					c = 1;
+				}
+			}
+		} /* end of while */
+		if(c==1)
+		{
+			if (rest < p2 && *rest == '\r') rest++;
+			if (rest < p2 && *rest == '\n') rest++;
+			if (rest < p2 && p2[-1] == '\n') p2--;
+			if (rest < p2 && p2[-1] == '\r') p2--;
+			body->s = rest;
+			body->len = p2-rest;
+			goto done;
+		}
+	}
+
+error:
+	return -1;
+
+done:
+	/*LM_DBG("DEBUG:extract_body:=|%.*s|\n",body->len,body->s);*/
+	return 1;
+}
+
+/*
+ * Some helper functions taken verbatim from tm module.
+ */
+
+/*
+ * Extract Call-ID value
+ * assumes the callid header is already parsed
+ * (so make sure it is, before calling this function or
+ *  it might fail even if the message _has_ a callid)
+ */
+int
+get_callid(struct sip_msg* _m, str* _cid)
+{
+
+        if ((parse_headers(_m, HDR_CALLID_F, 0) == -1)) {
+                LM_ERR("failed to parse call-id header\n");
+                return -1;
+        }
+
+        if (_m->callid == NULL) {
+                LM_ERR("call-id not found\n");
+                return -1;
+        }
+
+        _cid->s = _m->callid->body.s;
+        _cid->len = _m->callid->body.len;
+        trim(_cid);
+        return 0;
+}
+
+/*
+ * Extract tag from To header field of a response
+ */
+int
+get_to_tag(struct sip_msg* _m, str* _tag)
+{
+
+        if (parse_to_header(_m) < 0) {
+                LM_ERR("To header field missing\n");
+                return -1;
+        }
+
+        if (get_to(_m)->tag_value.len) {
+                _tag->s = get_to(_m)->tag_value.s;
+                _tag->len = get_to(_m)->tag_value.len;
+        } else {
+                _tag->s = NULL; /* fixes gcc 4.0 warnings */
+                _tag->len = 0;
+        }
+
+        return 0;
+}
+
+/*
+ * Extract tag from From header field of a request
+ */
+int
+get_from_tag(struct sip_msg* _m, str* _tag)
+{
+
+        if (parse_from_header(_m)<0) {
+                LM_ERR("failed to parse From header\n");
+                return -1;
+        }
+
+        if (get_from(_m)->tag_value.len) {
+                _tag->s = get_from(_m)->tag_value.s;
+                _tag->len = get_from(_m)->tag_value.len;
+        } else {
+                _tag->s = NULL; /* fixes gcc 4.0 warnings */
+                _tag->len = 0;
+        }
+
+        return 0;
+}
+
+/*
+ * Extract URI from the Contact header field
+ */
+int
+get_contact_uri(struct sip_msg* _m, struct sip_uri *uri, contact_t** _c)
+{
+
+        if ((parse_headers(_m, HDR_CONTACT_F, 0) == -1) || !_m->contact)
+                return -1;
+        if (!_m->contact->parsed && parse_contact(_m->contact) < 0) {
+                LM_ERR("failed to parse Contact body\n");
+                return -1;
+        }
+        *_c = ((contact_body_t*)_m->contact->parsed)->contacts;
+        if (*_c == NULL)
+                /* no contacts found */
+                return -1;
+
+        if (parse_uri((*_c)->uri.s, (*_c)->uri.len, uri) < 0 || uri->host.len <= 0) {
+                LM_ERR("failed to parse Contact URI [%.*s]\n",
+                        (*_c)->uri.len, ((*_c)->uri.s)?(*_c)->uri.s:"");
+                return -1;
+        }
+        return 0;
+}
+
+/*
+ * Extract branch from Via header
+ */
+int
+get_via_branch(struct sip_msg* msg, int vianum, str* _branch)
+{
+	struct via_body *via;
+	struct via_param *p;
+
+	if (parse_via_header(msg, vianum, &via) < 0)
+		return -1;
+
+	for (p = via->param_lst; p; p = p->next)
+	{
+		if (p->name.len == strlen("branch")
+				&& strncasecmp(p->name.s, "branch", strlen("branch")) == 0) {
+			_branch->s = p->value.s;
+			_branch->len = p->value.len;
+			return 0;
+		}
+	}
+	return -1;
+}
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/rtpengine_funcs.d ui-siprouter/modules/rtpengine/rtpengine_funcs.d
--- ui-siprouter~/modules/rtpengine/rtpengine_funcs.d	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/rtpengine_funcs.d	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,274 @@
+rtpengine_funcs.o: rtpengine_funcs.c rtpengine_funcs.h ../../str.h \
+ ../../parser/msg_parser.h ../../parser/../comp_defs.h \
+ ../../parser/../str.h ../../parser/../lump_struct.h \
+ ../../parser/.././parser/hf.h ../../parser/.././parser/../str.h \
+ ../../parser/.././parser/../comp_defs.h ../../parser/../flags.h \
+ ../../parser/../ip_addr.h ../../parser/../str.h \
+ ../../parser/../compiler_opt.h ../../parser/../ut.h \
+ ../../parser/../comp_defs.h ../../parser/../config.h \
+ ../../parser/../types.h ../../parser/../dprint.h \
+ ../../parser/../cfg_core.h ../../parser/../cfg/cfg.h \
+ ../../parser/../cfg/../str.h ../../parser/../mem/mem.h \
+ ../../parser/../mem/../config.h ../../parser/../mem/../dprint.h \
+ ../../parser/../mem/q_malloc.h ../../parser/../mem/meminfo.h \
+ ../../parser/../mem/src_loc.h ../../parser/../mem/shm_mem.h \
+ ../../parser/../mem/../lock_ops.h ../../parser/../mem/../futexlock.h \
+ ../../parser/../mem/../atomic/atomic_common.h \
+ ../../parser/../mem/../atomic/atomic_native.h \
+ ../../parser/../mem/../atomic/atomic_x86.h \
+ ../../parser/../mem/../compiler_opt.h ../../parser/../md5utils.h \
+ ../../parser/../config.h ../../parser/parse_def.h \
+ ../../parser/parse_cseq.h ../../parser/parse_via.h \
+ ../../parser/parse_fline.h ../../parser/parse_retry_after.h \
+ ../../parser/hf.h ../../parser/../error.h ../../parser/contact/contact.h \
+ ../../parser/contact/../../str.h ../../parser/contact/../parse_param.h \
+ ../../parser/contact/../../str.h ../../dprint.h ../../config.h \
+ ../../ut.h ../../forward.h ../../globals.h ../../types.h ../../ip_addr.h \
+ ../../str.h ../../poll_types.h ../../parser/msg_parser.h ../../route.h \
+ ../../config.h ../../error.h ../../route_struct.h ../../select.h \
+ ../../usr_avp.h ../../action.h ../../str_hash.h ../../hashes.h \
+ ../../mem/mem.h ../../clist.h ../../proxy.h ../../stats.h \
+ ../../udp_server.h ../../tcp_server.h ../../tcp_conn.h ../../tcp_init.h \
+ ../../tcp_options.h ../../locking.h ../../lock_ops.h ../../lock_alloc.h \
+ ../../mem/shm_mem.h ../../atomic_ops.h ../../atomic/atomic_common.h \
+ ../../atomic/atomic_native.h ../../timer_ticks.h ../../timer.h \
+ ../../dprint.h ../../sctp_core.h ../../compiler_opt.h ../../events.h \
+ ../../resolve.h ../../counters.h ../../pt.h ../../socket_info.h \
+ ../../dns_func.h ../../dns_wrappers.h ../../globals.h ../../udp_server.h \
+ ../../pt.h ../../trim.h ../../parser/parse_from.h \
+ ../../parser/parse_to.h ../../parser/msg_parser.h \
+ ../../parser/parse_addr_spec.h ../../parser/contact/parse_contact.h \
+ ../../parser/contact/../hf.h ../../parser/contact/../msg_parser.h \
+ ../../parser/contact/contact.h ../../parser/parse_uri.h \
+ ../../parser/../parser/msg_parser.h ../../parser/parse_content.h \
+ ../../parser/parser_f.h ../../parser/sdp/sdp_helpr_funcs.h \
+ ../../parser/sdp/../../str.h ../../parser/sdp/../msg_parser.h \
+ ../../parser/sdp/sdp.h
+
+rtpengine_funcs.h:
+
+../../str.h:
+
+../../parser/msg_parser.h:
+
+../../parser/../comp_defs.h:
+
+../../parser/../str.h:
+
+../../parser/../lump_struct.h:
+
+../../parser/.././parser/hf.h:
+
+../../parser/.././parser/../str.h:
+
+../../parser/.././parser/../comp_defs.h:
+
+../../parser/../flags.h:
+
+../../parser/../ip_addr.h:
+
+../../parser/../str.h:
+
+../../parser/../compiler_opt.h:
+
+../../parser/../ut.h:
+
+../../parser/../comp_defs.h:
+
+../../parser/../config.h:
+
+../../parser/../types.h:
+
+../../parser/../dprint.h:
+
+../../parser/../cfg_core.h:
+
+../../parser/../cfg/cfg.h:
+
+../../parser/../cfg/../str.h:
+
+../../parser/../mem/mem.h:
+
+../../parser/../mem/../config.h:
+
+../../parser/../mem/../dprint.h:
+
+../../parser/../mem/q_malloc.h:
+
+../../parser/../mem/meminfo.h:
+
+../../parser/../mem/src_loc.h:
+
+../../parser/../mem/shm_mem.h:
+
+../../parser/../mem/../lock_ops.h:
+
+../../parser/../mem/../futexlock.h:
+
+../../parser/../mem/../atomic/atomic_common.h:
+
+../../parser/../mem/../atomic/atomic_native.h:
+
+../../parser/../mem/../atomic/atomic_x86.h:
+
+../../parser/../mem/../compiler_opt.h:
+
+../../parser/../md5utils.h:
+
+../../parser/../config.h:
+
+../../parser/parse_def.h:
+
+../../parser/parse_cseq.h:
+
+../../parser/parse_via.h:
+
+../../parser/parse_fline.h:
+
+../../parser/parse_retry_after.h:
+
+../../parser/hf.h:
+
+../../parser/../error.h:
+
+../../parser/contact/contact.h:
+
+../../parser/contact/../../str.h:
+
+../../parser/contact/../parse_param.h:
+
+../../parser/contact/../../str.h:
+
+../../dprint.h:
+
+../../config.h:
+
+../../ut.h:
+
+../../forward.h:
+
+../../globals.h:
+
+../../types.h:
+
+../../ip_addr.h:
+
+../../str.h:
+
+../../poll_types.h:
+
+../../parser/msg_parser.h:
+
+../../route.h:
+
+../../config.h:
+
+../../error.h:
+
+../../route_struct.h:
+
+../../select.h:
+
+../../usr_avp.h:
+
+../../action.h:
+
+../../str_hash.h:
+
+../../hashes.h:
+
+../../mem/mem.h:
+
+../../clist.h:
+
+../../proxy.h:
+
+../../stats.h:
+
+../../udp_server.h:
+
+../../tcp_server.h:
+
+../../tcp_conn.h:
+
+../../tcp_init.h:
+
+../../tcp_options.h:
+
+../../locking.h:
+
+../../lock_ops.h:
+
+../../lock_alloc.h:
+
+../../mem/shm_mem.h:
+
+../../atomic_ops.h:
+
+../../atomic/atomic_common.h:
+
+../../atomic/atomic_native.h:
+
+../../timer_ticks.h:
+
+../../timer.h:
+
+../../dprint.h:
+
+../../sctp_core.h:
+
+../../compiler_opt.h:
+
+../../events.h:
+
+../../resolve.h:
+
+../../counters.h:
+
+../../pt.h:
+
+../../socket_info.h:
+
+../../dns_func.h:
+
+../../dns_wrappers.h:
+
+../../globals.h:
+
+../../udp_server.h:
+
+../../pt.h:
+
+../../trim.h:
+
+../../parser/parse_from.h:
+
+../../parser/parse_to.h:
+
+../../parser/msg_parser.h:
+
+../../parser/parse_addr_spec.h:
+
+../../parser/contact/parse_contact.h:
+
+../../parser/contact/../hf.h:
+
+../../parser/contact/../msg_parser.h:
+
+../../parser/contact/contact.h:
+
+../../parser/parse_uri.h:
+
+../../parser/../parser/msg_parser.h:
+
+../../parser/parse_content.h:
+
+../../parser/parser_f.h:
+
+../../parser/sdp/sdp_helpr_funcs.h:
+
+../../parser/sdp/../../str.h:
+
+../../parser/sdp/../msg_parser.h:
+
+../../parser/sdp/sdp.h:
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/rtpengine_funcs.h ui-siprouter/modules/rtpengine/rtpengine_funcs.h
--- ui-siprouter~/modules/rtpengine/rtpengine_funcs.h	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/rtpengine_funcs.h	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2001-2003 FhG Fokus
+ * Copyright (C) 2014-2015 Sipwise GmbH, http://www.sipwise.com
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * Kamailio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * Kamailio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#ifndef _RTPENGINE_FUNCS_H
+#define _RTPENGINE_FUNCS_H
+
+#include "../../str.h"
+#include "../../parser/msg_parser.h"
+#include "../../parser/contact/contact.h"
+
+int extract_body(struct sip_msg * , str *);
+int check_content_type(struct sip_msg * );
+int get_callid(struct sip_msg *, str *);
+int get_to_tag(struct sip_msg *, str *);
+int get_from_tag(struct sip_msg *, str *);
+int get_contact_uri(struct sip_msg *, struct sip_uri *, contact_t **);
+int get_via_branch(struct sip_msg *, int, str *);
+
+#endif
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/rtpengine_hash.c ui-siprouter/modules/rtpengine/rtpengine_hash.c
--- ui-siprouter~/modules/rtpengine/rtpengine_hash.c	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/rtpengine_hash.c	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,552 @@
+#include "rtpengine_hash.h"
+
+#include "../../str.h"
+#include "../../dprint.h"
+#include "../../mem/shm_mem.h"
+#include "../../locking.h"
+#include "../../timer.h"
+
+static void rtpengine_hash_table_free_row_lock(gen_lock_t *row_lock);
+
+
+static struct rtpengine_hash_table *rtpengine_hash_table;
+
+/* from sipwise rtpengine */
+static int str_cmp_str(const str a, const str b) {
+	if (a.len < b.len)
+		return -1;
+	if (a.len > b.len)
+		return 1;
+	if (a.len == 0 && b.len == 0)
+		return 0;
+	return memcmp(a.s, b.s, a.len);
+}
+
+/* from sipwise rtpengine */
+static int str_equal(str a, str b) {
+	return (str_cmp_str(a, b) == 0);
+}
+
+/* from sipwise rtpengine */
+static unsigned int str_hash(str s) {
+	unsigned int ret = 5381;
+	str it = s;
+
+	while (it.len > 0) {
+		ret = (ret << 5) + ret + *it.s;
+		it.s++;
+		it.len--;
+	}
+
+	return ret % rtpengine_hash_table->size;
+}
+
+/* rtpengine hash API */
+int rtpengine_hash_table_init(int size) {
+	int i;
+	int hash_table_size;
+
+	// init hash table size
+	if (size < 1) {
+		hash_table_size = 1;
+	} else {
+		hash_table_size = size;
+	}
+	LM_DBG("rtpengine_hash_table size = %d\n", hash_table_size);
+
+	// init hashtable
+	rtpengine_hash_table = shm_malloc(sizeof(struct rtpengine_hash_table));
+	if (!rtpengine_hash_table) {
+		LM_ERR("no shm left to create rtpengine_hash_table\n");
+		return 0;
+	}
+	memset(rtpengine_hash_table, 0, sizeof(struct rtpengine_hash_table));
+	rtpengine_hash_table->size = hash_table_size;
+
+	// init hashtable row_locks
+	rtpengine_hash_table->row_locks = shm_malloc(hash_table_size * sizeof(gen_lock_t*));
+	if (!rtpengine_hash_table->row_locks) {
+		LM_ERR("no shm left to create rtpengine_hash_table->row_locks\n");
+		rtpengine_hash_table_destroy();
+		return 0;
+	}
+	memset(rtpengine_hash_table->row_locks, 0, hash_table_size * sizeof(gen_lock_t*));
+
+	// init hashtable row_entry_list
+	rtpengine_hash_table->row_entry_list = shm_malloc(rtpengine_hash_table->size * sizeof(struct rtpengine_hash_entry*));
+	if (!rtpengine_hash_table->row_entry_list) {
+		LM_ERR("no shm left to create rtpengine_hash_table->row_entry_list\n");
+		rtpengine_hash_table_destroy();
+		return 0;
+	}
+	memset(rtpengine_hash_table->row_entry_list, 0, rtpengine_hash_table->size * sizeof(struct rtpengine_hash_entry*));
+
+	// init hashtable row_totals
+	rtpengine_hash_table->row_totals = shm_malloc(hash_table_size * sizeof(unsigned int));
+	if (!rtpengine_hash_table->row_totals) {
+		LM_ERR("no shm left to create rtpengine_hash_table->row_totals\n");
+		rtpengine_hash_table_destroy();
+		return 0;
+	}
+	memset(rtpengine_hash_table->row_totals, 0, hash_table_size * sizeof(unsigned int));
+
+	// init hashtable  row_locks[i], row_entry_list[i] and row_totals[i]
+	for (i = 0; i < hash_table_size; i++) {
+		// alloc hashtable row_locks[i]
+		rtpengine_hash_table->row_locks[i] = lock_alloc();
+		if (!rtpengine_hash_table->row_locks[i]) {
+			LM_ERR("no shm left to create rtpengine_hash_table->row_locks[%d]\n", i);
+			rtpengine_hash_table_destroy();
+			return 0;
+		}
+
+		// init hashtable row_locks[i]
+		if (!lock_init(rtpengine_hash_table->row_locks[i])) {
+			LM_ERR("fail to init rtpengine_hash_table->row_locks[%d]\n", i);
+			rtpengine_hash_table_destroy();
+			return 0;
+		}
+
+		// init hashtable row_entry_list[i]
+		rtpengine_hash_table->row_entry_list[i] = shm_malloc(sizeof(struct rtpengine_hash_entry));
+		if (!rtpengine_hash_table->row_entry_list[i]) {
+			LM_ERR("no shm left to create rtpengine_hash_table->row_entry_list[%d]\n", i);
+			rtpengine_hash_table_destroy();
+			return 0;
+		}
+		memset(rtpengine_hash_table->row_entry_list[i], 0, sizeof(struct rtpengine_hash_entry));
+
+		rtpengine_hash_table->row_entry_list[i]->tout = -1;
+		rtpengine_hash_table->row_entry_list[i]->next = NULL;
+
+		// init hashtable row_totals[i]
+		rtpengine_hash_table->row_totals[i] = 0;
+	}
+
+	return 1;
+}
+
+int rtpengine_hash_table_destroy() {
+	int i;
+
+	// check rtpengine hashtable
+	if (!rtpengine_hash_table) {
+		LM_ERR("NULL rtpengine_hash_table\n");
+		return 1;
+	}
+
+	// check rtpengine hashtable->row_locks
+	if (!rtpengine_hash_table->row_locks) {
+		LM_ERR("NULL rtpengine_hash_table->row_locks\n");
+		shm_free(rtpengine_hash_table);
+		rtpengine_hash_table = NULL;
+		return 1;
+	}
+
+	// destroy hashtable content
+	for (i = 0; i < rtpengine_hash_table->size; i++) {
+		// lock
+		if (!rtpengine_hash_table->row_locks[i]) {
+			LM_ERR("NULL rtpengine_hash_table->row_locks[%d]\n", i);
+			continue;
+		} else {
+			lock_get(rtpengine_hash_table->row_locks[i]);
+		}
+
+		// check rtpengine hashtable->row_entry_list
+		if (!rtpengine_hash_table->row_entry_list) {
+			LM_ERR("NULL rtpengine_hash_table->row_entry_list\n");
+		} else {
+			// destroy hashtable row_entry_list[i]
+			rtpengine_hash_table_free_row_entry_list(rtpengine_hash_table->row_entry_list[i]);
+			rtpengine_hash_table->row_entry_list[i] = NULL;
+		}
+
+		// unlock
+		lock_release(rtpengine_hash_table->row_locks[i]);
+
+		// destroy hashtable row_locks[i]
+		rtpengine_hash_table_free_row_lock(rtpengine_hash_table->row_locks[i]);
+		rtpengine_hash_table->row_locks[i] = NULL;
+	}
+
+	// destroy hashtable row_entry_list
+	if (!rtpengine_hash_table->row_entry_list) {
+		LM_ERR("NULL rtpengine_hash_table->row_entry_list\n");
+	} else {
+		shm_free(rtpengine_hash_table->row_entry_list);
+		rtpengine_hash_table->row_entry_list = NULL;
+	}
+
+	// destroy hashtable row_totals
+	if (!rtpengine_hash_table->row_totals) {
+		LM_ERR("NULL rtpengine_hash_table->row_totals\n");
+	} else {
+		shm_free(rtpengine_hash_table->row_totals);
+		rtpengine_hash_table->row_totals = NULL;
+	}
+
+	// destroy hashtable row_locks
+	if (!rtpengine_hash_table->row_locks) {
+		// should not be the case; just for code symmetry
+		LM_ERR("NULL rtpengine_hash_table->row_locks\n");
+	} else {
+		shm_free(rtpengine_hash_table->row_locks);
+		rtpengine_hash_table->row_locks = NULL;
+	}
+
+	// destroy hashtable
+	if (!rtpengine_hash_table) {
+		// should not be the case; just for code symmetry
+		LM_ERR("NULL rtpengine_hash_table\n");
+	} else {
+		shm_free(rtpengine_hash_table);
+		rtpengine_hash_table = NULL;
+	}
+
+	return 1;
+}
+
+int rtpengine_hash_table_insert(str callid, str viabranch, struct rtpengine_hash_entry *value) {
+	struct rtpengine_hash_entry *entry, *last_entry;
+	struct rtpengine_hash_entry *new_entry = (struct rtpengine_hash_entry *) value;
+	unsigned int hash_index;
+
+	// sanity checks
+	if (!rtpengine_hash_table_sanity_checks()) {
+		LM_ERR("sanity checks failed\n");
+		return 0;
+	}
+
+	// get entry list
+	hash_index = str_hash(callid);
+	entry = rtpengine_hash_table->row_entry_list[hash_index];
+	last_entry = entry;
+
+	// lock
+	if (rtpengine_hash_table->row_locks[hash_index]) {
+		lock_get(rtpengine_hash_table->row_locks[hash_index]);
+	} else {
+		LM_ERR("NULL rtpengine_hash_table->row_locks[%d]\n", hash_index);
+		return 0;
+	}
+
+	while (entry) {
+		// if found, don't add new entry
+		if (str_equal(entry->callid, new_entry->callid) &&
+		    str_equal(entry->viabranch, new_entry->viabranch)) {
+			// unlock
+			lock_release(rtpengine_hash_table->row_locks[hash_index]);
+			LM_NOTICE("callid=%.*s, viabranch=%.*s already in hashtable, ignore new value\n",
+				entry->callid.len, entry->callid.s,
+				entry->viabranch.len, entry->viabranch.s);
+			return 0;
+		}
+
+		// if expired entry discovered, delete it
+		if (entry->tout < get_ticks()) {
+			// set pointers; exclude entry
+			last_entry->next = entry->next;
+
+			// free current entry; entry points to unknown
+			rtpengine_hash_table_free_entry(entry);
+
+			// set pointers
+			entry = last_entry;
+
+			// update total
+			rtpengine_hash_table->row_totals[hash_index]--;
+		}
+
+		// next entry in the list
+		last_entry = entry;
+		entry = entry->next;
+	}
+
+	last_entry->next = new_entry;
+
+	// update total
+	rtpengine_hash_table->row_totals[hash_index]++;
+
+	// unlock
+	lock_release(rtpengine_hash_table->row_locks[hash_index]);
+
+	return 1;
+}
+
+int rtpengine_hash_table_remove(str callid, str viabranch) {
+	struct rtpengine_hash_entry *entry, *last_entry;
+	unsigned int hash_index;
+
+	// sanity checks
+	if (!rtpengine_hash_table_sanity_checks()) {
+		LM_ERR("sanity checks failed\n");
+		return 0;
+	}
+
+	// get first entry from entry list; jump over unused list head
+	hash_index = str_hash(callid);
+	entry = rtpengine_hash_table->row_entry_list[hash_index];
+	last_entry = entry;
+
+	// lock
+	if (rtpengine_hash_table->row_locks[hash_index]) {
+		lock_get(rtpengine_hash_table->row_locks[hash_index]);
+	} else {
+		LM_ERR("NULL rtpengine_hash_table->row_locks[%d]\n", hash_index);
+		return 0;
+	}
+
+	while (entry) {
+		// if callid found, delete entry
+		if (str_equal(entry->callid, callid) &&
+		    str_equal(entry->viabranch, viabranch)) {
+			// free entry
+			last_entry->next = entry->next;
+			rtpengine_hash_table_free_entry(entry);
+
+			// update total
+			rtpengine_hash_table->row_totals[hash_index]--;
+
+			// unlock
+			lock_release(rtpengine_hash_table->row_locks[hash_index]);
+
+			return 1;
+		}
+
+		// if expired entry discovered, delete it
+		if (entry->tout < get_ticks()) {
+			// set pointers; exclude entry
+			last_entry->next = entry->next;
+
+			// free current entry; entry points to unknown
+			rtpengine_hash_table_free_entry(entry);
+
+			// set pointers
+			entry = last_entry;
+
+			// update total
+			rtpengine_hash_table->row_totals[hash_index]--;
+		}
+
+		last_entry = entry;
+		entry = entry->next;
+	}
+
+	// unlock
+	lock_release(rtpengine_hash_table->row_locks[hash_index]);
+
+	return 0;
+}
+
+struct rtpp_node *rtpengine_hash_table_lookup(str callid, str viabranch) {
+	struct rtpengine_hash_entry *entry, *last_entry;
+	unsigned int hash_index;
+	struct rtpp_node *node;
+
+	// sanity checks
+	if (!rtpengine_hash_table_sanity_checks()) {
+		LM_ERR("sanity checks failed\n");
+		return 0;
+	}
+
+	// get first entry from entry list; jump over unused list head
+	hash_index = str_hash(callid);
+	entry = rtpengine_hash_table->row_entry_list[hash_index];
+	last_entry = entry;
+
+	// lock
+	if (rtpengine_hash_table->row_locks[hash_index]) {
+		lock_get(rtpengine_hash_table->row_locks[hash_index]);
+	} else {
+		LM_ERR("NULL rtpengine_hash_table->row_locks[%d]\n", hash_index);
+		return 0;
+	}
+
+	while (entry) {
+		// if callid found, return entry
+		if (str_equal(entry->callid, callid) &&
+		    str_equal(entry->viabranch, viabranch)) {
+			node = entry->node;
+
+			// unlock
+			lock_release(rtpengine_hash_table->row_locks[hash_index]);
+
+			return node;
+		}
+
+		// if expired entry discovered, delete it
+		if (entry->tout < get_ticks()) {
+			// set pointers; exclude entry
+			last_entry->next = entry->next;
+
+			// free current entry; entry points to unknown
+			rtpengine_hash_table_free_entry(entry);
+
+			// set pointers
+			entry = last_entry;
+
+			// update total
+			rtpengine_hash_table->row_totals[hash_index]--;
+		}
+
+		last_entry = entry;
+		entry = entry->next;
+	}
+
+	// unlock
+	lock_release(rtpengine_hash_table->row_locks[hash_index]);
+
+	return NULL;
+}
+
+// print hash table entries while deleting expired entries
+void rtpengine_hash_table_print() {
+	int i;
+	struct rtpengine_hash_entry *entry, *last_entry;
+
+	// sanity checks
+	if (!rtpengine_hash_table_sanity_checks()) {
+		LM_ERR("sanity checks failed\n");
+		return ;
+	}
+
+	// print hashtable
+	for (i = 0; i < rtpengine_hash_table->size; i++) {
+		// lock
+		if (rtpengine_hash_table->row_locks[i]) {
+			lock_get(rtpengine_hash_table->row_locks[i]);
+		} else {
+			LM_ERR("NULL rtpengine_hash_table->row_locks[%d]\n", i);
+			return ;
+		}
+
+		entry = rtpengine_hash_table->row_entry_list[i];
+		last_entry = entry;
+
+		while (entry) {
+			// if expired entry discovered, delete it
+			if (entry->tout < get_ticks()) {
+				// set pointers; exclude entry
+				last_entry->next = entry->next;
+
+				// free current entry; entry points to unknown
+				rtpengine_hash_table_free_entry(entry);
+
+				// set pointers
+				entry = last_entry;
+
+				// update total
+				rtpengine_hash_table->row_totals[i]--;
+			} else {
+				LM_DBG("hash_index=%d callid=%.*s tout=%u\n",
+					i, entry->callid.len, entry->callid.s, entry->tout - get_ticks());
+			}
+
+			last_entry = entry;
+			entry = entry->next;
+		}
+
+		// unlock
+		lock_release(rtpengine_hash_table->row_locks[i]);
+	}
+
+}
+
+unsigned int rtpengine_hash_table_total() {
+	int i;
+	unsigned int total = 0;
+
+	// sanity checks
+	if (!rtpengine_hash_table_sanity_checks()) {
+		LM_ERR("sanity checks failed\n");
+		return 0;
+	}
+
+	for (i = 0; i < rtpengine_hash_table->size; i++) {
+		total += rtpengine_hash_table->row_totals[i];
+	}
+
+	return total;
+}
+
+void rtpengine_hash_table_free_entry(struct rtpengine_hash_entry *entry) {
+	if (!entry) {
+		LM_ERR("try to free a NULL entry\n");
+		return ;
+	}
+
+	// free callid
+	if (entry->callid.s) {
+		shm_free(entry->callid.s);
+	}
+
+	// free viabranch
+	if (entry->viabranch.s) {
+		shm_free(entry->viabranch.s);
+	}
+
+	// free entry
+	shm_free(entry);
+
+	return ;
+}
+
+void rtpengine_hash_table_free_row_entry_list(struct rtpengine_hash_entry *row_entry_list) {
+	struct rtpengine_hash_entry *entry, *last_entry;
+
+	if (!row_entry_list) {
+		LM_ERR("try to free a NULL row_entry_list\n");
+		return ;
+	}
+
+	entry = row_entry_list;
+	while (entry) {
+		last_entry = entry;
+		entry = entry->next;
+		rtpengine_hash_table_free_entry(last_entry);
+		last_entry = NULL;
+	}
+
+	return ;
+}
+
+static void rtpengine_hash_table_free_row_lock(gen_lock_t *row_lock) {
+	if (!row_lock) {
+		LM_ERR("try to free a NULL lock\n");
+		return ;
+	}
+
+	lock_destroy(row_lock);
+	lock_dealloc(row_lock);
+
+	return ;
+}
+
+int rtpengine_hash_table_sanity_checks() {
+	// check rtpengine hashtable
+	if (!rtpengine_hash_table) {
+		LM_ERR("NULL rtpengine_hash_table\n");
+		return 0;
+	}
+
+	// check rtpengine hashtable->row_locks
+	if (!rtpengine_hash_table->row_locks) {
+		LM_ERR("NULL rtpengine_hash_table->row_locks\n");
+		return 0;
+	}
+
+	// check rtpengine hashtable->row_entry_list
+	if (!rtpengine_hash_table->row_entry_list) {
+		LM_ERR("NULL rtpengine_hash_table->row_entry_list\n");
+		return 0;
+	}
+
+	// check rtpengine hashtable->row_totals
+	if (!rtpengine_hash_table->row_totals) {
+		LM_ERR("NULL rtpengine_hash_table->row_totals\n");
+		return 0;
+	}
+
+	return 1;
+}
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/rtpengine_hash.d ui-siprouter/modules/rtpengine/rtpengine_hash.d
--- ui-siprouter~/modules/rtpengine/rtpengine_hash.d	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/rtpengine_hash.d	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,69 @@
+rtpengine_hash.o: rtpengine_hash.c rtpengine_hash.h ../../str.h \
+ ../../locking.h ../../lock_ops.h ../../futexlock.h \
+ ../../atomic/atomic_common.h ../../atomic/atomic_native.h \
+ ../../atomic/atomic_x86.h ../../compiler_opt.h ../../lock_alloc.h \
+ ../../mem/mem.h ../../mem/../config.h ../../mem/../types.h \
+ ../../mem/../dprint.h ../../mem/../compiler_opt.h \
+ ../../mem/../cfg_core.h ../../mem/../cfg/cfg.h ../../mem/../cfg/../str.h \
+ ../../mem/q_malloc.h ../../mem/meminfo.h ../../mem/src_loc.h \
+ ../../mem/shm_mem.h ../../mem/../lock_ops.h ../../dprint.h \
+ ../../mem/shm_mem.h ../../timer.h ../../clist.h ../../dprint.h \
+ ../../timer_ticks.h
+
+rtpengine_hash.h:
+
+../../str.h:
+
+../../locking.h:
+
+../../lock_ops.h:
+
+../../futexlock.h:
+
+../../atomic/atomic_common.h:
+
+../../atomic/atomic_native.h:
+
+../../atomic/atomic_x86.h:
+
+../../compiler_opt.h:
+
+../../lock_alloc.h:
+
+../../mem/mem.h:
+
+../../mem/../config.h:
+
+../../mem/../types.h:
+
+../../mem/../dprint.h:
+
+../../mem/../compiler_opt.h:
+
+../../mem/../cfg_core.h:
+
+../../mem/../cfg/cfg.h:
+
+../../mem/../cfg/../str.h:
+
+../../mem/q_malloc.h:
+
+../../mem/meminfo.h:
+
+../../mem/src_loc.h:
+
+../../mem/shm_mem.h:
+
+../../mem/../lock_ops.h:
+
+../../dprint.h:
+
+../../mem/shm_mem.h:
+
+../../timer.h:
+
+../../clist.h:
+
+../../dprint.h:
+
+../../timer_ticks.h:
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' ui-siprouter~/modules/rtpengine/rtpengine_hash.h ui-siprouter/modules/rtpengine/rtpengine_hash.h
--- ui-siprouter~/modules/rtpengine/rtpengine_hash.h	1970-01-01 02:00:00.000000000 +0200
+++ ui-siprouter/modules/rtpengine/rtpengine_hash.h	2016-02-01 12:31:31.561049098 +0200
@@ -0,0 +1,40 @@
+#ifndef _RTPENGINE_HASH_H
+#define _RTPENGINE_HASH_H
+
+#include "../../str.h"
+#include "../../locking.h"
+
+
+/* table entry */
+struct rtpengine_hash_entry {
+	str callid;				// call callid
+	str viabranch;				// call viabranch
+	struct rtpp_node *node;			// call selected node
+
+	unsigned int tout;			// call timeout
+	struct rtpengine_hash_entry *next;	// call next
+};
+
+/* table */
+struct rtpengine_hash_table {
+	struct rtpengine_hash_entry **row_entry_list;	// vector of size pointers to entry
+	gen_lock_t **row_locks;				// vector of size pointers to locks
+	unsigned int *row_totals;			// vector of size numbers of entries in the hashtable rows
+	unsigned int size;				// hash table size
+};
+
+
+int rtpengine_hash_table_init(int size);
+int rtpengine_hash_table_destroy();
+int rtpengine_hash_table_insert(str callid, str viabranch, struct rtpengine_hash_entry *value);
+int rtpengine_hash_table_remove(str callid, str viabranch);
+struct rtpp_node *rtpengine_hash_table_lookup(str callid, str viabranch);
+void rtpengine_hash_table_print();
+unsigned int rtpengine_hash_table_total();
+
+void rtpengine_hash_table_free_entry(struct rtpengine_hash_entry *entry);
+void rtpengine_hash_table_free_row_entry_list(struct rtpengine_hash_entry *row_entry_list);
+
+int rtpengine_hash_table_sanity_checks();
+
+#endif
